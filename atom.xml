<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aphysia.cn</id>
    <title>秦怀记事本</title>
    <updated>2023-03-15T17:20:23.429Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aphysia.cn"/>
    <link rel="self" href="https://aphysia.cn/atom.xml"/>
    <subtitle>秦怀的杂货铺，欢迎你的到来~</subtitle>
    <logo>https://aphysia.cn/images/avatar.png</logo>
    <icon>https://aphysia.cn/favicon.ico</icon>
    <rights>All rights reserved 2023, 秦怀记事本</rights>
    <entry>
        <title type="html"><![CDATA[Java反射使用说透彻一点]]></title>
        <id>https://aphysia.cn/post/java-fan-she-shi-yong-shuo-tou-che-yi-dian/</id>
        <link href="https://aphysia.cn/post/java-fan-she-shi-yong-shuo-tou-che-yi-dian/">
        </link>
        <updated>2023-03-03T17:17:15.000Z</updated>
        <summary type="html"><![CDATA[<p>很多时候我们会遇到别人问一个问题：你给我讲一下反射，到底是什么东西？怎么实现的？我们能用反射来做什么？它有什么优缺点？下面我们会围绕着这几个问题展开：</p>
]]></summary>
        <content type="html"><![CDATA[<p>很多时候我们会遇到别人问一个问题：你给我讲一下反射，到底是什么东西？怎么实现的？我们能用反射来做什么？它有什么优缺点？下面我们会围绕着这几个问题展开：</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201115212257.png" alt="" loading="lazy"></figure>
<h2 id="一-反射机制是什么">一、反射机制是什么？</h2>
<p><strong>反射是什么？什么是反？什么是正射？</strong><br>
有反就有正，我们知道正常情况， 如果我们希望创建一个对象，会使用以下的语句：</p>
<pre><code class="language-java">Person person = new Person();
</code></pre>
<p>其实我们第一次执行上面的语句的时候，JVM会先加载<code>Person.class</code>，加载到内存完之后，在方法区/堆中会创建了一个<code>Class</code>对象,对应这个<code>Person</code>类。这里有争议，有人说是在方法区，有些人说是在堆。个人感觉应该JVM规范说是在方法区，但是不是强制要求，而且不同版本的JVM实现也不一样。具体参考以下链接，这里不做解释：<br>
https://www.cnblogs.com/xy-nb/p/6773051.html<br>
而上面正常的初始化对象的方法，也可以说是“正射”,就是使用<code>Class</code>对象创建出一个<code>Person</code>对象。</p>
<p>而反射则相反，是根据<code>Person</code>对象，获取到<code>Class</code>对象，然后可以获取到<code>Person</code>类的相关信息，进行初始化或者调用等一系列操作。</p>
<p>在<strong>运行状态时</strong>，可以构造任何一个类的对象，获取到任意一个对象所属的类信息，以及这个类的成员变量或者方法，可以调用任意一个对象的属性或者方法。可以理解为具备了 <strong>动态加载对象</strong> 以及 <strong>对对象的基本信息进行剖析和使用</strong> 的能力。</p>
<p>提供的功能包括：</p>
<ul>
<li>1.在运行时判断一个对象所属的类</li>
<li>2.在运行时构造任意一个类的对象</li>
<li>3.在运行时获取一个类定义的成员变量以及方法</li>
<li>4.在运行时调用任意一个对象的方法</li>
<li>5.生成动态代理</li>
</ul>
<p>灵活，强大，可以在运行时装配，无需在组件之间进行源代码链接，但是使用不当效率会有影响。所有类的对象都是Class的实例。<br>
既然我们可以对类的全限定名，方法以及参数等进行配置，完成对象的初始化，那就是相当于增加了java的可配置性。</p>
<p><strong>这里特别需要明确的一点：类本身也是一个对象，方法也是一个对象，在Java里面万物皆可对象，除了基础数据类型...</strong></p>
<h2 id="二-反射的具体使用">二、反射的具体使用</h2>
<h3 id="21-获取对象的包名以及类名">2.1 获取对象的包名以及类名</h3>
<pre><code class="language-java">package invocation;
public class MyInvocation {
    public static void main(String[] args) {
        getClassNameTest();
    }
    
    public static void getClassNameTest(){
        MyInvocation myInvocation = new MyInvocation();
        System.out.println(&quot;class: &quot; + myInvocation.getClass());
        System.out.println(&quot;simpleName: &quot; + myInvocation.getClass().getSimpleName());
        System.out.println(&quot;name: &quot; + myInvocation.getClass().getName());
        System.out.println(&quot;package: &quot; +
                &quot;&quot; + myInvocation.getClass().getPackage());
    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-java">class: class invocation.MyInvocation
simpleName: MyInvocation
name: invocation.MyInvocation
package: package invocation
</code></pre>
<p>由上面结果我们可以看到：<br>
1.<code>getClass()</code>:打印会带着class+全类名<br>
2.<code>getClass().getSimpleName()</code>：只会打印出类名<br>
3.<code>getName()</code>：会打印全类名<br>
4.<code>getClass().getPackage()</code>:打印出package+包名</p>
<p><code>getClass()</code>获取到的是一个对象，<code>getPackage()</code>也是。</p>
<h3 id="22-获取class对象">2.2 获取Class对象</h3>
<p>在java中，一切皆对象。java中可以分为两种对象，实例对象和Class对象。这里我们说的获取Class对象，其实就是第二种，Class对象代表的是每个类在运行时的类型信息，指和类相关的信息。比如有一个<code>Student</code>类，我们用<code>Student student = new Student()</code>new一个对象出来，这个时候<code>Student</code>这个类的信息其实就是存放在一个对象中，这个对象就是<strong>Class类的对象</strong>，而student这个实例对象也会和<strong>Class对象</strong>关联起来。<br>
我们有三种方式可以获取一个类在运行时的Class对象，分别是</p>
<ul>
<li>Class.forName(&quot;com.Student&quot;)</li>
<li>student.getClass()</li>
<li>Student.class</li>
</ul>
<p>实例代码如下：</p>
<pre><code class="language-java">package invocation;

public class MyInvocation {
    public static void main(String[] args) {
        getClassTest();
    }
    public static void getClassTest(){
        Class&lt;?&gt; invocation1 = null;
        Class&lt;?&gt; invocation2 = null;
        Class&lt;?&gt; invocation3 = null;
        try {
            // 最常用的方法
            invocation1 = Class.forName(&quot;invocation.MyInvocation&quot;);
        }catch (Exception ex){
            ex.printStackTrace();
        }
        invocation2 = new MyInvocation().getClass();
        invocation3 = MyInvocation.class;
        System.out.println(invocation1);
        System.out.println(invocation2);
        System.out.println(invocation3);
    }
}
</code></pre>
<p>执行的结果如下,三个结果一样：</p>
<pre><code>class invocation.MyInvocation
class invocation.MyInvocation
class invocation.MyInvocation
</code></pre>
<h3 id="23-getinstance获取指定类型的实例化对象">2.3 getInstance()获取指定类型的实例化对象</h3>
<p>首先我们有一个Student类，后面都会沿用这个类，将不再重复。</p>
<pre><code class="language-java">class Student{
    private int age;

    private String name;

    public Student() {
    }
    public Student(int age) {
        this.age = age;
    }

    public Student(String name) {
        this.name = name;
    }
    
    public Student(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;Student{&quot; +
                &quot;age=&quot; + age +
                &quot;, name='&quot; + name + '\'' +
                '}';
    }
</code></pre>
<p>我们可以使用<code>getInstance()</code>方法构造出一个Student的对象：</p>
<pre><code class="language-java">    public static void getInstanceTest() {
        try {
            Class&lt;?&gt; stduentInvocation = Class.forName(&quot;invocation.Student&quot;);
            Student student = (Student) stduentInvocation.newInstance();
            student.setAge(9);
            student.setName(&quot;Hahs&quot;);
            System.out.println(student);

        }catch (Exception ex){
            ex.printStackTrace();
        }
    }
    
    
输出结果如下：
Student{age=9, name='Hahs'}
</code></pre>
<p>但是如果我们取消不写Student的无参构造方法呢？就会出现下面的报错：</p>
<pre><code class="language-java">java.lang.InstantiationException: invocation.Student
	at java.lang.Class.newInstance(Class.java:427)
	at invocation.MyInvocation.getInstanceTest(MyInvocation.java:40)
	at invocation.MyInvocation.main(MyInvocation.java:8)
Caused by: java.lang.NoSuchMethodException: invocation.Student.&lt;init&gt;()
	at java.lang.Class.getConstructor0(Class.java:3082)
	at java.lang.Class.newInstance(Class.java:412)
	... 2 more
</code></pre>
<p>这是因为我们重写了构造方法，而且是有参构造方法，如果不写构造方法，那么每个类都会默认有无参构造方法，重写了就不会有无参构造方法了，所以我们调用<code>newInstance()</code>的时候，会报没有这个方法的错误。值得注意的是,<code>newInstance()</code>是一个无参构造方法。</p>
<h3 id="24-通过构造函数对象实例化对象">2.4 通过构造函数对象实例化对象</h3>
<p>除了<code>newInstance()</code>方法之外，其实我们还可以通过构造函数对象获取实例化对象，怎么理解？这里只构造函数对象，而不是构造函数，也就是构造函数其实就是一个对象，我们先获取构造函数对象，当然也可以使用来实例化对象。</p>
<p>可以先获取一个类的所有的构造方法，然后遍历输出：</p>
<pre><code class="language-java">    public static void testConstruct(){
        try {
            Class&lt;?&gt; stduentInvocation = Class.forName(&quot;invocation.Student&quot;);
            Constructor&lt;?&gt; cons[] = stduentInvocation.getConstructors();
            for(int i=0;i&lt;cons.length;i++){
                System.out.println(cons[i]);
            }

        }catch (Exception ex){
            ex.printStackTrace();
        }
    }
</code></pre>
<p>输出结果：</p>
<pre><code class="language-java">public invocation.Student(int,java.lang.String)
public invocation.Student(java.lang.String)
public invocation.Student(int)
public invocation.Student()
</code></pre>
<p>取出一个构造函数我们可以获取到它的各种信息，包括参数，参数个数，类型等等：</p>
<pre><code class="language-java">    public static void constructGetInstance() {
        try {
            Class&lt;?&gt; stduentInvocation = Class.forName(&quot;invocation.Student&quot;);
            Constructor&lt;?&gt; cons[] = stduentInvocation.getConstructors();
            Constructor constructors = cons[0];
            System.out.println(&quot;name: &quot; + constructors.getName());
            System.out.println(&quot;modifier: &quot; + constructors.getModifiers());
            System.out.println(&quot;parameterCount: &quot; + constructors.getParameterCount());
            System.out.println(&quot;构造参数类型如下：&quot;);
            for (int i = 0; i &lt; constructors.getParameterTypes().length; i++) {
                System.out.println(constructors.getParameterTypes()[i].getName());
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
</code></pre>
<p>输出结果,<code>modifier</code>是权限修饰符，1表示为<code>public</code>，我们可以知道获取到的构造函数是两个参数的，第一个是int，第二个是String类型，看来获取出来的顺序并不一定是我们书写代码的顺序。</p>
<pre><code class="language-java">name: invocation.Student
modifier: 1
parameterCount: 2
构造参数类型如下：
int
java.lang.String
</code></pre>
<p>既然我们可以获取到构造方法这个对象了，那么我们可不可以通过它去构造一个对象呢？<strong>答案肯定是可以！！！</strong><br>
下面我们用不同的构造函数来创建对象：</p>
<pre><code class="language-java">    public static void constructGetInstanceTest() {
        try {
            Class&lt;?&gt; stduentInvocation = Class.forName(&quot;invocation.Student&quot;);
            Constructor&lt;?&gt; cons[] = stduentInvocation.getConstructors();
            // 一共定义了4个构造器
            Student student1 = (Student) cons[0].newInstance(9,&quot;Sam&quot;);
            Student student2 = (Student) cons[1].newInstance(&quot;Sam&quot;);
            Student student3 = (Student) cons[2].newInstance(9);
            Student student4 = (Student) cons[3].newInstance();
            System.out.println(student1);
            System.out.println(student2);
            System.out.println(student3);
            System.out.println(student4);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
</code></pre>
<p>输出如下：</p>
<pre><code class="language-java">Student{age=9, name='Sam'}
Student{age=0, name='Sam'}
Student{age=9, name='null'}
Student{age=0, name='null'}
</code></pre>
<p>构造器的顺序我们是必须一一针对的，要不会报一下的参数不匹配的错误：</p>
<pre><code class="language-java">java.lang.IllegalArgumentException: argument type mismatch
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at invocation.MyInvocation.constructGetInstanceTest(MyInvocation.java:85)
	at invocation.MyInvocation.main(MyInvocation.java:8)
</code></pre>
<h3 id="25-获取类继承的接口">2.5 获取类继承的接口</h3>
<p>通过反射我们可以获取接口的方法，如果我们知道某个类实现了接口的方法，同样可以做到通过类名创建对象调用到接口的方法。</p>
<p>首先我们定义两个接口，一个<code>InSchool</code>:</p>
<pre><code class="language-java">public interface InSchool {
    public void attendClasses();
}
</code></pre>
<p>一个<code>AtHome</code>:</p>
<pre><code class="language-java">public interface AtHome {
    public void doHomeWork();
}
</code></pre>
<p>创建一个实现两个接口的类<code>Student.java</code></p>
<pre><code class="language-java">public class Student implements AtHome, InSchool {
    public void doHomeWork() {
        System.out.println(&quot;I am a student,I am doing homework at home&quot;);
    }

    public void attendClasses() {
        System.out.println(&quot;I am a student,I am attend class in school&quot;);
    }
}
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws Exception {
        Class&lt;?&gt; studentClass = Class.forName(&quot;invocation.Student&quot;);
        Class&lt;?&gt;[] interfaces = studentClass.getInterfaces();
        for (Class c : interfaces) {
            // 获取接口
            System.out.println(c);
            // 获取接口里面的方法
            Method[] methods = c.getMethods();
            // 遍历接口的方法
            for (Method method : methods) {
                // 通过反射创建对象
                Student student = (Student) studentClass.newInstance();
                // 通过反射调用方法
                method.invoke(student, null);
            }
        }
    }
}
</code></pre>
<p>结果如下：<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201114003042.png" alt="" loading="lazy"></p>
<p>可以看出其实我们可以获取到接口的数组，并且里面的顺序是我们继承的顺序，通过接口的<strong>Class对象</strong>，我们可以获取到接口的方法，然后通过方法反射调用实现类的方法，因为这是一个无参数的方法，所以只需要传null即可。</p>
<h3 id="26-获取父类相关信息">2.6 获取父类相关信息</h3>
<p>主要是使用<code>getSuperclass()</code>方法获取父类，当然也可以获取父类的方法，执行父类的方法,首先创建一个<code>Animal.java</code>:</p>
<pre><code class="language-java">public class Animal {
    public void doSomething(){
        System.out.println(&quot;animal do something&quot;);
    }
}
</code></pre>
<p><code>Dog.java</code>继承于<code>Animal.java</code>：</p>
<pre><code class="language-java">public class Dog extends Animal{
    public void doSomething(){
        System.out.println(&quot;Dog do something&quot;);
    }
}
</code></pre>
<p>我们可以通过反射创建<code>Dog</code>对象，获取其父类<code>Animal</code>以及创建对象，当然也可以获取<code>Animal</code>的默认父类<code>Object</code>：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) throws Exception {
        Class&lt;?&gt; dogClass = Class.forName(&quot;invocation02.Dog&quot;);
        System.out.println(dogClass);
        invoke(dogClass);

        Class&lt;?&gt; animalClass = dogClass.getSuperclass();
        System.out.println(animalClass);
        invoke(animalClass);

        Class&lt;?&gt; objectClass = animalClass.getSuperclass();
        System.out.println(objectClass);
        invoke(objectClass);
    }

    public static void invoke(Class&lt;?&gt; myClass) throws Exception {
        Method[] methods = myClass.getMethods();
        // 遍历接口的方法
        for (Method method : methods) {
            if (method.getName().equalsIgnoreCase(&quot;doSomething&quot;)) {
                // 通过反射调用方法
                method.invoke(myClass.newInstance(), null);
            }
        }
    }
}
</code></pre>
<p>输入如下：<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201114144931.png" alt="" loading="lazy"></p>
<h3 id="27-获取当前类的公有属性和私有属性以及更新">2.7 获取当前类的公有属性和私有属性以及更新</h3>
<p>创建一个<code>Person.java</code>,里面有静态变量，非静态变量，以及<code>public</code>，<code>protected</code>,<code>private</code>不同修饰的属性。</p>
<pre><code class="language-java">public class Person {

    public static String type ;

    private static String subType ;

    // 名字（公开）
    public String name;

    protected String gender;

    private String address;

    @Override
    public String toString() {
        return &quot;Person{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, address='&quot; + address + '\'' +
                '}';
    }
}
</code></pre>
<p>使用<code>getFields()</code>可以获取到public的属性，包括static属性，使用<code>getDeclaredFields()</code>可以获取所有声明的属性，不管是<code>public</code>，<code>protected</code>,<code>private</code>不同修饰的属性。</p>
<p>修改<code>public</code>属性,只需要<code>field.set(object，value)</code>即可，但是<code>private</code>属性不能直接set，否则会报以下的错误。</p>
<pre><code class="language-java">Exception in thread &quot;main&quot; java.lang.IllegalAccessException: Class invocation03.Tests can not access a member of class invocation03.Person with modifiers &quot;private&quot;
	at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102)
	at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296)
	at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288)
	at java.lang.reflect.Field.set(Field.java:761)
	at invocation03.Tests.main(Tests.java:21)
</code></pre>
<p>那么需要怎么做呢？private默认是不允许外界操作其值的，这里我们可以使用<code>field.setAccessible(true);</code>，相当于打开了操作的权限。</p>
<p>那static的属性修改和非static的一样，但是我们怎么获取呢？<br>
如果是<code>public</code>修饰的，可以直接用类名获取到，如果是<code>private</code>修饰的，那么需要使用<code>filed.get(object)</code>,这个方法其实对上面说的所有的属性都可以的。<br>
测试代码如下</p>
<pre><code class="language-java">public class Tests {
    public static void main(String[] args) throws Exception{
        Class&lt;?&gt; personClass = Class.forName(&quot;invocation03.Person&quot;);
        Field[] fields = personClass.getFields();
        // 获取公开的属性
        for(Field field:fields){
            System.out.println(field);
        }
        System.out.println(&quot;=================&quot;);
        // 获取所有声明的属性
        Field[] declaredFields = personClass.getDeclaredFields();
        for(Field field:declaredFields){
            System.out.println(field);
        }
        System.out.println(&quot;=================&quot;);
        Person person = (Person) personClass.newInstance();
        person.name = &quot;Sam&quot;;
        System.out.println(person);

        // 修改public属性
        Field fieldName = personClass.getDeclaredField(&quot;name&quot;);
        fieldName.set(person,&quot;Jone&quot;);

        // 修改private属性
        Field addressName = personClass.getDeclaredField(&quot;address&quot;);
        // 需要修改权限
        addressName.setAccessible(true);
        addressName.set(person,&quot;东风路47号&quot;);
        System.out.println(person);

        // 修改static 静态public属性
        Field typeName = personClass.getDeclaredField(&quot;type&quot;);
        typeName.set(person,&quot;人类&quot;);
        System.out.println(Person.type);

        // 修改静态 private属性
        Field subType = personClass.getDeclaredField(&quot;subType&quot;);
        subType.setAccessible(true);
        subType.set(person,&quot;黄种人&quot;);
        System.out.println(subType.get(person));
    }
}
</code></pre>
<p>结果：<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201114162617.png" alt="" loading="lazy"></p>
<p>从结果可以看出，不管是<code>public</code>，还是<code>protected</code>，<code>private</code>修饰的，我们都可以通过反射对其进行查询和修改，不管是静态变量还是非静态变量。<br>
<code>getDeclaredField()</code>可以获取到所有声明的属性，而<code>getFields()</code>则只能获取到<code>public</code>的属性。对于非public的属性，我们需要修改其权限才能访问和修改：<code>field.setAccessible(true)</code>。</p>
<p>获取属性值需要使用<code>field.get(object)</code>，值得注意的是：<strong>每个属性，其本身就是对象</strong></p>
<h3 id="28-获取以及调用类的公有私有方法">2.8 获取以及调用类的公有/私有方法</h3>
<p>既然可以获取到公有属性和私有属性，那么我想，执行公有方法和私有方法应该都不是什么问题？<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201115211213.png" alt="" loading="lazy"></p>
<p>那下面我们一起来学习一下...</p>
<p>先定义一个类，包含各种修饰符，以及是否包含参数，是否为静态方法，<code>Person.java</code>:</p>
<pre><code class="language-java">public class Person {
    // 非静态公有无参数
    public void read(){
        System.out.println(&quot;reading...&quot;);
    }

    // 非静态公有无参数有返回
    public String getName(){
        return &quot;Sam&quot;;
    }

    // 非静态公有带参数   
    public int readABookPercent(String name){
        System.out.println(&quot;read &quot;+name);
        return 80;
    }

    // 私有有返回值
    private String getAddress(){
        return &quot;东方路&quot;;
    }

    // 公有静态无参数无返回值
    public static void staticMethod(){
        System.out.println(&quot;static public method&quot;);
    }

    // 公有静态有参数
    public static void staticMethodWithArgs(String args){
        System.out.println(&quot;static public method:&quot;+args);
    }

    // 私有静态方法
    private static void staticPrivateMethod(){
        System.out.println(&quot;static private method&quot;);
    }
}
</code></pre>
<p>首先我们来看看获取里面所有的方法：</p>
<pre><code class="language-java">public class Tests {
    public static void main(String[] args) throws Exception {
        Class&lt;?&gt; personClass = Class.forName(&quot;invocation03.Person&quot;);
        Method[] methods = personClass.getMethods();
        for (Method method : methods) {
            System.out.println(method);
        }

        System.out.println(&quot;=============================================&quot;);
        Method[] declaredMethods = personClass.getDeclaredMethods();
        for (Method method : declaredMethods) {
            System.out.println(method);
        }
    }
}
</code></pre>
<p>结果如下：<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116000934.png" alt="" loading="lazy"><br>
咦，我们发现<code>getMethods()</code>确实可以获取所有的公有的方法，但是有一个问题，就是他会把父类的也获取到，也就是上面图片绿色框里面的，我们知道所有的类默认都继承了<code>Object</code>类，所以它把<code>Object</code>的那些方法都获取到了。<br>
而<code>getDeclaredMethods</code>确实可以获取到公有和私有的方法，不管是静态还是非静态，但是它是获取不到父类的方法的。</p>
<p>那如果我们想调用方法呢？先试试调用非静态方法：</p>
<pre><code class="language-java">public class Tests {
    public static void main(String[] args) throws Exception {
        Class&lt;?&gt; personClass = Class.forName(&quot;invocation03.Person&quot;);
        Person person = (Person) personClass.newInstance();
        Method[] declaredMethods = personClass.getDeclaredMethods();
        for (Method method : declaredMethods) {
            if(method.getName().equalsIgnoreCase(&quot;read&quot;)){
                method.invoke(person,null);
                System.out.println(&quot;===================&quot;);
            }else if(method.getName().equalsIgnoreCase(&quot;getName&quot;)){
                System.out.println(method.invoke(person,null));
                System.out.println(&quot;===================&quot;);
            }else if(method.getName().equalsIgnoreCase(&quot;readABookPercent&quot;)){
                System.out.println(method.invoke(person,&quot;Sam&quot;));
                System.out.println(&quot;===================&quot;);
            }
        }

    }
}
</code></pre>
<p>结果如下，可以看出<code>method.invoke(person,null);</code>是调用无参数的方法，而<code>method.invoke(person,&quot;Sam&quot;)</code>则是调用有参数的方法，要是有更多参数，也只需要在里面多加一个参数即可，返回值也同样可以获取到。<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116001756.png" alt="" loading="lazy"></p>
<p>那么<code>private</code>方法呢？我们照着来试试，试试就试试，who 怕 who？</p>
<pre><code class="language-java">public class Tests {
    public static void main(String[] args) throws Exception {
        Class&lt;?&gt; personClass = Class.forName(&quot;invocation03.Person&quot;);
        Person person = (Person) personClass.newInstance();
        Method[] declaredMethods = personClass.getDeclaredMethods();
        for (Method method : declaredMethods) {
            if(method.getName().equalsIgnoreCase(&quot;getAddress&quot;)){
                method.invoke(person,null);
            }
        }

    }
}
</code></pre>
<p>结果报错了：</p>
<pre><code class="language-java">Exception in thread &quot;main&quot; java.lang.IllegalAccessException: Class invocation03.Tests can not access a member of class invocation03.Person with modifiers &quot;private&quot;
	at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102)
	at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296)
	at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288)
	at java.lang.reflect.Method.invoke(Method.java:491)
	at invocation03.Tests.main(Tests.java:13)
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116002147.png" alt="" loading="lazy"></figure>
<p>一看就是没有权限，小场面，不要慌，我来操作一波,只要加上</p>
<pre><code class="language-java">method.setAccessible(true);
</code></pre>
<p>哦豁，完美解决了...<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116002514.png" alt="" loading="lazy"></p>
<p>那么问题来了，上面说的都是非静态的，我就想要调用静态的方法。<br>
当然用上面的方法，对象也可以直接调用到类的方法的：<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116002936.png" alt="" loading="lazy"></p>
<p>一点问题都没有，为什么输出结果有几个null,那是因为这函数是无返回值的呀，笨蛋...</p>
<p>如果我不想用遍历方法的方式，再去判断怎么办？能不能直接获取到我想要的方法啊？那答案肯定是可以啊。</p>
<pre><code class="language-java">public class Tests {
    public static void main(String[] args) throws Exception {
        Class&lt;?&gt; personClass = Class.forName(&quot;invocation03.Person&quot;);
        Person person = (Person) personClass.newInstance();
        Method method = personClass.getMethod(&quot;readABookPercent&quot;, String.class);
        method.invoke(person, &quot;唐诗三百首&quot;);
    }
}
</code></pre>
<p>结果和上面调用的完全一样，图我就不放了，就一行字。要是这个方法没有参数呢？那就给一个null就可以啦。或者不给也可以。</p>
<pre><code class="language-java">public class Tests {
    public static void main(String[] args) throws Exception {
        Class&lt;?&gt; personClass = Class.forName(&quot;invocation03.Person&quot;);
        Person person = (Person) personClass.newInstance();
        Method method = personClass.getMethod(&quot;getName&quot;,null);
        System.out.println(method.invoke(person));
    }
}
</code></pre>
<h2 id="三-反射的优缺点">三、反射的优缺点</h2>
<h3 id="31-优点">3.1 优点</h3>
<p>反射可以在不知道会运行哪一个类的情况下，获取到类的信息，创建对象以及操作对象。这其实很方便于拓展，所以反射会是框架设计的灵魂，因为框架在设计的时候，为了降低耦合度，肯定是需要考虑拓展等功能的，不能将类型写死，硬编码。</p>
<p>降低耦合度，变得很灵活，在运行时去确定类型，绑定对象，体现了多态功能。</p>
<h3 id="32-缺点">3.2 缺点</h3>
<p>这么好用，没有缺点？怎么可能！！！有利就有弊，事物都是有双面性的。<br>
即使功能很强大，但是反射是需要动态类型的，<code>JVM</code>没有办法优化这部分代码，执行效率相对直接初始化对象较低。一般业务代码不建议使用。</p>
<p>反射可以修改权限，比如上面访问到<code>private</code>这些方法和属性，这是会破坏封装性的，有安全隐患，有时候，还会破坏单例的设计。</p>
<p>反射会使代码变得复杂，不容易维护，毕竟代码还是要先写给人看的嘛，逃~</p>
<p><strong>【作者简介】</strong>：<br>
秦怀，公众号【<strong>秦怀杂货店</strong>】作者，技术之路不在一时，山高水长，纵使缓慢，驰而不息。这个世界希望一切都很快，更快，但是我希望自己能走好每一步，写好每一篇文章，期待和你们一起交流。</p>
<p>此文章仅代表自己（本菜鸟）学习积累记录，或者学习笔记，如有侵权，请联系作者核实删除。人无完人，文章也一样，文笔稚嫩，在下不才，勿喷，如果有错误之处，还望指出，感激不尽~</p>
<figure data-type="image" tabindex="3"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201012000828.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java native关键字]]></title>
        <id>https://aphysia.cn/post/java-native-guan-jian-zi/</id>
        <link href="https://aphysia.cn/post/java-native-guan-jian-zi/">
        </link>
        <updated>2023-03-03T17:16:18.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>今天一不小心跟进Object的源码中，发现一个<code>native</code>关键字，一脸蒙蔽，怎么我从来没有用过。</p>
]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>今天一不小心跟进Object的源码中，发现一个<code>native</code>关键字，一脸蒙蔽，怎么我从来没有用过。</p>
<!-- more -->
<pre><code class="language-java">// 这是计算对象的hsahcode的方法，涉及到内存地址
public native int hashCode();
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201118222529.png" alt="" loading="lazy"></figure>
<p>1.汇编生<code>c</code>,<code>c</code>生万物,其实java要实现对底层的控制，还是需要<code>c/c++</code>帮忙，老大毕竟是老大。</p>
<p>2.<code>native</code>关键字我们开发应用的时候是用不到的，那什么时候用到呢？那些开发<strong>java语言</strong>的时候用到，<code>native</code>关键字是与<code>c++</code>联合开发的时候使用的，要不java控制不了底层啊，比如内存。所以还是那句：汇编生<code>c</code>,<code>c</code>生万物，<code>c++</code>是<code>c</code>的升级版。</p>
<p>3.这是<code>java</code>调用其他地方的接口的一个声明关键字，意思是这个方法不是java实现的,有挺多的编程语言都有这样的特性，比如<code>c++</code>里面使用<code>extern &quot;c&quot;</code>来表示告诉c++编译器去调用c里面已经实现好的函数，而不是自己去实现。<code>native</code>方法有点像<code>java</code> 里面的<code>interface</code>，都不用去实现，而是有别人去实现，但是<code>interface</code>是谁实现接口谁实现，<code>native</code>方法是直接交给<code>c/c++</code>来实现。<code>java</code>只能调用，由操作系统实现。</p>
<p>4.<code>native</code>方法不能与<code>abstract</code>方法一起使用，因为<code>native</code>表示这些方法是有实现体的，但是<code>abstract</code>却表示这些方法是没有实现体的，那么两者矛盾，肯定也不能一起使用。</p>
<h2 id="1怎么调用到native方法的呢">1.怎么调用到native方法的呢？</h2>
<p>上面说<code>native</code>表示这个方法不是<code>java</code>实现的，那么就不是原生态方法，也就不会存在这个文件中，而是存在其他地方，那么java要怎么调用才能调用到呢？</p>
<blockquote>
<ul>
<li>JNI(Java Native Interface)这是一个本机编程的接口，它也是java jdk（开发工具包）的一部分，JNI可以支持java中使用其他语言，java要调用其他语言的接口，需要经过他处理。java所谓的跨平台，在一定程度上放弃了底层操作，因为不同的硬件或者操作系统底层的操作都是不一样的。</li>
</ul>
</blockquote>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/img_convert/31426e38350ffdfdc9bd09b72d13e877.png" alt="" loading="lazy"></figure>
<p>那么我们现在来写一个程序：<code>helloWorld.java</code>(我的所有写的文件都放在桌面，同个文件夹即可)</p>
<pre><code class="language-java">public class helloworld{
  static
  {
    System.loadLibrary(&quot;cSayHello&quot;);
  }
  public static native void hello();
  @SuppressWarnings(&quot;static-access&quot;)
  public static void main(String[] args){
    new helloworld().hello();
  }
}
</code></pre>
<p>直接在编译器运行这段代码会出现下面错误：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/img_convert/9dee6cd8edb7a01ef8ebbded3d949a3e.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="4"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201118223648.png" alt="" loading="lazy"></figure>
<p>上面的错误是说找不到<code>cSayHello</code>:<code>no cSayHello in java.library.path</code>,所以啊，这个<code>c/c++</code>的方法我们要自己实现，毕竟我们用的不是操作系统以及定义好的方法。<br>
所以我们先来，使用cmd <strong>在helloworld.java所在的目录下</strong> 使用命令行:</p>
<pre><code class="language-shell">javac helloworld
javah helloworld
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/img_convert/db0557017bfcf65baf30b09cdfe13529.png" alt="" loading="lazy"></figure>
<p>然后我们可以看到<strong>在helloworld.java所在的目录下</strong>多了两个文件，一个是<strong>helloworld.class</strong>文件,一个是<strong>helloworld.h</strong>文件。</p>
<p>打开<strong>helloworld.h</strong>,里面引用了<strong>jni.h</strong>这个文件，这个文件在我们安装的<code>java</code>目录下面的<code>include</code>文件下:</p>
<pre><code class="language-java">/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class helloworld */

#ifndef _Included_helloworld
#define _Included_helloworld
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     helloworld
 * Method:    hello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_helloworld_hello
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
</code></pre>
<p>我的<code>java</code>是装在<code>D盘</code>下面：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/img_convert/c4244e20fac830111b6b8c9dcc12e6c2.png" alt="" loading="lazy"></figure>
<p>我们来写需要引入的<code>c</code>文件<code>cSayHello</code>,我也是放在桌面，反正同一个文件夹就可以。</p>
<pre><code class="language-C++">#include &quot;helloworld.h&quot;
#include &lt;stdio.h&gt;
 
JNIEXPORT void JNICALL Java_helloworld_hello(JNIEnv *env, jclass jc)
{
    printf(&quot;java helloworld&quot;);    
}
</code></pre>
<p>在<code>windows</code>系统上，需要下载安装<code>WinGW Gcc</code>，安装教程参考https://www.jianshu.com/p/535a3131ccd8, 安装成功<code>cmd</code>输入：</p>
<pre><code class="language-shell">gcc -m64  -Wl,--add-stdcall-alias -I&quot;D:\Java\jdk1.8.0_111\include&quot; -I&quot;D:\Java\jdk1.8.0_111\include\win32&quot; -shared -o cSayHello.dll helloworld.c
</code></pre>
<p>然后直接运行,就可以看到输出了</p>
<pre><code class="language-java">java helloworld
</code></pre>
<h2 id="2-java调用自定义native方法步骤">2. java调用自定义native方法步骤</h2>
<p>在java中使用native的步骤：<br>
1.在java代码中声明native方法<br>
2.执行javah来生成一个.h文件<br>
3.写.cpp文件来实现native导出的方法，需要包含上面第二步产生的.h文件，同时也包含了jdk自带的jni.h<br>
4.将第三步的.cpp文件通过gcc 编译成动态链接库文件<br>
5.在java中使用的用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问<br>
一般情况下，我们jdk中声明的native方法，在编译的时候都会自动去加载动态链接库文件，而不需要我们自己去操作了。</p>
<h2 id="3使用native的缺点">3.使用native的缺点</h2>
<p>使用native的缺点：可移植性差，把对底层的控制权交给其他语言，那么也会出现不稳定性，庆幸的是现在操作系统的底层实现基本不会改变。上面hsahcode()的计算真是通过内存所在的内存块来计算的，java是无法直接操作内存的。</p>
<p><strong>【作者简介】</strong>：<br>
秦怀，公众号【<strong>秦怀杂货店</strong>】作者，技术之路不在一时，山高水长，纵使缓慢，驰而不息。这个世界希望一切都很快，更快，但是我希望自己能走好每一步，写好每一篇文章，期待和你们一起交流。</p>
<p>此文章仅代表自己（本菜鸟）学习积累记录，或者学习笔记，如有侵权，请联系作者核实删除。人无完人，文章也一样，文笔稚嫩，在下不才，勿喷，如果有错误之处，还望指出，感激不尽~</p>
<figure data-type="image" tabindex="7"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201012000828.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[缓存穿透，缓存击穿，缓存雪崩的区别以及解决方案]]></title>
        <id>https://aphysia.cn/post/huan-cun-chuan-tou-huan-cun-ji-chuan-huan-cun-xue-beng-de-qu-bie-yi-ji-jie-jue-fang-an/</id>
        <link href="https://aphysia.cn/post/huan-cun-chuan-tou-huan-cun-ji-chuan-huan-cun-xue-beng-de-qu-bie-yi-ji-jie-jue-fang-an/">
        </link>
        <updated>2023-03-03T17:14:20.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数据，可以直接返回空。</p>
]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数据，可以直接返回空。</p>
<!-- more -->
<p>关于缓存，一般会有以下几个常见的问题</p>
<h2 id="缓存穿透">缓存穿透</h2>
<p>缓存穿透是指，<strong>缓存和数据库都没有的数据</strong>，被大量请求，比如订单号不可能为<code>-1</code>，但是用户请求了大量订单号为<code>-1</code>的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。<br>
如果被恶意用户利用，疯狂请求不存在的数据，就会导致数据库压力过大，甚至垮掉。</p>
<p>注意：穿透的意思是，都没有，直接一路打到数据库。</p>
<p><strong>那对于这种情况，我们该如何解决呢？</strong></p>
<ol>
<li>接口增加业务层级的<code>Filter</code>，进行合法校验，这可以有效拦截大部分不合法的请求。</li>
<li>作为第一点的补充，最常见的是使用布隆过滤器，针对一个或者多个维度，把可能存在的数据值hash到bitmap中，bitmap证明该数据不存在则该数据一定不存在，但是bitmap证明该数据存在也只能是可能存在，因为不同的数值hash到的bit位很有可能是一样的，hash冲突会导致误判，多个hash方法也只能是降低冲突的概率，无法做到避免。</li>
<li>另外一个常见的方法，则是针对数据库与缓存都没有的数据，对空的结果进行缓存，但是过期时间设置得较短，一般五分钟内。而这种数据，如果数据库有写入，或者更新，必须同时刷新缓存，否则会导致不一致的问题存在。</li>
</ol>
<h2 id="缓存击穿">缓存击穿</h2>
<p>缓存击穿是指数据库原本有得数据，但是缓存中没有，一般是缓存突然失效了，这时候如果有大量用户请求该数据，缓存没有则会去数据库请求，会引发数据库压力增大，可能会瞬间打垮。</p>
<p>针对这类问题，一般有以下做法：</p>
<ol>
<li>如果是热点数据，那么可以考虑设置永远不过期。</li>
<li>如果数据一定会过期，那么就需要在数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，要不其他线程会一直拿不到锁。</li>
</ol>
<p>下面是缓存击穿的时候互斥锁的写法，注意：获取锁之后操作，不管成功或者失败，都应该释放锁，而其他的请求，如果没有获取到锁，应该等待，再重试。当然，如果是需要更加全面一点，应该加上一个等待次数，比如1s中，那么也就是睡眠五次，达到这个阈值，则直接返回空，不应该过度消耗机器，以免当个不可用的场景把整个应用的服务器带挂了。</p>
<pre><code class="language-java">    public static String getProductDescById(String id) {
        String desc = redis.get(id);
        // 缓存为空，过期了
        if (desc == null) {
            // 互斥锁，只有一个请求可以成功
            if (redis.setnx(lock_id, 1, 60) == 1) {
                try {
                    // 从数据库取出数据
                    desc = getFromDB(id);
                    redis.set(id, desc, 60 * 60 * 24);
                } catch (Exception ex) {
                    LogHelper.error(ex);
                } finally {
                    // 确保最后删除，释放锁
                    redis.del(lock_id);
                    return desc;
                }
            } else {
                // 否则睡眠200ms，接着获取锁
                Thread.sleep(200);
                return getProductDescById(id);
            }
        }
    }
</code></pre>
<h2 id="缓存雪崩">缓存雪崩</h2>
<p>缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。</p>
<p>针对这种情况，一般我们都是使用以下方案：</p>
<ol>
<li>如果是热点数据，那么可以考虑设置永远不过期。</li>
<li>缓存的过期时间除非比较严格，要不考虑设置一个波动随机值，比如理论十分钟，那这类key的缓存时间都加上一个1<sub>3分钟，过期时间在7</sub>13分钟内波动，有效防止都在同一个时间点上大量过期。</li>
<li>方法1避免了有效过期的情况，但是要是所有的热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此将热点数据打散分不到不同的机房中，也可以有效减少这种情况。</li>
<li>也可以考虑双缓存的方式，数据库数据同步到缓存A和B，A设置过期时间，B不设置过期时间，如果A为空的时候去读B，同时异步去更新缓存，但是更新的时候需要同时更新两个缓存。</li>
</ol>
<p>比如设置产品的缓存时间：</p>
<pre><code class="language-java">redis.set(id,value,60*60 + Math.random()*1000);
</code></pre>
<h2 id="小结">小结</h2>
<p>缓存穿透是指数据库原本就没有的数据，请求如入无人之境，直奔数据库，而缓存击穿，则是指数据库有数据，缓存也本应该有数据，但是突然缓存过期了，这层保护屏障被击穿了，请求直奔数据库，缓存雪崩则是指很多缓存同一个时间失效了，流量全部涌入数据库，造成数据库极大的压力。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[布隆过滤器的三种实践]]></title>
        <id>https://aphysia.cn/post/bu-long-guo-lu-qi-de-san-chong-shi-jian/</id>
        <link href="https://aphysia.cn/post/bu-long-guo-lu-qi-de-san-chong-shi-jian/">
        </link>
        <updated>2023-03-02T15:09:02.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>前面我们已经讲过布隆过滤器的原理，都理解是这么运行的，那么一般我们使用布隆过滤器，是怎么去使用呢？如果自己去实现，又是怎么实现呢？</p>
]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>前面我们已经讲过布隆过滤器的原理，都理解是这么运行的，那么一般我们使用布隆过滤器，是怎么去使用呢？如果自己去实现，又是怎么实现呢？</p>
<!-- more -->
<p>[TOC]</p>
<h2 id="布隆过滤器">布隆过滤器</h2>
<p><strong>再念一次定义：</strong></p>
<p>布隆过滤器（<code>Bloom Filter</code>）是由布隆（<code>Burton Howard Bloom</code>）在 1970 年提出的，它实际上是由一个很长的二进制向量和一系列随机<code>hash</code>映射函数组成（说白了，就是用二进制数组存储数据的特征）。</p>
<p>譬如下面例子：有三个<code>hash</code>函数，那么“陈六”就会被三个<code>hash</code>函数分别<code>hash</code>，并且对位数组的长度，进行取余，分别hash到三个位置。</p>
<figure data-type="image" tabindex="1"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233900.png" alt="" loading="lazy"></figure>
<p>如果对原理还有不理解的地方，可以查看我的上一篇文章。</p>
<h2 id="手写布隆过滤器">手写布隆过滤器</h2>
<p>那么我们手写布隆过滤器的时候，首先需要一个位数组，在<code>Java</code>里面有一个封装好的位数组，<code>BitSet</code>。</p>
<p>简单介绍一下<code>BitSet</code>，也就是位图，里面实现了使用紧凑的存储空间来表示大空间的位数据。使用的时候，我们可以直接指定大小，也就是相当于创建出指定大小的位数组。</p>
<pre><code class="language-java">BitSet bits = new BitSet(size);
</code></pre>
<p>同时，<code>BitSet</code>提供了大量的<code>API</code>，基本的操作主要包括：</p>
<ul>
<li>清空位数组的数据</li>
<li>翻转某一位的数据</li>
<li>设置某一位的数据</li>
<li>获取某一位的数据</li>
<li>获取当前的<code>bitSet</code>的位数</li>
</ul>
<p>下面就讲一下，写一个简单的布隆过滤器需要考虑的点：</p>
<ul>
<li>位数组的大小空间，需要指定，其他相同的时候，位数组的大小越大，<code>hash</code>冲突的可能性越小。</li>
<li>多个<code>hash</code>函数，我们需要使用<code>hash</code>数组来存，<code>hash</code>函数需要如何设置呢？为了避免冲突，我们应该使用多个不同的质数来当种子。</li>
<li>方法：主要实现两个方法，一个往布隆过滤器里面添加元素，另一个是判断布隆过滤器是否包含某个元素。</li>
</ul>
<p>下面是具体的实现,只是简单的模拟，不可用于生产环境，<code>hash</code>函数较为简单，主要是使用 <code>hash</code> 值得高低位进行异或，然后乘以种子，再对位数组大小进行取余数：</p>
<pre><code class="language-java">import java.util.BitSet;

public class MyBloomFilter {

    // 默认大小
    private static final int DEFAULT_SIZE = Integer.MAX_VALUE;

    // 最小的大小
    private static final int MIN_SIZE = 1000;

    // 大小为默认大小
    private int SIZE = DEFAULT_SIZE;

    // hash函数的种子因子
    private static final int[] HASH_SEEDS = new int[]{3, 5, 7, 11, 13, 17, 19, 23, 29, 31};

    // 位数组，0/1,表示特征
    private BitSet bitSet = null;

    // hash函数
    private HashFunction[] hashFunctions = new HashFunction[HASH_SEEDS.length];

    // 无参数初始化
    public MyBloomFilter() {
        // 按照默认大小
        init();
    }

    // 带参数初始化
    public MyBloomFilter(int size) {
        // 大小初始化小于最小的大小
        if (size &gt;= MIN_SIZE) {
            SIZE = size;
        }
        init();
    }

    private void init() {
        // 初始化位大小
        bitSet = new BitSet(SIZE);
        // 初始化hash函数
        for (int i = 0; i &lt; HASH_SEEDS.length; i++) {
            hashFunctions[i] = new HashFunction(SIZE, HASH_SEEDS[i]);
        }
    }

    // 添加元素，相当于把元素的特征添加到位数组
    public void add(Object value) {
        for (HashFunction f : hashFunctions) {
            // 将hash计算出来的位置为true
            bitSet.set(f.hash(value), true);
        }
    }

    // 判断元素的特征是否存在于位数组
    public boolean contains(Object value) {
        boolean result = true;
        for (HashFunction f : hashFunctions) {
            result = result &amp;&amp; bitSet.get(f.hash(value));
            // hash函数只要有一个计算出为false，则直接返回
            if (!result) {
                return result;
            }
        }
        return result;
    }

    // hash函数
    public static class HashFunction {
        // 位数组大小
        private int size;
        // hash种子
        private int seed;

        public HashFunction(int size, int seed) {
            this.size = size;
            this.seed = seed;
        }

        // hash函数
        public int hash(Object value) {
            if (value == null) {
                return 0;
            } else {
                // hash值
                int hash1 = value.hashCode();
                // 高位的hash值
                int hash2 = hash1 &gt;&gt;&gt; 16;
                // 合并hash值(相当于把高低位的特征结合)
                int combine = hash1 ^ hash1;
                // 相乘再取余
                return Math.abs(combine * seed) % size;
            }
        }

    }

    public static void main(String[] args) {
        Integer num1 = new Integer(12321);
        Integer num2 = new Integer(12345);
        MyBloomFilter myBloomFilter =new MyBloomFilter();
        System.out.println(myBloomFilter.contains(num1));
        System.out.println(myBloomFilter.contains(num2));

        myBloomFilter.add(num1);
        myBloomFilter.add(num2);

        System.out.println(myBloomFilter.contains(num1));
        System.out.println(myBloomFilter.contains(num2));

    }
}
</code></pre>
<p>运行结果,符合预期：</p>
<pre><code class="language-txt">false
false
true
true
</code></pre>
<p>但是上面的这种做法是不支持预期的误判率的，只是可以指定位数组的大小。</p>
<p>当然我们也可以提供数据量，以及期待的大致的误判率来初始化，大致的初始化代码如下：</p>
<pre><code class="language-java">    // 带参数初始化
    public BloomFilter(int num,double rate) {
        // 计算位数组的大小
        this.size = (int) (-num * Math.log(rate) / Math.pow(Math.log(2), 2));
        // hsah 函数个数
        this.hashSize = (int) (this.size * Math.log(2) / num);
        // 初始化位数组
        this.bitSet = new BitSet(size);
    }
</code></pre>
<h2 id="redis实现">Redis实现</h2>
<p>平时我们可以选择使用<code>Redis</code>的特性于布隆过滤器，为什么呢？因为<code>Redis</code>里面有类似于<code>BitSet</code>的指令，比如设置位数组的值：</p>
<pre><code>setbit key offset value
</code></pre>
<p>上面的<code>key</code>是键，<code>offset</code>是偏移量，<code>value</code>就是<code>1</code>或者<code>0</code>。比如下面的就是将key1 的第7位置为1。</p>
<figure data-type="image" tabindex="2"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210314110134.png" alt="" loading="lazy"></figure>
<p>而获取某一位的数值可以使用下面这个命令：</p>
<pre><code class="language-java">gitbit key offset
</code></pre>
<p>借助<code>redis</code>这个功能我们可以实现优秀的布隆过滤器，但是实际上我们不需要自己去写了，<code>Redisson</code>这个客户端已经有较好的实现。<br>
下面就是用法：<br>
使用<code>maven</code>构建项目，首先需要导包到<code>pom.xml</code>：</p>
<pre><code class="language-xml">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.redisson&lt;/groupId&gt;
            &lt;artifactId&gt;redisson&lt;/artifactId&gt;
            &lt;version&gt;3.11.2&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
<p>代码如下，我使用的<code>docker</code>，启动的时候记得设置密码，运行的时候修改密码不起效果：</p>
<pre><code class="language-shell">docker run -d --name redis -p 6379:6379 redis --requirepass &quot;password&quot;
</code></pre>
<p>实现的代码如下，首先需要连接上<code>redis</code>，然后创建<code>redission</code>，使用<code>redission</code>创建布隆过滤器，直接使用即可。（<strong>可以指定预计的数量以及期待的误判率</strong>）</p>
<pre><code class="language-java">import org.redisson.Redisson;
import org.redisson.api.RBloomFilter;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

public class BloomFilterTest {
    public static void main(String[] args) {
        Config config = new Config();
        config.useSingleServer().setAddress(&quot;redis://localhost:6379&quot;);
        config.useSingleServer().setPassword(&quot;password&quot;);
        // 相当于创建了redis的连接
        RedissonClient redisson = Redisson.create(config);

        RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(&quot;myBloomFilter&quot;);
        //初始化,预计元素数量为100000000,期待的误差率为4%
        bloomFilter.tryInit(100000000,0.04);
        //将号码10086插入到布隆过滤器中
        bloomFilter.add(&quot;12345&quot;);

        System.out.println(bloomFilter.contains(&quot;123456&quot;));//false
        System.out.println(bloomFilter.contains(&quot;12345&quot;));//true
    }
}
</code></pre>
<p>运行结果如下：值得注意的是，这是单台<code>redis</code>的情况，如果是<code>redis</code>集群的做法略有不同。<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210314233301.png" alt="" loading="lazy"></p>
<h2 id="google-guava实现">Google GUAVA实现</h2>
<p><code>Google</code>提供的<code>guava</code>包里面也提供了布隆过滤器,引入<code>pom</code>文件：</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
            &lt;artifactId&gt;guava&lt;/artifactId&gt;
            &lt;version&gt;18.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>具体的实现调用的代码如下,同样可以指定具体的存储数量以及预计的误判率：</p>
<pre><code class="language-java">import com.google.common.base.Charsets;
import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;

public class GuavaBloomFilter {
    public static void main(String[] args) {
        BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(
                Funnels.stringFunnel(Charsets.UTF_8),1000000,0.04);

        bloomFilter.put(&quot;Sam&quot;);

        System.out.println(bloomFilter.mightContain(&quot;Jane&quot;));
        System.out.println(bloomFilter.mightContain(&quot;Sam&quot;));
    }
}
</code></pre>
<p>执行的结果如下,符合预期<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210314234457.png" alt="" loading="lazy"></p>
<p>上面三种分别是手写，<code>redis</code>，<code>guava</code>实践了布隆过滤器，只是简单的用法，其实<code>redis</code>和<code>guava</code>里面的实现也可以看看，有兴趣可以了解一下，我先立一个<code>Flag</code>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[布隆过滤器详解]]></title>
        <id>https://aphysia.cn/post/bu-long-guo-lu-qi-xiang-jie/</id>
        <link href="https://aphysia.cn/post/bu-long-guo-lu-qi-xiang-jie/">
        </link>
        <updated>2023-03-02T15:07:39.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>前面我们提到，在防止缓存穿透的情况（缓存穿透是指，<strong>缓存和数据库都没有的数据</strong>，被大量请求，比如订单号不可能为<code>-1</code>，但是用户请求了大量订单号为<code>-1</code>的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。）,我们可以考虑使用布隆过滤器，来过滤掉绝对不存于集合中的元素。</p>
]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>前面我们提到，在防止缓存穿透的情况（缓存穿透是指，<strong>缓存和数据库都没有的数据</strong>，被大量请求，比如订单号不可能为<code>-1</code>，但是用户请求了大量订单号为<code>-1</code>的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。）,我们可以考虑使用布隆过滤器，来过滤掉绝对不存于集合中的元素。</p>
<!-- more -->
<h2 id="布隆过滤器是什么呢">布隆过滤器是什么呢？</h2>
<p>布隆过滤器（Bloom Filter）是由布隆（Burton Howard Bloom）在1970年提出的，它实际上是由一个很长的二进制向量和一系列随机hash映射函数组成（说白了，就是用二进制数组存储数据的特征）。可以使用它来判断一个元素是否存在于集合中，它的优点在于查询效率高，空间小，缺点是存在一定的误差，以及我们想要剔除元素的时候，可能会相互影响。</p>
<p>也就是当一个元素被加入集合的时候，通过多个hash函数，将元素映射到位数组中的k个点，置为1。</p>
<h2 id="为什么需要布隆过滤器">为什么需要布隆过滤器？</h2>
<p>一般情况下，我们想要判断是否存在某个元素，一开始考虑肯定是使用数组，但是使用数组的情况，查找的时候效率比较慢，要判断一个元素不存在于数组中，需要每次遍历完所有的元素。删除完一个元素后，还得把后面的其他元素往前面移动。</p>
<figure data-type="image" tabindex="1"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308225741.png" alt="" loading="lazy"></figure>
<p>其实可以考虑使用<code>hash</code>表，如果有<code>hash</code>表来存储，将是以下的结构：<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308230509.png" alt="" loading="lazy"></p>
<p>但是这种结构，虽然满足了大部分的需求，可能存在两点缺陷：</p>
<ul>
<li>只有一个hash函数，其实两个元素hash到一块，也就是产生hash冲突的可能性，还是比较高的。虽然可以用拉链法（后面跟着一个链表）的方式解决，但是操作时间复杂度可能有所升高。</li>
<li>存储的时候，我们需要把元素引用给存储进去，要是上亿的数据，我们要将上亿的数据存储到一个hash表里面，不太建议这样操作。</li>
</ul>
<p>对于上面存在的缺陷，其实我们可以考虑，用多个hash函数来减少冲突（注意：冲突时不可以避免的，只能减少），用位来存储每一个hash值。这样既可以减少hash冲突，还可以减少存储空间。</p>
<p>假设有三个hash函数，那么不同的元素，都会使用三个hash函数，hash到三个位置上。<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233116.png" alt="" loading="lazy"></p>
<p>假设后面又来了一个张三，那么在hash的时候，同样会hash到以下位置，所有位都是1，我们就可以说张三已经存在在里面了。</p>
<figure data-type="image" tabindex="2"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233607.png" alt="" loading="lazy"></figure>
<p>那么有没有可能出现误判的情况呢？这是有可能的，比如现在只有张三，李四，王五，蔡八，hash映射值如下：<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233752.png" alt="" loading="lazy"></p>
<p>后面来了陈六，但是不凑巧的是，它hash的三个函数hash出来的位，刚刚好就是被别的元素hash之后，改成1了，判断它已经存在了，但是实际上，陈六之前是不存在的。</p>
<figure data-type="image" tabindex="3"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233900.png" alt="" loading="lazy"></figure>
<p>上面的情况，就是误判，布隆过滤器都会不可避免的出现误判。但是它有一个好处是，<strong>布隆过滤器，判断存在的元素，可能不存在，但是判断不存在的元素，一定不存在。</strong>，因为判断不存在说明至少有一位hash出来是对不上的。</p>
<p>也是由于会出现多个元素可能hash到一起，但有一个数据被踢出了集合，我们想把它映射的位，置为0，相当于删除该数据。这个时候，就会影响到其他的元素，可能会把别的元素映射的位，置为了0。这也就是为什么布隆过滤器不能删除的原因。</p>
<h2 id="具体步骤">具体步骤</h2>
<p>添加元素：</p>
<ul>
<li>
<ol>
<li>使用多个hash函数对元素item进行hash运算，得到多个hash值。</li>
</ol>
</li>
<li>
<ol start="2">
<li>每一个hash值对bit位数组取模，得到位数组中的位置索引index。</li>
</ol>
</li>
<li>
<ol start="3">
<li>如果index的位置不为1，那么就将该位置为1。</li>
</ol>
</li>
</ul>
<p>判断元素是否存在：</p>
<ul>
<li>
<ol>
<li>使用多个hash函数对元素item进行hash运算，得到多个hash值。</li>
</ol>
</li>
<li>
<ol start="2">
<li>每一个hash值对bit位数组取模，得到位数组中的位置索引index。</li>
</ol>
</li>
<li>
<ol start="3">
<li>如果index所处的位置都为1，说明元素可能已经存在了。</li>
</ol>
</li>
</ul>
<h2 id="误判率推导">误判率推导</h2>
<p>庆幸的是，布隆过滤器的误判率是可以预测的，由上面的分析，也可以得知，其实是与位数组的大小，以及hash函数的个数等，这些都是息息相关的。</p>
<p>假设位数组的大小是m，我们一共有k个hash函数，那么每一个hash函数，进行hash的时候，只能hash到m位中的一个位置，所以没有被hash到的概率是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac></mrow><annotation encoding="application/x-tex">1-\frac{1}{m}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>k个hash函数都hash之后，该位还是没有被hash到1的概率是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><msup><mo>)</mo><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">(1-\frac{1}{m})^k
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>如果我们插入了n个元素，也就是hash了n*k次，该位还是没有被hash成1的概率是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><msup><mo>)</mo><mrow><mi>k</mi><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(1-\frac{1}{m})^{kn}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>那该位为1的概率就是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>−</mo><mo>(</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><msup><mo>)</mo><mrow><mi>k</mi><mi>n</mi></mrow></msup></mrow><annotation encoding="application/x-tex">1-(1-\frac{1}{m})^{kn}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>如果需要检测某一个元素是不是在集合中，也就是该元素对应的k个hash元素hash出来的值，都需要设置为1。也就是该元素不存在，但是该元素对应的所有位都被hash成为1的概率是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow><mo>(</mo><mn>1</mn><mo>−</mo><mo>(</mo><mn>1</mn><mo>−</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><msup><mo>)</mo><mrow><mi>k</mi><mi>n</mi></mrow></msup><mo>)</mo></mrow><mi>k</mi></msup><mo>≈</mo><msup><mrow><mo>(</mo><mn>1</mn><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>k</mi><mi>n</mi><mi mathvariant="normal">/</mi><mi>m</mi></mrow></msup><mo>)</mo></mrow><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">{(1-(1-\frac{1}{m})^{kn})}^{k}\approx {(1-e^{-kn/m})}^k 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.246448em;vertical-align:-0.686em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.560448em;"><span style="top:-3.7743400000000005em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.4270079999999998em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mord mathdefault mtight">n</span><span class="mord mtight">/</span><span class="mord mathdefault mtight">m</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1770079999999998em;"><span style="top:-3.3909000000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>可以大致看出，随着位数组大小m和hash函数个数的增加，其实概率会下降，随着插入的元素n的增加，概率会有所上升。</p>
<p>最后也可以通过自己期待的误判率P和期待添加的个数n，来大致计算出布隆过滤器的位数组的长度：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mo>−</mo><mo>(</mo><mfrac><mrow><mi>n</mi><mi>I</mi><mi>n</mi><mi>P</mi></mrow><mrow><mo>(</mo><mi>I</mi><mi>n</mi><mn>2</mn><msup><mo>)</mo><mn>2</mn></msup></mrow></mfrac><mo>)</mo></mrow><annotation encoding="application/x-tex">m=-(\frac{nInP}{(In2)^2})
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>上面就是误判率的大致计算方式，同时也提示我们，可以根据自己业务的数据量以及误判率，来调整我们的数组的大小。</p>
<h2 id="布隆过滤器的作用">布隆过滤器的作用</h2>
<p>除了我们前面说的过滤爬虫恶意请求，还可以对一些URL进行去重，过滤海量数据里面的重复数据，过滤数据库里面不存在的id等等。</p>
<p>但是，即使有布隆过滤器，我们也不可能完全避免，或者彻底解决缓存穿透这个问题。只是相当于做了优化，将准确率提高。</p>
<p>很多的key-value数据库也会使用布隆过滤器来加快查询效率，因为全部挨个判断一遍，这个效率太低了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并发中分布式锁setnx解析]]></title>
        <id>https://aphysia.cn/post/bing-fa-zhong-fen-bu-shi-suo-setnx-jie-xi/</id>
        <link href="https://aphysia.cn/post/bing-fa-zhong-fen-bu-shi-suo-setnx-jie-xi/">
        </link>
        <updated>2023-03-02T15:06:27.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
前面讲解到，如果出现网络延迟的情况下，多个请求阻塞，那么恶意攻击就可以全部请求领取接口成功，而针对这种做法，我们使用`setnx`来解决，确保只有一个请求可以进入接口请求。]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
前面讲解到，如果出现网络延迟的情况下，多个请求阻塞，那么恶意攻击就可以全部请求领取接口成功，而针对这种做法，我们使用`setnx`来解决，确保只有一个请求可以进入接口请求。
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226230957.png" alt="" loading="lazy"></figure>
<pre><code class="language-java">    public String receiveGitf(int activityId,int giftId,String uid){
        // isExist判断活动是否存在，内部包括redis和数据库请求，省略
        if(isActivityExist(activityId,giftId)){
            // 活动和礼品有效,判断是否领取过
            if(!userReceived(uid,activityId,giftId)){
                // 没有领取过，调用C系统
                try {
                    // setnx
                    if(redis.setnx(&quot;uid_activityId_giftId&quot;)){
                        boolean receivedResult = Http.getMethod(C_Client.class, &quot;distributeGift&quot;);
                        if(receivedResult){
                            // 领取成功更新mysql
                            updateMysql(uid,activityId,giftId);
                        }else{
                            // 领取成功更新redis
                            deleteRedis(uid,activityId,giftId);
                            return &quot;已经领过/领取失败&quot;;
                        }
                    }else{
                        return &quot;已经领过/领取失败&quot;;
                    }
                }catch (Exception e){
                    // 记录日志
                    logHelper.log(e);
                    return &quot;调用领券系统失败，请重试&quot;;
                }
            }
        }
        return &quot;领取失败，活动不存在&quot;;
    }
</code></pre>
<p>下面，我们就专门讲解一下<code>setnx</code>，<code>setnx</code>可以用作分布式锁，但是<strong>这个场景并不是分布式锁的一个较好的实践，因为每个用户的key都是不一样的，我们主要是防止同一个用户恶意领取</strong>，<code>setnx</code>本身是一个原子操作，可以保证多个线程只有一个能拿到锁，能返回<code>true</code>,其他的都会返回<code>false</code>。</p>
<p>但是上面的做法，没有设置过期时间，在生产上一般是不可以这么使用。<strong>不设置过期时间的key多了之后，redis服务器很容易内存打满，这时候不知道哪些是强制依赖的，只能扩容，从代码层面去清理，如果直接清理不常用的，也很难保证不出事。</strong>（基本不允许这么干，除非是基础数据，跟着服务器启动，写入<code>redis</code>的，不会变更的，比如城市数据，国家数据等等，当然，这些也可以考虑在本地内存中实现）</p>
<p>如果在上面的代码中，加入超时时间，假设是一个月或者半年，流程变成这样：<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210228165201.png" alt="" loading="lazy"></p>
<p>设置key的超时时间使用<code>expire</code>,但是这样还有缺陷么？</p>
<p>在<code>redis 2.6.12</code>之前，<code>setnx</code>和<code>expire</code>都不是原子操作，也就是很有可能在<code>setnx</code>成功之后，redis当季，expire设置失败，也就不会有超时时间了。虽然这个影响在当前业务不是很大，但是还是一个小缺陷。</p>
<p><code>Redis2.6.12</code>以上版本，可以用<code>set</code>获取锁,set包含<code>setnx</code>和<code>expire</code>，实现了原子操作。也就是两步要么一起成功，要么一起失败。</p>
<p>除此之外，上面的流程可能还存在的一个问题，是请求<code>C</code>服务的时候出现超时，然后删除key，恰好这个时候<code>redis</code>有问题，删除失败了，这个<code>key</code>就永远存在了。表现在业务上，就是<code>A</code>用户点击了领取，领取失败了，但是后面再怎么点，都是已经领取的状态了。</p>
<p><strong>那这种现象怎么优化呢？</strong></p>
<p>这种情况，其实已经是很少见的情况，按照我们当前的业务场景也看，就是当前的用户，<code>redis</code>记录了它已经领取过了，但是由于接口的失败，成功之后还没将<code>mysql/其他数据库</code>更新,两个数据库不一致了。</p>
<p>我能想到的一个方法，就是再删除失败的时候，告警，并且将业务相关的数据记录下来，比如<code>key</code>，<code>uid</code>等等，针对这部分数据，做一次补发，或者手动删除key。</p>
<p>或者，启动一个定时任务或者<code>lua</code>脚本，去判定<code>redis</code>和数据库不一致的情况，但是切记不要全部查询，应该是隔一段时间，查询最后增加的部分，做一个校验以及相应的处理。枚举<code>key</code>是十分耗时的操作！！！</p>
<p><code>setnx</code> 除了解决上面的问题，还可以应用在解决<strong>缓存击穿</strong>的问题上。</p>
<p>譬如现在有热点数据，不仅在<code>mysql</code>数据库存储了，还在<code>redis</code>中存了一份缓存，那么如果有一个时间点，缓存失效了，这时候，大量的请求打过来，同时到达，缓存拿不到数据，都去数据库取数据，假设数据库操作比较耗时，那么压力全都在数据库服务器上了。</p>
<p>这个时候所有的请求都去更新数据，明显是不合适的，应该是使用分布式锁，让一个线程去请求<code>mysql</code>一次即可。但是为了避免死锁的情况，如果超时，得及时额外释放锁，要不可能请求<code>mysql</code>都失败了，其他线程又拿不到锁，那么数据就会一直为<code>null</code>了。</p>
<p>可以使用以下的命令：</p>
<pre><code class="language-shell">SETNX lock.foo &lt;current Unix time + lock timeout + 1&gt;
</code></pre>
<p>关于这个场景下的<code>setnx</code>先讲到这里，后面再讲讲分布式锁相关的知识。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计领取礼品的架构以及并发问题解决]]></title>
        <id>https://aphysia.cn/post/she-ji-ling-qu-li-pin-de-jia-gou-yi-ji-bing-fa-wen-ti-jie-jue/</id>
        <link href="https://aphysia.cn/post/she-ji-ling-qu-li-pin-de-jia-gou-yi-ji-bing-fa-wen-ti-jie-jue/">
        </link>
        <updated>2023-03-02T15:05:18.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>现在 有一个场景，领取礼品，每个用户有次数限制，用户通过前端点击，调用了应用A的接口，里面调用了服务B，服务B里面去调用了服务C，注意服务C是其他部门的服务。服务C负责真正的发放礼品。（假设这个服务C我们是不可修改的，A,B是自己团队负责的，并且可能出现高并发的情况）</p>
]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>现在 有一个场景，领取礼品，每个用户有次数限制，用户通过前端点击，调用了应用A的接口，里面调用了服务B，服务B里面去调用了服务C，注意服务C是其他部门的服务。服务C负责真正的发放礼品。（假设这个服务C我们是不可修改的，A,B是自己团队负责的，并且可能出现高并发的情况）</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226212257.png" alt="" loading="lazy"></figure>
<p>我们应该如何做这个次数限制呢？</p>
<p>假设每次领取礼品的活动有一个<code>activityId</code>，一个用户一个活动可以领取一件礼品，礼品有<code>giftId</code>，不可以多领，每个用户对应一个<code>uid</code>。</p>
<h2 id="查询是否可以领取">查询是否可以领取</h2>
<p>首先对于前端而言，进入系统，首先需要获取用户是否已经领取过，而这个是否已经领取过，具体的实现我们应该写在B服务中，用户通过应用A，请求到服务B，返回用户是否已经领取的结果。</p>
<p>查询是否领取的流程大致如下：<br>
用户进入页面，前端如果有缓存的话，可以为他展示之前缓存的结果，假设没有缓存，就会请求A应用，A应用会去请求B服务，B服务首先需要判断礼品或者活动是否存在。</p>
<p>去redis里面取活动或者礼品是否存在，如果redis没有查询到，那么就查询数据库，返回结果，如果数据库都没有，说明这个前端请求很可能是捏造的，直接返回结果“活动或者礼品不存在”，如果此时查询出来，确实存在，那么就需要去查询是否领取过，同样是查询redis，不存在的情况下，查询数据库，再返回结果。，如果领取过，则会有领取结果，前端将按键置灰，否者用户按键可以领取。</p>
<figure data-type="image" tabindex="2"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226214848.png" alt="" loading="lazy"></figure>
<p>上面的redis肯定是需要我们维护的，这里不展开讲。比如增加活动的时候，除了改数据库，同时需要<code>redis</code>里面写一份数据，key可以是<code>activityId_giftId</code>，记录已经有的活动，用户成功领取的时候，同样是不仅增加数据库记录，也需要往<code>redis</code>写一份数据，key可以是<code>activityId_giftId_uid</code>，记录该用户已经领取过该活动的奖品。</p>
<p>但是上面的系统，有一个问题，就是活动/礼品不存在的时候，请求会每一次都直接打到数据库，如果是恶意攻击，数据库就挂了。这里当然可以考虑使用布隆过滤器，对请求参数中的活动/礼品做过滤，同时也可以考虑其他的防爬虫手段，比如滑动窗口统计请求数，根据<code>ip</code>，客户端<code>id</code>,<code>uid</code>等等。</p>
<p>当然，如果可以保证<code>redis</code>数据可靠，稳定，可以不请求数据库，<code>redis</code>不包含则说明不存在，直接返回。但是这种做法需要在增加活动/修改商品的时候，同时将<code>redis</code>一同修改同步。如果redis挂掉的情况，或者请求<code>redis</code>异常，再去查询数据库。如果能接受修改数据库活动信息不立马更新，也可以考虑更新完数据库，用消息队列发一条消息，收到再做<code>redis</code>更新。当然，这个不是一种好的做法，解耦合之后，增加了复杂度。前面说的做法，只要<code>redis</code>挂了，数据库理论上也支撑不了多久（极端情况）。</p>
<p>（当然，上面不是完美的方案，是个大致流程）</p>
<h2 id="领取礼品接口怎么处理">领取礼品接口怎么处理？</h2>
<p>首先流程上与上面的查询是否领取过有些类似，，但是在查询是否领取过这一步之后，有所不同。如果已经领取过，则直接返回，但是如果没有领取过，需要调用C服务进行领取，如果调用C接口失败，或者返回领取失败，B服务需要做的事，就是记录日志或者告警，同时返回失败。<br>
如果C服务返回领取成功，那么需要记录领取记录到数据库，并且更新缓存，表示已经领取过该礼品，这也是上面为什么一般能直接查询缓存就可以知道用户是否领取过的原因。<br>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226230957.png" alt="" loading="lazy"></p>
<p>这个设计中，其实C服务才是真正实现方法奖品的服务，我们做的A和B相当于调用别人的服务，做了中间服务，这种情况更需要记录日志，控制爬虫，恶意攻击等等，同时做好异常处理。</p>
<p>上面的设计，如果我们来写段伪代码，来看看有什么问题？</p>
<pre><code class="language-java">    public String receiveGitf(int activityId,int giftId,String uid){
        // isExist判断活动是否存在，内部包括redis和数据库请求，省略
        if(isActivityExist(activityId,giftId)){
            // 活动和礼品有效,判断是否领取过
            if(!userReceived(uid,activityId,giftId)){
                // 没有领取过，调用C系统
                try {
                    boolean receivedResult = Http.getMethod(C_Client.class, &quot;distributeGift&quot;);
                    if(receivedResult){
                        // 领取成功更新mysql
                        updateMysql(uid,activityId,giftId);
                        // 领取成功更新redis
                        updateRedis(uid,activityId,giftId);
                    }else{
                        return &quot;已经领过/领取失败&quot;;
                    }
                }catch (Exception e){
                    // 记录日志
                    logHelper.log(e);
                    return &quot;调用领券系统失败，请重试&quot;;
                }
            }
        }
        return &quot;领取失败，活动不存在&quot;;
    }
</code></pre>
<p>看起来好像没有什么问题，领取成功写<code>redis</code>，之后读到就不会再领取。但是高并发环境下呢？高并发环境下，很有可能出现领取多次的情况，因为网络请求不是瞬时可以返回的，如果有很多个同一个uid的请求，同时进来，C服务的处理或者延迟比较高。所有的请求都会堵塞在请求C服务这里。（网络请求需要时间！！！）</p>
<figure data-type="image" tabindex="3"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226233336.png" alt="" loading="lazy"></figure>
<p>这时候还没有任何请求成功，所以<code>redis</code>根本不会更新，数据库也不会，所以的请求都会打到C服务，假设别人的服务是不可靠的，可以多次领取，那么所有的请求都会成功，并且会有多条成功的记录！！！</p>
<p>那如何来改进这个问题呢？<br>
我们可以使用<code>setnx</code>来处理，先请求<code>setnx</code>，更新缓存，然后只有一个可以成功进来，如果真的成功，再写数据库，如果异常或者请求失败，将缓存删除。</p>
<pre><code class="language-java">    public String receiveGitf(int activityId,int giftId,String uid){
        // isExist判断活动是否存在，内部包括redis和数据库请求，省略
        if(isActivityExist(activityId,giftId)){
            // 活动和礼品有效,判断是否领取过
            if(!userReceived(uid,activityId,giftId)){
                // 没有领取过，调用C系统
                try {
                    // setnx
                    if(redis.setnx(&quot;uid_activityId_giftId&quot;)){
                        boolean receivedResult = Http.getMethod(C_Client.class, &quot;distributeGift&quot;);
                        if(receivedResult){
                            // 领取成功更新mysql
                            updateMysql(uid,activityId,giftId);
                        }else{
                            // 领取成功更新redis
                            deleteRedis(uid,activityId,giftId);
                            return &quot;已经领过/领取失败&quot;;
                        }
                    }else{
                        return &quot;已经领过/领取失败&quot;;
                    }
                }catch (Exception e){
                    // 记录日志
                    logHelper.log(e);
                    return &quot;调用领券系统失败，请重试&quot;;
                }
            }
        }
        return &quot;领取失败，活动不存在&quot;;
    }
</code></pre>
<p>在 <code>Redis</code> 里，所谓 <code>SETNX</code>，是<code>「SET if Not eXists」</code>缩写，也就是只有<code>key</code>不存在的时候才设置，可以利用它来实现锁的效果。这样只有一个请求可以进入。</p>
<pre><code class="language-shell">redis&gt; EXISTS id                # id 不存在

redis&gt; SETNX id &quot;1&quot;    # id 设置成功1

redis&gt; SETNX id &quot;2&quot;   # 尝试覆盖 id ，返回失败 0

redis&gt; GET job                   # 没有被覆盖&quot;2&quot;
</code></pre>
<p>这个场景下的问题已经得到初步的解决，那这个<code>setnx</code>有没有坑呢？下次我们聊一下...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计一个短链接生成系统]]></title>
        <id>https://aphysia.cn/post/she-ji-yi-ge-duan-lian-jie-sheng-cheng-xi-tong/</id>
        <link href="https://aphysia.cn/post/she-ji-yi-ge-duan-lian-jie-sheng-cheng-xi-tong/">
        </link>
        <updated>2023-03-02T15:01:07.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="引言">引言</h2>
<p>相信大家在生活中，特别是最近的双十一活动期间，会收到很多短信，而那些短信都有两个特征，第一个是几乎都是垃圾短信，这个特点此处可以忽略不计，第二个特点是<strong>链接很短</strong>，比如下面这个：</p>
]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<h2 id="引言">引言</h2>
<p>相信大家在生活中，特别是最近的双十一活动期间，会收到很多短信，而那些短信都有两个特征，第一个是几乎都是垃圾短信，这个特点此处可以忽略不计，第二个特点是<strong>链接很短</strong>，比如下面这个：</p>
<!-- more -->
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211110222405.png" style="zoom:40%;" />
<p>我们知道，短信有些是有字数限制的，直接放一个带满各种参数的链接，不合适，另外一点是，不想暴露参数。好处无非以下：</p>
<ul>
<li>太长的链接容易被限制长度</li>
<li>短链接看着简洁，长链接看着容易懵</li>
<li>安全，不想暴露参数</li>
<li>可以统一链接转换，当然也可以实现统计点击次数等操作</li>
</ul>
<p>那背后的原理是什么呢？怎么实现的？让你实现这样的系统，你会怎么设计呢？【来自于某鹅场面试官】</p>
<h2 id="短链接的原理">短链接的原理</h2>
<h3 id="短链接展示的逻辑">短链接展示的逻辑</h3>
<p>这里最重要的知识点是重定向，先复习一下<code>http</code>的状态码：</p>
<table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1**</td>
<td style="text-align:left">服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td style="text-align:left">2**</td>
<td style="text-align:left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td style="text-align:left">3**</td>
<td style="text-align:left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4**</td>
<td style="text-align:left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">5**</td>
<td style="text-align:left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<p>那么以 3 开头的状态码都是关于重定向的：</p>
<ul>
<li>300：多种选择，可以在多个位置存在</li>
<li>301：永久重定向，浏览器会缓存，自动重定向到新的地址</li>
<li>302：临时重定向，客户端还是会继续使用旧的URL</li>
<li>303：查看其他的地址，类似于301</li>
<li>304：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。</li>
<li>305：需要使用代理才能访问到资源</li>
<li>306：废弃的状态码</li>
<li>307：临时重定向，使用Get请求重定向</li>
</ul>
<p>整个跳转的流程：</p>
<ul>
<li>1.用户访问短链接，请求到达服务器</li>
<li>2.服务器将短链接装换成为长链接，然后给浏览器返回重定向的状态码301/302
<ul>
<li>301永久重定向会导致浏览器缓存重定向地址，短链接系统统计访问次数会不正确</li>
<li>302临时重定向可以解决次数不准的问题，但是每次都会到短链接系统转换，服务器压力会变大。</li>
</ul>
</li>
<li>3.浏览器拿到重定向的状态码，以及真正需要访问的地址，重定向到真正的长链接上。</li>
</ul>
<p>从下图可以看出，确实链接被<code>302</code>重定向到新的地址上去，返回的头里面有一个字段<code>Location</code>就是所要重定向的地址：</p>
<img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211110235518.png" style="zoom:70%;" />
<h3 id="短链接怎么设计的">短链接怎么设计的？</h3>
<h4 id="全局发号器">全局发号器</h4>
<p>肯定我们第一点想到的是压缩，像文件压缩那样，压缩之后再解压还原到原来的链接，重定向到原来的链接，但是很不幸的是，这个是行不通的，你有见过什么压缩方式能把这么长的数字直接压缩到这么短么？事实上不可能。就像是<code>Huffman</code>树，也只能对那种重复字符较多的字符串压缩时效率较高，像链接这种，可能带很多参数，而且各种不规则的情况都有，直接压缩算法不现实。</p>
<p>那<code>https://dx.10086.cn/tzHLFw</code>与<code>https://gd.10086.cn/gmccapp/webpage/payPhonemoney/index.html?channel=</code>之间的装换是怎么样的呢？前面路径不变，变化的是后面，也就是<code>tzHLFw</code>与<code>gmccapp/webpage/payPhonemoney/index.html?channel=</code>之间的转换。</p>
<p>实际也很简单，就是数据库里面的一条数据，一个<code>id</code>对应长链接（相当于全局的发号器，全局唯一的ID）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">url</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">https://gd.10086.cn/gmccapp/webpage/payPhonemoney/index.html?channel=</td>
</tr>
</tbody>
</table>
<p>这里用到的，也就是我们之前说过的分布式全局唯一ID，如果我们直接用<code>id</code>作为参数，貌似也可以：<code>https://dx.10086.cn/1</code>，访问这个链接时，去数据库查询获得真正的url，再重定向。</p>
<p>单机的唯一<code>ID</code>很简单，用原子类<code>AtomicLong</code>就可以，但是分布式的就不行了，简单点可以用 <code>redis</code>，或者数据库自增，或者可以考虑<code>Zookeeper</code>之类的。</p>
<h4 id="id-转换策略">id 转换策略</h4>
<p>但是直接用递增的数字，有两个坏处：</p>
<ul>
<li>数字很大的时候，还是很长</li>
<li>递增的数字，不安全，规律性太强了</li>
</ul>
<p>明显我们平时看到的链接也不是数字的，一般都是大小写字母加上数字。为了缩短链接的长度，我们必须把<code>id</code>转换掉，比如我们的短链接由<code>a-z</code>,<code>A-Z</code>,<code>0-9</code>组成，相当于<code>62</code>进制的数字，将<code>id</code>转换成为<code>62</code>进制的数字:</p>
<pre><code class="language-java">public class ShortUrl {

    private static final String BASE = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;

    public static String toBase62(long num) {
        StringBuilder result = new StringBuilder();
        do {
            int i = (int) (num % 62);
            result.append(BASE.charAt(i));
            num /= 62;
        } while (num &gt; 0);

        return result.reverse().toString();
    }

    public static long toBase10(String str) {
        long result = 0;
        for (int i = 0; i &lt; str.length(); i++) {
            result = result * 62 + BASE.indexOf(str.charAt(i));
        }
        return result;
    }

    public static void main(String[] args) {
        // tzHLFw
        System.out.println(toBase10(&quot;tzHLFw&quot;));
        System.out.println(toBase62(27095455234L));
    }
}
</code></pre>
<p><code>id</code>转 <code>62</code>位的<code>key</code> 或者<code>key</code>装换成为<code>id</code>都已经实现了，不过计算还是比较耗时的，不如加个字段存起来，于是数据库变成了：</p>
<table>
<thead>
<tr>
<th style="text-align:center">id</th>
<th style="text-align:center">key</th>
<th style="text-align:center">url</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">27095455234</td>
<td style="text-align:center">tzHLFw</td>
<td style="text-align:center">https://gd.10086.cn/gmccapp/webpage/payPhonemoney/index.html?channel=</td>
</tr>
</tbody>
</table>
<p>但是这样还是很容易被猜出这个<code>id</code>和<code>key</code>的对应关系，要是被遍历访问，那还是很不安全的，如果担心，可以随机将短链接的字符顺序打乱，或者在适当的位置加上一些随机生成的字符，比如第<code>1，4，5 </code>位是随机字符，其他位置不变，只要我们计算的时候，将它对应的关系存到数据库，我们就可以通过连接的<code>key</code>找到对应的<code>url</code>。（值得注意的是，<code>key</code>必须是全局唯一的，如果冲突，必须重新生成）</p>
<p>一般短链接都有过期时间，那么我们也必须在数据库里面加上对应的字段，访问的时候，先判断是否过期，过期则不给予重定向。</p>
<figure data-type="image" tabindex="1"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211115003828.png" alt="" loading="lazy"></figure>
<h4 id="性能考虑">性能考虑</h4>
<p>如果有很多短链接暴露出去了，数据库里面数据很多，这个时候可以考虑使用缓存优化，生成的时候顺便把缓存写入，然后读取的时候，走缓存即可，因为一般短链接和长链接的关系不会修改，即使修改，也是很低频的事情。</p>
<p>如果系统的<code>id</code>用完了怎么办？这种概率很小，如果真的发生，可以重用旧的已经失效的<code>id</code>号。</p>
<p>如果被人疯狂请求一些不存在的短链接怎么办？其实这就是缓存穿透，缓存穿透是指，<strong>缓存和数据库都没有的数据</strong>，被大量请求，比如订单号不可能为<code>-1</code>，但是用户请求了大量订单号为<code>-1</code>的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。如果被恶意用户利用，疯狂请求不存在的数据，就会导致数据库压力过大，甚至垮掉。</p>
<p>针对这种情况，一般可以用布隆过滤器过滤掉不存在的数据请求，但是我们这里<code>id</code>本来就是递增且有序的，其实我们范围大致都是已知的，更加容易判断，超出的肯定不存在，或者请求到的时候，缓存里面放一个空对象也是没有问题的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[漫游数据结构世界]]></title>
        <id>https://aphysia.cn/post/man-you-shu-ju-jie-gou-shi-jie/</id>
        <link href="https://aphysia.cn/post/man-you-shu-ju-jie-gou-shi-jie/">
        </link>
        <updated>2023-03-02T14:58:33.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>程序 = 数据结构 + 算法</p>
</blockquote>
<p>是的，上面这句话是非常经典的，程序由数据结构以及算法组成，当然数据结构和算法也是相辅相成的，不能完全独立来看待，但是本文会相对重点聊聊那些常用的数据结构。</p>
]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<blockquote>
<p>程序 = 数据结构 + 算法</p>
</blockquote>
<p>是的，上面这句话是非常经典的，程序由数据结构以及算法组成，当然数据结构和算法也是相辅相成的，不能完全独立来看待，但是本文会相对重点聊聊那些常用的数据结构。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="" loading="lazy"></figure>
<p><strong>数据结构是什么呢？</strong></p>
<p>首先得知道数据是什么？<strong>数据是对客观事务的符号表示</strong>，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号总称。那为何加上**“结构”**两字？</p>
<p><strong>数据元素是数据的基本单位</strong>，而任何问题中，数据元素都不是独立存在的，它们之间总是存在着某种关系，这种<strong>数据元素之间的关系我们称之为结构</strong>。</p>
<p>因此，我们有了以下定义：</p>
<blockquote>
<p>数据结构是<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>存储、组织<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE">数据</a>的方式。数据结构是指相互之间存在一种或多种特定关系的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313">数据元素</a>的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储<a href="https://baike.baidu.com/item/%E6%95%88%E7%8E%87/868847">效率</a>。数据结构往往同高效的检索<a href="https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025">算法</a>和<a href="https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853">索引</a>技术有关。</p>
</blockquote>
<p>简单讲，数据结构就是组织，管理以及存储数据的方式。虽然理论上所有的数据都可以混杂，或者糅合，或者饥不择食，随便存储，但是计算机是追求高效的，如果我们能了解数据结构，找到较为适合当前问题场景的数据结构，将数据之间的关系表现在存储上，计算的时候可以较为高效的利用适配的算法，那么程序的运行效率肯定也会有所提高。</p>
<p>常用的4种数据结构有：</p>
<ul>
<li>集合：只有同属于一个集合的关系，没有其他关系</li>
<li>线性结构：结构中的数据元素之间存在一个对一个的关系</li>
<li>树形结构：结构中的数据元素之间存在一个对多个的关系</li>
<li>图状结构或者网状结构：图状结构或者网状结构</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104211919.png" alt="" loading="lazy"></figure>
<p><strong>何为逻辑结构和存储结构？</strong></p>
<p><strong>数据元素之间的逻辑关系，称之为逻辑结构</strong>，也就是我们定义了对操作对象的一种数学描述。但是我们还必须知道在计算机中如何表示它。<strong>数据结构在计算机中的表示（又称为映像），称之为数据的物理结构，又称存储结构</strong>。</p>
<p>数据元素之前的关系在计算机中有两种不同的表示方法：<strong>顺序映像和非顺序映像</strong>，并且由此得到两种不同的存储结构：<strong>顺序存储结构</strong>和<strong>链式存储结构</strong>，比如顺序存储结构，我们要表示复数<code>z1 =3.0 - 2.3i </code>,可以直接借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系：</p>
<figure data-type="image" tabindex="3"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104213735.png" alt="" loading="lazy"></figure>
<p>而链式结构，则是以<strong>指针</strong>表示数据元素之间的逻辑关系，同样是<code>z1 =3.0 - 2.3i </code>，先找到下一个是 <code>100</code>，是一个地址，根据地址找到真实的数据<code>-2.3i</code>:</p>
<figure data-type="image" tabindex="4"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104214041.png" alt="" loading="lazy"></figure>
<h2 id="位bit">位（bit）</h2>
<p>在计算机中表示信息的最小的单位是二进制数中的一位，叫做<strong>位</strong>。也就是我们常见的类似<code>01010101010</code>这种数据，计算机的底层就是各种晶体管，电路板，所以不管是什么数据，即使是图片，声音，在最底层也是<code>0</code>和<code>1</code>,如果有八条电路，那么每条电路有自己的闭合状态，有<code>8</code>个<code>2</code>相乘，2<sup>8</sup>，也就是<code>256</code>种不同的信号。</p>
<p>但是一般我们需要表示负数，也就是最高的一位表示符号位，<code>0</code>表示正数，<code>1</code>表示负数，也就是8位的最大值是<code>01111111</code>，也就是<code>127</code>。</p>
<p>值得我们注意的是，计算机的世界里，多了原码，反码，补码的概念：</p>
<ul>
<li>原码：用第一位表示符号，其余位表示值</li>
<li>反码：正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反。</li>
<li>补码：正数的补码是其本身，负数的补码是在其反码的基础上 + 1</li>
</ul>
<h3 id="为什么有了原码还要反码和补码">为什么有了原码还要反码和补码？</h3>
<p>我们知道加减法是高频的运算，人可以很直观的看出加号减号，马上就可以算出来，但是计算机如果区分不同的符号，那么加减就会比较复杂，比如正数+正数，正数-正数，正数-负数，负数+负数...等等。于是，有人就想用同一个运算器（加号运算器），解决所有的加减法计算，可以减少很多复杂的电路，以及各种符号转换的开销，计算也更加高效。</p>
<p>我们可以看到，下面负数参加运算的结果也是符合补码的规则的：</p>
<pre><code class="language-txt">        00100011		35
 +      11011101	   -35
-------------------------
        00000000       0
</code></pre>
<pre><code class="language-txt">        00100011		35
 + 	    11011011	   -37
-------------------------
        11111110       -2
</code></pre>
<p>当然，如果计算结果超出了位数所能表示的范围，那就是溢出，就说明需要更多的位数才能正确表示。</p>
<p>一般能用位运算的，都尽量使用位运算，因为它比较高效, 常见的位运算：</p>
<ul>
<li><code>~</code>：按位取反</li>
<li><code>&amp;</code>：按为与运算</li>
<li><code>|</code>：按位或运算</li>
<li><code>^</code>：按位异或</li>
<li><code>&lt;&lt;</code>: 带符号左移，比如<code>35(00100011)</code>,左移一位为 <code>70(01000110)</code>,<code>-35(11011101)</code>左移一位为<code>-70(10111010)</code></li>
<li><code>&gt;&gt;</code>：带符号右移，比如<code>35(00100011)</code>,右移一位为 <code>17(00010001)</code>,<code>-35(11011101)</code>左移一位为<code>-18(11101110)</code></li>
<li><code>&lt;&lt;&lt;</code>:无符号左移，比如<code>35(00100011)</code>,左移一位为<code>70(01000110)</code></li>
<li><code>&gt;&gt;&gt;</code>:无符号右移，比如<code>-35(11011101)</code>,右移一位为<code>110(01101110)</code></li>
<li><code>x ^= y; y ^= x; x ^= y;</code>:交换</li>
<li><code>s &amp;= ~(1 &lt;&lt; k)</code>:第<code>k</code>位置0</li>
</ul>
<p>要说哪里使用位运算比较经典，那么要数<strong>布隆过滤器</strong>，需要了解详情的可以参考：http://aphysia.cn/archives/cachebloomfilter</p>
<h3 id="布隆过滤器是什么呢">布隆过滤器是什么呢？</h3>
<p>布隆过滤器（<code>Bloom Filter</code>）是由布隆（<code>Burton Howard Bloom</code>）在1970年提出的，它实际上是由一个很长的二进制向量和一系列随机hash映射函数组成（说白了，就是用二进制数组存储数据的特征）。可以使用它来判断一个元素是否存在于集合中，它的优点在于查询效率高，空间小，缺点是存在一定的误差，以及我们想要剔除元素的时候，可能会相互影响。</p>
<p>也就是当一个元素被加入集合的时候，通过多个<code>hash</code>函数，将元素映射到位数组中的<code>k</code>个点，置为<code>1</code>。</p>
<p><strong>重点是多个hash函数，可以将数据hash到不同的位上，也只有这些位全部为1的时候，我们才能判断该数据已经存在</strong></p>
<p>假设有三个<code>hash</code>函数，那么不同的元素，都会使用三个<code>hash</code>函数，<code>hash</code>到三个位置上。</p>
<figure data-type="image" tabindex="5"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233116.png" alt="" loading="lazy"></figure>
<p>假设后面又来了一个张三，那么在<code>hash</code>的时候，同样会<code>hash</code>到以下位置，所有位都是<code>1</code>，我们就可以说张三已经存在在里面了。</p>
<figure data-type="image" tabindex="6"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233607.png" alt="" loading="lazy"></figure>
<p>那么有没有可能出现误判的情况呢？这是有可能的，比如现在只有张三，李四，王五，蔡八，<code>hash</code>映射值如下：</p>
<figure data-type="image" tabindex="7"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233752.png" alt="" loading="lazy"></figure>
<p>后面来了陈六，但是不凑巧的是，它<code>hash</code>的三个函数hash出来的位，刚刚好就是被别的元素<code>hash</code>之后，改成<code>1</code>了，判断它已经存在了，但是实际上，陈六之前是不存在的。</p>
<figure data-type="image" tabindex="8"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233900.png" alt="" loading="lazy"></figure>
<p>上面的情况，就是误判，布隆过滤器都会不可避免的出现误判。但是它有一个好处是，<strong>布隆过滤器，判断存在的元素，可能不存在，但是判断不存在的元素，一定不存在。</strong>，因为判断不存在说明至少有一位<code>hash</code>出来是对不上的。</p>
<p>也是由于会出现多个元素可能<code>hash</code>到一起，但有一个数据被踢出了集合，我们想把它映射的位，置为<code>0</code>，相当于删除该数据。这个时候，就会影响到其他的元素，可能会把别的元素映射的位，置为了<code>0</code>。这也就是为什么布隆过滤器不能删除的原因。</p>
<h2 id="数组">数组</h2>
<p>线性表示最常用而且最为简单的一种数据结构，一个线性表示 n 个数据元素的有限序列，有以下特点：</p>
<ul>
<li>存在唯一的第一个的数据元素</li>
<li>存在唯一被称为最后一个的数据元素</li>
<li>除了第一个以外，集合中每一个元素均有一个前驱</li>
<li>除了最后一个元素之外，集合中的每一个数据元素都有一个后继元素</li>
</ul>
<p>线性表包括下面几种：</p>
<ul>
<li>数组：查询 / 更新快，查找/删除慢</li>
<li>链表</li>
<li>队列</li>
<li>栈</li>
</ul>
<p><strong>数组是线性表的一种，线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素</strong>：</p>
<figure data-type="image" tabindex="9"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104223923.png" alt="" loading="lazy"></figure>
<p>在<code>Java</code>中表示为：</p>
<pre><code class="language-Java">int[] nums = new int[100];
int[] nums = {1,2,3,4,5};

Object[] Objects = new Object[100];
</code></pre>
<p>在<code>C++</code> 中表示为：</p>
<pre><code class="language-C++">int nums[100];
</code></pre>
<p>数组是一种线性的结构，一般在底层是连续的空间，存储相同类型的数据，由于连续紧凑结构以及天然索引支持，查询数据效率高:</p>
<p>假设我们知道数组<code>a</code>的第 1 个值是 地址是  <code>296</code>,里面的数据类型占 <code>2</code> 个 单位，那么我们如果期望得到第 5 个： <code>296+（5-1）*2 = 304</code>,<code>O(1)</code>的时间复杂度就可以获取到。</p>
<p>更新的本质也是查找，先查找到该元素，就可以动手更新了：</p>
<figure data-type="image" tabindex="10"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104224829.png" alt="" loading="lazy"></figure>
<p>但是如果期望插入数据的话，需要移动后面的数据，比如下面的数组，插入元素<code>6</code>，最差的是移动所有的元素，时间复杂度为<code>O(n)</code></p>
<figure data-type="image" tabindex="11"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220104225524289.png" alt="image-20220104225524289" loading="lazy"></figure>
<p>而删除元素则需要把后面的数据移动到前面，最差的时间复杂度同样为<code>O(n)</code>:</p>
<figure data-type="image" tabindex="12"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104230125.png" alt="" loading="lazy"></figure>
<p>Java代码实现数组的增删改查：</p>
<pre><code class="language-Java">package datastruction;

import java.util.Arrays;

public class MyArray {
    private int[] data;

    private int elementCount;

    private int length;

    public MyArray(int max) {
        length = max;
        data = new int[max];
        elementCount = 0;
    }

    public void add(int value) {
        if (elementCount == length) {
            length = 2 * length;
            data = Arrays.copyOf(data, length);
        }
        data[elementCount] = value;
        elementCount++;
    }

    public int find(int searchKey) {
        int i;
        for (i = 0; i &lt; elementCount; i++) {
            if (data[i] == searchKey)
                break;
        }
        if (i == elementCount) {
            return -1;
        }
        return i;
    }

    public boolean delete(int value) {
        int i = find(value);
        if (i == -1) {
            return false;
        }
        for (int j = i; j &lt; elementCount - 1; j++) {
            data[j] = data[j + 1];
        }
        elementCount--;
        return true;
    }

    public boolean update(int oldValue, int newValue) {
        int i = find(oldValue);
        if (i == -1) {
            return false;
        }
        data[i] = newValue;
        return true;
    }
}

// 测试类
public class Test {
    public static void main(String[] args) {
        MyArray myArray = new MyArray(2);
        myArray.add(1);
        myArray.add(2);
        myArray.add(3);
        myArray.delete(2);
        System.out.println(myArray);
    }
}
</code></pre>
<h2 id="链表">链表</h2>
<p>上面的例子中，我们可以看到数组是需要连续的空间，这里面如果空间大小只有 <code>2</code>，放到第 <code>3</code> 个元素的时候，就不得不扩容，不仅如此，还得拷贝元素。一些删除，插入操作会引起较多的数据移动的操作。</p>
<p>链表，也就是链式数据结构，由于它不要求逻辑上相邻的数据元素在物理位置上也相邻，所以它没有顺序存储结构所具有的缺点，但是同时也失去了通过索引下标直接查找元素的优点。</p>
<p>重点：<strong>链表在计算机的存储中不是连续的，而是前一个节点存储了后一个节点的指针（地址），通过地址找到后一个节点。</strong></p>
<p>下面是单链表的结构：</p>
<figure data-type="image" tabindex="13"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220105084859.png" alt="" loading="lazy"></figure>
<p>一般我们会手动在单链表的前面设置一个前置结点，也可以称为头结点，但是这并非绝对：</p>
<figure data-type="image" tabindex="14"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220105085243.png" alt="" loading="lazy"></figure>
<p>一般链表结构分为以下几种：</p>
<ul>
<li><strong>单向链表</strong>：链表中的每一个结点，都有且只有一个指针指向下一个结点，并且最后一个节点指向空。</li>
<li><strong>双向链表</strong>：每个节点都有两个指针（为方便，我们称之为<strong>前指针</strong>，<strong>后指针</strong>），分别指向上一个节点和下一个节点，第一个节点的前指针指向<code>NULL</code>，最后一个节点的后指针指向<code>NULL</code></li>
<li><strong>循环链表</strong>：每一个节点的指针指向下一个节点，并且最后一个节点的指针指向第一个节点（虽然是循环链表，但是必要的时候还需要标识头结点或者尾节点，避免死循环）</li>
<li><strong>复杂链表</strong>：每一个链表有一个后指针，指向下一个节点，同时有一个随机指针，指向任意一个结点。</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220105235909.png" alt="" loading="lazy"></figure>
<p>链表操作的时间复杂度：</p>
<ul>
<li>查询：<code>O(n)</code>,需要遍历链表</li>
<li>插入：<code>O(1)</code>，修改前后指针即可</li>
<li>删除：<code>O(1)</code>，同样是修改前后指针即可</li>
<li>修改：不需要查询则为<code>O(1)</code>，需要查询则为<code>O(n)</code></li>
</ul>
<p><strong>链表的结构代码怎么表示呢？</strong></p>
<p>下面只表示单链表结构，<code>C++</code>表示：</p>
<pre><code class="language-C++">// 结点
typedef struct LNode{
  // 数据
  ElemType data;
  // 下一个节点的指针
  struct LNode *next;
}*Link,*Position;

// 链表
typedef struct{
  // 头结点，尾节点
  Link head,tail;
  // 长度
  int len;
}LinkList;
</code></pre>
<p><code>Java</code> 代码表示：</p>
<pre><code class="language-Java">    public class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }
</code></pre>
<p>自己实现简单链表，实现增删改查功能：</p>
<pre><code class="language-Java">class ListNode&lt;T&gt; {
    T val;
    ListNode next = null;

    ListNode(T val) {
        this.val = val;
    }
}

public class MyList&lt;T&gt; {
    private ListNode&lt;T&gt; head;
    private ListNode&lt;T&gt; tail;
    private int size;

    public MyList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    public void add(T element) {
        add(size, element);
    }

    public void add(int index, T element) {
        if (index &lt; 0 || index &gt; size) {
            throw new IndexOutOfBoundsException(&quot;超出链表长度范围&quot;);
        }
        ListNode current = new ListNode(element);
        if (index == 0) {
            if (head == null) {
                head = current;
                tail = current;
            } else {
                current.next = head;
                head = current;
            }
        } else if (index == size) {
            tail.next = current;
            tail = current;
        } else {
            ListNode preNode = get(index - 1);
            current.next = preNode.next;
            preNode.next = current;
        }
        size++;
    }

    public ListNode get(int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw new IndexOutOfBoundsException(&quot;超出链表长度&quot;);
        }
        ListNode temp = head;
        for (int i = 0; i &lt; index; i++) {
            temp = temp.next;
        }
        return temp;
    }

    public ListNode delete(int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw new IndexOutOfBoundsException(&quot;超出链表节点范围&quot;);
        }
        ListNode node = null;
        if (index == 0) {
            node = head;
            head = head.next;
        } else if (index == size - 1) {
            ListNode preNode = get(index - 1);
            node = tail;
            preNode.next = null;
            tail = preNode;
        } else {
            ListNode pre = get(index - 1);
            pre.next = pre.next.next;
            node = pre.next;
        }
        size--;
        return node;
    }

    public void update(int index, T element) {
        if (index &lt; 0 || index &gt;= size) {
            throw new IndexOutOfBoundsException(&quot;超出链表节点范围&quot;);
        }
        ListNode node = get(index);
        node.val = element;
    }

    public void display() {
        ListNode temp = head;
        while (temp != null) {
            System.out.print(temp.val + &quot; -&gt; &quot;);
            temp = temp.next;
        }
        System.out.println(&quot;&quot;);
    }
}

</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        MyList myList = new MyList();
        myList.add(1);
        myList.add(2);
        // 1-&gt;2
        myList.display();

        // 1
        System.out.println(myList.get(0).val);

        myList.update(1,3);
        // 1-&gt;3
        myList.display();

        myList.add(4);
        // 1-&gt;3-&gt;4
        myList.display();

        myList.delete(1);
        // 1-&gt;4
        myList.display();
    }
}
</code></pre>
<p>输出结果：</p>
<pre><code class="language-java">1 -&gt; 2 -&gt; 
1
1 -&gt; 3 -&gt; 
1 -&gt; 3 -&gt; 4 -&gt; 
1 -&gt; 4 -&gt;
</code></pre>
<p>单向链表的查找更新比较简单，我们看看插入新节点的具体过程（这里只展示中间位置的插入，头尾插入比较简单）：</p>
<figure data-type="image" tabindex="16"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108113826.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="17"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108113852.png" alt="" loading="lazy"></figure>
<p>那如何删除一个中间的节点呢？下面是具体的过程：</p>
<figure data-type="image" tabindex="18"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220108114627633.png" alt="image-20220108114627633" loading="lazy"></figure>
<p>或许你会好奇，<code>a5</code>节点只是指针没有了，那它去哪里了？</p>
<p>如果是<code>Java</code>程序，垃圾回收器会收集这种没有被引用的节点，帮我们回收掉了这部分内存，但是为了加快垃圾回收的速度，一般不需要的节点我们需要置空，比如 <code>node = null</code>, 如果在<code>C++</code> 程序中，那么就需要手动回收了，否则容易造成内存泄漏等问题。</p>
<p>复杂链表的操作暂时讲到这里，后面我会单独把链表这一块的数据结构以及常用算法单独分享一下，本文章主要讲数据结构全貌。</p>
<h3 id="跳表">跳表</h3>
<p>上面我们可以观察到，链表如果搜索，是很麻烦的，如果这个节点在最后，需要遍历所有的节点，才能找到，查找效率实在太低，有没有什么好的办法呢？</p>
<p>办法总比问题多，但是想要绝对的”<code>多快好省</code>“是不存在的，有舍有得，计算机的世界里，充满哲学的味道。既然搜索效率有问题，那么我们不如给链表排个序。排序后的链表，还是只能知道头尾节点，知道中间的范围，但是要找到中间的节点，还是得走遍历的老路。如果我们把中间节点存储起来呢？存起来，确实我们就知道数据在前一半，还是在后一半。比如找<code>7</code>，肯定就从中间节点开始找。如果查找<code>4</code>,就得从头开始找，最差到中间节点，就停止查找。</p>
<figure data-type="image" tabindex="19"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108120726.png" alt="" loading="lazy"></figure>
<p>但是如此，还是没有彻底解决问题，因为链表很长的情况，只能通过前后两部分查找。不如回到原则：<code>空间和时间，我们选择时间，那就要舍弃一部分空间</code>,我们每个节点再加一个指针，现在有 2 层指针（注意：<strong>节点只有一份，都是同一个节点，只是为了好看，弄了两份，实际上是同一个节点，有两个指针，比如 1 ，既指向2，也指向5</strong>）：</p>
<figure data-type="image" tabindex="20"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108121514.png" alt="" loading="lazy"></figure>
<p>两层指针，问题依然存在，那就不断加层，比如每两个节点，就加一层：</p>
<figure data-type="image" tabindex="21"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108122738.png" alt="" loading="lazy"></figure>
<p>这就是跳表了，跳表的定义如下：</p>
<blockquote>
<p>跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。</p>
</blockquote>
<p>主要的原理是用空间换时间，可以实现近乎二分查找的效率，实际上消耗的空间，假设每两个加一层， <code>1 + 2 + 4 + ... + n = 2n-1</code>,多出了差不多一倍的空间。你看它像不像书的目录，一级目录，二级，三级 ...</p>
<figure data-type="image" tabindex="22"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108123726.gif" alt="" loading="lazy"></figure>
<p>如果我们不断往跳表中插入数据，可能出现某一段节点会特别多的情况，这个时候就需要动态更新索引，除了插入数据，还要插入到上一层的链表中，保证查询效率。</p>
<p><code>redis</code> 中使用了跳表来实现<code>zset</code>,<code>redis</code>中使用一个随机算法来计算层级，计算出每个节点到底多少层索引，虽然不能绝对保证比较平衡，但是基本保证了效率，实现起来比那些平衡树，红黑树的算法简单一点。</p>
<h2 id="栈">栈</h2>
<p>栈是一种数据结构，在<code>Java</code>里面体现是<code>Stack</code>类。它的本质是<strong>先进后出</strong>，就像是一个桶，只能不断的放在上面，取出来的时候，也只能不断的取出最上面的数据。要想取出底层的数据，只有等到上面的数据都取出来，才能做到。当然，如果有这种需求，我们一般会使用双向队列。</p>
<p>以下是栈的特性演示：</p>
<figure data-type="image" tabindex="23"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211228083751.png" alt="" loading="lazy"></figure>
<p>栈的底层用什么实现的？其实可以用链表，也可以用数组，但是<code>JDK</code>底层的栈，是用数组实现的，封装之后，通过<code>API</code>操作的永远都只能是最后一个元素，栈经常用来实现递归的功能。如果想要了解<code>Java</code>里面的栈或者其他集合实现分析，可以看看这系列文章：http://aphysia.cn/categories/collection</p>
<p>元素加入称之为入栈（压栈），取出元素，称之为出栈，栈顶元素则是最后一次放进去的元素。</p>
<p>使用数组实现简单的栈(注意仅供参考测试，实际会有线程安全等问题)：</p>
<pre><code class="language-Java">import java.util.Arrays;

public class MyStack&lt;T&gt; {
    private T[] data;
    private int length = 2;
    private int maxIndex;

    public MyStack() {
        data = (T[]) new Object[length];
        maxIndex = -1;
    }

    public void push(T element) {
        if (isFull()) {
            length = 2 * length;
            data = Arrays.copyOf(data, length);
        }
        data[maxIndex + 1] = element;
        maxIndex++;
    }

    public T pop() {
        if (isEmpty()) {
            throw new IndexOutOfBoundsException(&quot;栈内没有数据&quot;);
        } else {
            T[] newdata = (T[]) new Object[data.length - 1];
            for (int i = 0; i &lt; data.length - 1; i++) {
                newdata[i] = data[i];
            }
            T element = data[maxIndex];
            maxIndex--;
            data = newdata;
            return element;
        }
    }

    private boolean isFull() {
        return data.length - 1 == maxIndex;
    }

    public boolean isEmpty() {
        return maxIndex == -1;
    }

    public void display() {
        for (int i = 0; i &lt; data.length; i++) {
            System.out.print(data[i]+&quot; &quot;);
        }
        System.out.println(&quot;&quot;);
    }
}

</code></pre>
<p>测试代码：</p>
<pre><code class="language-Java">public class MyStackTest {
    public static void main(String[] args) {
        MyStack&lt;Integer&gt; myStack = new MyStack&lt;&gt;();
        myStack.push(1);
        myStack.push(2);
        myStack.push(3);
        myStack.push(4);
        myStack.display();

        System.out.println(myStack.pop());

        myStack.display();

    }
}
</code></pre>
<p>输出结果如下，符合预期：</p>
<pre><code class="language-text">1 2 3 4 
4
1 2 3 
</code></pre>
<p>栈的特点就是先进先出，但是如果需要随机取出前面的数据，效率会比较低，需要倒腾出来，但是如果底层使用数组，理论上是可以通过索引下标取出的，<code>Java</code>里面正是这样实现。</p>
<h2 id="队列">队列</h2>
<p>既然前面有先进后出的数据结构，那我们必定也有先进先出的数据结构，疫情的时候，排队估计大家都有测过核酸，那排队老长了，排在前面先测，排在后面后测，这道理大家都懂。</p>
<figure data-type="image" tabindex="24"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108162737.gif" alt="" loading="lazy"></figure>
<blockquote>
<p>队列是一种特殊的<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081">线性表</a>，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p>
</blockquote>
<p>队列的特点是先进先出，以下是例子：</p>
<figure data-type="image" tabindex="25"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108164851.png" alt="" loading="lazy"></figure>
<p>一般只要说到先进先出（<code>FIFO</code>）,全称<code>First In First Out</code>,就会想到队列，但是如果你想拥有队列即可以从队头取出元素，又可以从队尾取出元素，那就需要用到特殊的队列（双向队列），双向队列一般使用双向链表实现会简单一点。</p>
<p>下面我们用<code>Java</code>实现简单的单向队列：</p>
<pre><code class="language-Java">class Node&lt;T&gt; {
    public T data;
    public Node next;

    public Node(T data) {
        this.data = data;
    }
}

public class MyQueue&lt;T&gt; {
    private Node&lt;T&gt;  head;
    private Node&lt;T&gt;  rear;
    private int size;

    public MyQueue() {
        size = 0;
    }

    public void pushBack(T element) {
        Node newNode = new Node(element);
        if (isEmpty()) {
            head = newNode;
        } else {
            rear.next = newNode;
        }
        rear = newNode;
        size++;
    }

    public boolean isEmpty() {
        return head == null;
    }

    public T popFront() {
        if (isEmpty()) {
            throw new NullPointerException(&quot;队列没有数据&quot;);
        } else {
            Node&lt;T&gt; node = head;
            head = head.next;
            size--;
            return node.data;
        }
    }

    public void dispaly() {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data +&quot; -&gt; &quot;);
            temp = temp.next;
        }
        System.out.println(&quot;&quot;);
    }
}
</code></pre>
<p>测试代码如下：</p>
<pre><code class="language-Java">public class MyStackTest {
    public static void main(String[] args) {
        MyStack&lt;Integer&gt; myStack = new MyStack&lt;&gt;();
        myStack.push(1);
        myStack.push(2);
        myStack.push(3);
        myStack.push(4);
        myStack.display();

        System.out.println(myStack.pop());

        myStack.display();

    }
}
</code></pre>
<p>运行结果：</p>
<pre><code class="language-Java">1 -&gt; 2 -&gt; 3 -&gt; 
1
2 -&gt; 3 -&gt; 
2
3 -&gt; 
</code></pre>
<p>常用的队列类型如下：</p>
<ul>
<li>
<p>单向队列：也就是我们说的普通队列，先进先出。</p>
</li>
<li>
<p>双向队列：可以从不同方向进出队列</p>
</li>
<li>
<p>优先队列：内部是自动排序的，按照一定顺序出队列</p>
</li>
<li>
<p>阻塞队列：从队列取出元素的时候，队列没有元素则会阻塞，同样如果队列满了，往队列里面放入元素也会被阻塞。</p>
</li>
<li>
<p>循环队列：可以理解为一个循环链表，但是一般需要标识出头尾节点，防止死循环，尾节点的<code>next</code>指向头结点。</p>
</li>
</ul>
<p>队列一般可以用来保存需要顺序的数据，或者保存任务，在树的层次遍历中可以使用队列解决，一般广度优先搜索都可以使用队列解决。</p>
<h2 id="哈希表">哈希表</h2>
<p>前面的数据结构，查找的时候，一般都是使用<code>=</code>或者<code>!=</code>,在折半查找或者其他范围查询的时候，可能会使用<code>&lt;</code>和<code>&gt;</code>,理想的时候，我们肯定希望不经过任何的比较，直接能定位到某个位置（存储位置），这种在数组中，可以通过索引取得元素。那么，如果我们将需要存储的数据和数组的索引对应起来，并且是一对一的关系，那不就可以很快定位到元素的位置了么？</p>
<p>只要通过函数<code>f(k)</code>就能找到<code>k</code>对应的位置，这个函数<code>f(k)</code>就是<code>hash</code>函数。它表示的是一种映射关系，但是对不同的值，可能会映射到同一个值（同一个<code>hash</code>地址），也就是<code>f(k1) = f(k2)</code>，这种现象我们称之为<code>冲突</code>或者<code>碰撞</code>。</p>
<p><code>hash</code>表定义如下：</p>
<blockquote>
<p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
</blockquote>
<figure data-type="image" tabindex="26"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108174206.png" alt="" loading="lazy"></figure>
<p>一般常用的<code>hash</code> 函数有：</p>
<ul>
<li>直接定址法：取出关键字或者关键字的某个线性函数的值为哈希函数，比如<code>H(key) = key</code>或者<code>H(key) = a * key + b</code></li>
<li>数字分析法：对于可能出现的数值全部了解，取关键字的若干数位组成哈希地址</li>
<li>平方取中法：取关键字平方后的中间几位作为哈希地址</li>
<li>折叠法：将关键字分割成为位数相同的几部分（最后一部分的位数可以不同），取这几部分的叠加和（舍去进位），作为哈希地址。</li>
<li>除留余数法：取关键字被某个不大于散列表表长<code>m</code>的数<code>p</code>除后所得的余数为散列地址。即h<code>ash(k)=k mod p</code>，<code>p&lt; =m</code>。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对<code>p</code>的选择很重要，一般取素数或<code>m</code>，若<code>p</code>选择不好，容易产生冲突。</li>
<li>随机数法：取关键字的随机函数值作为它的哈希地址。</li>
</ul>
<p>但是这些方法，都无法避免哈希冲突，只能有意识的减少。那处理<code>hash</code>冲突，一般有哪些方法呢？</p>
<ul>
<li>开放地址法：<code>hash</code>计算后，如果该位置已经有数据，那么对该地址<code>+1</code>，也就是往后找，知道找到一个空的位置。</li>
<li>重新<code>hash</code>法：发生哈希冲突后，可以使用另外的<code>hash</code>函数重新极计算，找到空的<code>hash</code>地址,如果有，还可以再叠加<code>hash</code>函数。</li>
<li>链地址法：所有<code>hash</code>值一样的,链接成为一个链表，挂在数组后面。</li>
<li>建立公共溢出区：不常见，意思是所有元素，如果和表中的元素<code>hash</code>冲突，都弄到另外一个表，也叫溢出表。</li>
</ul>
<p><code>Java</code>里面，用的就是链地址法：</p>
<figure data-type="image" tabindex="27"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108175944.png" alt="" loading="lazy"></figure>
<p>但是如果<code>hash</code>冲突比较严重，链表会比较长，查询的时候，需要遍历后面的链表，因此<code>JDK</code>优化了一版，链表的长度超过阈值的时候，会变成<strong>红黑树</strong>，红黑树有一定的规则去平衡子树，避免退化成为链表，影响查询效率。</p>
<figure data-type="image" tabindex="28"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108180256.png" alt="" loading="lazy"></figure>
<p>但是你肯定会想到，如果数组太小了，放了比较多数据了，怎么办？再放冲突的概率会越来越高，其实这个时候会触发一个扩容机制，将数组扩容成为 <code>2</code>倍大小，重新<code>hash</code>以前的数据，哈希到不同的数组中。</p>
<p><code>hash</code>表的优点是查找速度快，但是如果不断触发重新 <code>hash</code>, 响应速度也会变慢。同时，如果希望范围查询，<code>hash</code>表不是好的选择。</p>
<h2 id="树">树</h2>
<p>数组和链表都是线性结构，而这里要介绍的树，则是非线性结构。现实中树是金字塔结构，数据结构中的树，最上面称之为根节点。</p>
<figure data-type="image" tabindex="29"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108212239.gif" alt="" loading="lazy"></figure>
<p>我们该如何定义树结构呢？</p>
<blockquote>
<p><strong>树</strong>是一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>，它是由<em>n(n≥1</em>)个有限节点组成一个具有层次关系的<a href="https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117">集合</a>。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<p>每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树。(百度百科)</p>
</blockquote>
<p>下面是树的基本术语（来自于清华大学数据结构<code>C</code>语言版）：</p>
<ul>
<li>节点的度：一个节点含有的子树的个数称为该节点的度</li>
<li>树的度：一棵树中，最大的节点度称为树的度；</li>
<li>叶节点或终端节点：度为零的节点；</li>
<li>非终端节点或分支节点：度不为零的节点；</li>
<li>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>
<li>节点的层次：从根开始定义起，根为第<code>1</code>层，根的子节点为第<code>2</code>层，以此类推；</li>
<li>深度：对于任意节点<code>n</code>,<code>n</code>的深度为从根到n的唯一路径长，根的深度为<code>0</code>；</li>
<li>高度：对于任意节点<code>n</code>,<code>n</code>的高度为从<code>n</code>到一片树叶的最长路径长，所有树叶的高度为<code>0</code>；</li>
<li>堂兄弟节点：父节点在同一层的节点互为堂兄弟；</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
<li>有序树：将树种的节点的各个子树看成从左至右是有次序的（不能互换），则应该称该树为有序树，否则为无序树</li>
<li>第一个孩子：在有序树中最左边的子树的根称为第一个孩子</li>
<li>最后一个孩子：在有序树种最右边的子树的根称为最后一个孩子</li>
<li>森林：由<code>m</code>（<code>m&gt;=0</code>）棵互不相交的树的集合称为森林；</li>
</ul>
<p>树，其实我们最常用的是二叉树：</p>
<figure data-type="image" tabindex="30"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108213545.png" alt="" loading="lazy"></figure>
<p>二叉树的特点是每个节点最多只有两个子树，并且子树有左右之分，左右子节点的次序不能任意颠倒。</p>
<p>二叉树在<code>Java</code>中表示：</p>
<pre><code class="language-Java">public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
</code></pre>
<p>满二叉树：一棵深度为 k 且有 2<sup>k</sup>-1 个节点的二叉树，称之为满二叉树</p>
<p>完全二叉树：深度为 k 的，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中编号从 1 到 n 的节点一一对应是，称之为完全二叉树。</p>
<figure data-type="image" tabindex="31"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108214243.png" alt="" loading="lazy"></figure>
<p>一般二叉树的遍历有几种：</p>
<ul>
<li>前序遍历：遍历顺序 根节点 --&gt; 左子节点 --&gt; 右子节点</li>
<li>中序遍历：遍历顺序  左子节点  --&gt; 根节点 --&gt; 右子节点</li>
<li>后序遍历：遍历顺序 左子节点 --&gt; 右子节点 --&gt; 根节点</li>
<li>广度 / 层次遍历： 从上往下，一层一层的遍历</li>
</ul>
<p>如果是一棵混乱的二叉树，那查找或者搜索的效率也会比较低，和一条混乱的链表没有什么区别，何必弄更加复杂的结构呢？</p>
<p>其实，二叉树是可以用在排序或者搜索中的，因为二叉树有严格的左右子树之分，我们可以定义根节点，左子节点，右子节点的大小之分。于是有了二叉搜索树：</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/7077965">二叉查找树</a>（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879">二叉树</a>： 若它的左子树不空，则左子树上所有结点的值均小于它的<a href="https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93%E7%82%B9/9795570">根结点</a>的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079">二叉排序树</a>。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p>
</blockquote>
<p>二叉查找树样例如下：</p>
<figure data-type="image" tabindex="32"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108220407.png" alt="" loading="lazy"></figure>
<p>比如上面的树，如果我们需要查找到 <code>4</code>， 从 <code>5</code>开始，<code>4</code>比<code>5</code>小，往左子树走，查找到<code>3</code>，<code>4</code>比<code>3</code>大，往右子树走，找到了<code>4</code>，也就是一个 <code>7</code>个节点的树，我们只查找了<code>3</code>次，也就是层数，假设<code>n</code>个节点，那就是<code>log(n+1)</code>。</p>
<p>树维护好了，查询效率固然高，但是如果树没维护好，容易退化成为链表，查询效率也会下降，比如：</p>
<figure data-type="image" tabindex="33"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108222210.png" alt="" loading="lazy"></figure>
<p>一棵对查询友好的二叉树，应该是一个平衡或者接近平衡的二叉树，何为平衡二叉树：</p>
<blockquote>
<p>平衡二叉搜索树的任何结点的左子树和右子树高度最多相差1。平衡二叉树也称为 AVL 树。</p>
</blockquote>
<p>为了保证插入或者删除数据等之后，二叉树还是平衡二叉树，那么就需要调整节点，这个也称为平衡过程，里面会涉及各种旋转调整，这里暂时不展开。</p>
<p>但是如果涉及大量的更新，删除操作，平衡树种的各种调整需要牺牲不小的性能，为了解决这个问题，有大佬提出了红黑树.</p>
<blockquote>
<p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>科学中用到的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>，典型的用途是实现<a href="https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/3317025">关联数组</a>。 [1]</p>
<p>红黑树是在1972年由[Rudolf Bayer](https://baike.baidu.com/item/Rudolf Bayer/3014716)发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。 [2]</p>
<p>红黑树是一种特化的AVL树（<a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057">平衡二叉树</a>），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p>
</blockquote>
<p>红黑树有以下的特点：</p>
<ul>
<li>
<p>性质1. 结点是红色或黑色。</p>
</li>
<li>
<p>性质2. 根结点是黑色。</p>
</li>
<li>
<p>性质3. 所有叶子都是黑色。（叶子是NIL结点）</p>
</li>
<li>
<p>性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</p>
</li>
<li>
<p>性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。</p>
</li>
</ul>
<p>正是这些特性，让红黑树在调整的时候，不像普通的平衡二叉树调整那般困难，频繁。也就是加上了条条框框，让它符合一定的标准，减少平衡过程的混乱以及频次。</p>
<p>前面说的哈希表，<code>Java</code> 中的实现，正是应用了红黑树，在<code>hash</code>冲突较多的时候，会将链表转换成为红黑树。</p>
<p>上面说的都是二叉树，但是我们不得不扯一下多叉树，为什么呢？虽然二叉树中的各种搜索树，红黑树已经很优秀了，但是在与磁盘交互的时候，大多数是数据存储中，我们不得不考虑 IO 的因素，因为磁盘IO比内存慢太多了。如果索引树的层高有几千上万，那么磁盘读取的时候，需要次数太多了。B树更加适合磁盘存储。</p>
<blockquote>
<p>970年，R.Bayer和E.mccreight提出了一种适用于外查找的<a href="https://baike.baidu.com/item/%E6%A0%91/2699484">树</a>，它是一种平衡的多叉树，称为B树（或B-树、B_树）。</p>
<p>一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：</p>
<p>1、根结点至少有两个子女；</p>
<p>2、每个非根节点所包含的关键字个数 j 满足：m/2 - 1 &lt;= j &lt;= m - 1；</p>
<p>3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故<strong>内部子树</strong>个数 k 满足：m/2 &lt;= k &lt;= m ；</p>
<p>4、所有的叶子结点都位于同一层。</p>
</blockquote>
<p>每个节点放多一点数据，查找的时候，内存中的操作比磁盘快很多，<code>b</code>树可以减少磁盘IO的次数。B 树：</p>
<figure data-type="image" tabindex="34"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108231118.png" alt="" loading="lazy"></figure>
<p>而每个节点的<code>data</code>可能很大,这样会导致每一页查出来的数据很少，IO查询次数自然就增加了，那我们不如只在叶子节点中存储数据：</p>
<figure data-type="image" tabindex="35"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108231837.png" alt="" loading="lazy"></figure>
<blockquote>
<p>B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:</p>
<p>(1)每个结点至多有m个子女；</p>
<p>(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；</p>
<p>(3)有k个子女的结点必有k个关键字。</p>
</blockquote>
<p><strong>一般b+树的叶子节点，会用链表连接起来，方便遍历以及范围遍历。</strong></p>
<p>这就是<code>b+</code>树，<code>b+</code>树相对于<code>B树</code>多了以下优势：</p>
<ol>
<li><code>b+</code>树的中间节点不保存数据，每次IO查询能查到更多的索引，,是一个矮胖的树。</li>
<li>对于范围查找来说，<code>b+</code>树只需遍历叶子节点链表即可，<code>b</code>树却需要从根节点都叶子节点。</li>
</ol>
<p>除了上面的树，其实还有一种叫<code>Huffman</code>树：给定N个权值作为N个<a href="https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/3620239">叶子结点</a>，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
<p>一般用来作为压缩使用，因为数据中，每个字符出现的频率不一样，出现频率越高的字符，我们用越短的编码保存，就可以达到压缩的目的。那这个编码怎么来的呢？</p>
<p>假设字符是<code>hello</code>,那么编码可能是（只是编码的大致雏形，高频率出现的字符，编码更短），编码就是从根节点到当前字符的路径的<code>01</code>串：</p>
<figure data-type="image" tabindex="36"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109140839.png" alt="" loading="lazy"></figure>
<p>通过不同权值的编码，哈夫曼树到了有效的压缩。</p>
<h2 id="堆">堆</h2>
<p>堆，其实也是二叉树中的一种，堆必须是完全二叉树，完全二叉树是：除了最后一层，其他层的节点个数都是满的，最后一层的节点都集中在左部连续位置。</p>
<p>而堆还有一个要求：堆中每一个节点的值都必须大于等于（或小于等于）其左右子节点的值。</p>
<p>堆主要分为两种：</p>
<ul>
<li>大顶堆：每个节点都大于等于其子树节点（堆顶是最大值）</li>
<li>小顶堆：每个节点都小于等于其子树节点（堆顶是最小值）</li>
</ul>
<p>一般情况下，我们都是用数组来表示堆，比如下面的小顶堆：</p>
<figure data-type="image" tabindex="37"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220109000632499.png" alt="image-20220109000632499" loading="lazy"></figure>
<p>数组中父子节点以及左右节点的关系如下：</p>
<ul>
<li><code>i </code>结点的父结点 <code>parent = floor((i-1)/2) </code>(向下取整)</li>
<li><code>i </code>结点的左子结点 <code>2 * i +1</code></li>
<li><code>i </code>结点的右子结点 <code>2 * i + 2</code></li>
</ul>
<p>既然是存储数据的，那么一定会涉及到插入删除等操作，堆里面插入删除，会涉及到堆的调整，调整之后才能重新满足它的定义，这个调整的过程，叫做<strong>堆化</strong>。</p>
<p>用小顶堆举例，调整主要是为了保证：</p>
<ul>
<li>还是完全二叉树</li>
<li>堆中每一个节点都还小于等于其左右子节点</li>
</ul>
<p>对于小顶堆，调整的时候是：小元素往上浮，大元素往下沉，就是不断交换的过程。</p>
<p>堆一般可以用来求解<code>TOP K</code> 问题，或者前面我们说的优先队列等。</p>
<h2 id="图">图</h2>
<p>终于来到了图的讲解，图其实就是二维平面，之前写过扫雷，扫雷的整个方块区域，其实也可以说是图相关的。图是非线性的数据结构，主要是由边和顶点组成。</p>
<figure data-type="image" tabindex="38"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220109002114134.png" alt="image-20220109002114134" loading="lazy"></figure>
<p>同时图又分为有向图与无向图，上面的是无向图，因为边没有指明方向，只是表示两者关联关系，而有向图则是这样：</p>
<figure data-type="image" tabindex="39"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109002313.png" alt="" loading="lazy"></figure>
<p>如果每个顶点是一个地方，每条边是路径，那么这就是一张地图网络，因此图也经常被用于求解最短距离。先来看看图相关的概念：</p>
<ul>
<li>顶点：图最基本的单元，那些节点</li>
<li>边：顶点之间的关联关系</li>
<li>相邻顶点：由边直接关联的顶点</li>
<li>度：一个顶点直接连接的相邻顶点的数量</li>
<li>权重：边的权值</li>
</ul>
<p>一般表示图有以下几种方法：</p>
<ol>
<li>邻接矩阵，使用二维数组表示，为1 表示联通，0表示不连通，当然如果表示路径长度的时候，可以用大于<code>0</code>的数表示路径长度，用<code>-1</code>表示不连通。</li>
</ol>
<p>下面的图片中，0和 1，2连通，我们可以看到第 0行的第1，2列是1 ，表示连通。还有一点：顶点自身我们是标识了0，表示不连通，但是有些情况可以视为连通状态。</p>
<figure data-type="image" tabindex="40"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109115154.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>邻接表</li>
</ol>
<blockquote>
<p>邻接表，存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782">存储结构</a>。如这个表头结点所对应的顶点存在<a href="https://baike.baidu.com/item/%E7%9B%B8%E9%82%BB/1534684">相邻</a>顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。</p>
<p>对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。</p>
</blockquote>
<figure data-type="image" tabindex="41"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109123929.png" alt="" loading="lazy"></figure>
<p>图里面遍历一般分为广度优先遍历和深度优先遍历，广度优先遍历是指优先遍历与当前顶点<strong>直接相关</strong>的顶点，一般借助队列实现。而深度优先遍历则是往一个方向一直走到不能再走，有点不撞南墙不回头的意思，一般使用递归实现。</p>
<p>图，除了用了计算最小路径以外，还有一个概念：最小生成树。</p>
<blockquote>
<p>一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。</p>
</blockquote>
<p>有一种说法，图是平面上的点，我们把其中一个点拎起来，能将其他顶点带起来的边，取最小权值，多余的边去掉，就是最小生成树。</p>
<figure data-type="image" tabindex="42"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109141906.png" alt="" loading="lazy"></figure>
<p>当然，最小生成树并不一定是唯一的，可能存在多种结果。</p>
<h2 id="秦怀观点">秦怀@观点</h2>
<p>了解这些基本的数据结构，在写代码或者数据建模的时候，能够选择更加合适的，这是最大的用处。计算机是为人服务的，代码也是，数据结构的全部类型我们是无法一下子一一掌握的，但是基本的东西是变动不会很大，除非新一代革命性变化。</p>
<p>程序是由数据结构和算法组成，数据结构就像是基石，借助《数据结构C语言》版本中的一句话结尾：</p>
<blockquote>
<p>为了编写出一个”好“的程序，必须分析待处理的对象的特性以及各处理对象之间存在的关系，这就是”数据结构“这门学科和发展的背景。</p>
</blockquote>
<figure data-type="image" tabindex="43"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E7%82%B9%E8%B5%9EV2.gif" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[雪花算法的细枝末节讲解]]></title>
        <id>https://aphysia.cn/post/xue-hua-suan-fa-de-xi-zhi-mo-jie-jiang-jie/</id>
        <link href="https://aphysia.cn/post/xue-hua-suan-fa-de-xi-zhi-mo-jie-jiang-jie/">
        </link>
        <updated>2023-03-01T16:17:30.000Z</updated>
        <summary type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>前面文章在谈论分布式唯一ID生成的时候，有提到雪花算法，这一次，我们详细点讲解，只讲它。</p>
]]></summary>
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />
<p>前面文章在谈论分布式唯一ID生成的时候，有提到雪花算法，这一次，我们详细点讲解，只讲它。</p>
<!-- more -->
<h2 id="snowflake算法">SnowFlake算法</h2>
<blockquote>
<p>据国家大气研究中心的查尔斯·奈特称，一般的雪花大约由10^19个水分子组成。在雪花形成过程中，会形成不同的结构分支，所以说大自然中不存在两片完全一样的雪花，每一片雪花都拥有自己漂亮独特的形状。雪花算法表示生成的id如雪花般独一无二。</p>
<p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。</p>
</blockquote>
<p>核心思想：分布式，唯一。</p>
<h2 id="算法具体介绍">算法具体介绍</h2>
<p>雪花算法是 64 位 的二进制，一共包含了四部分：</p>
<ul>
<li>1位是符号位，也就是最高位，始终是0，没有任何意义，因为要是唯一计算机二进制补码中就是负数，0才是正数。</li>
<li>41位是时间戳，具体到毫秒，41位的二进制可以使用69年，因为时间理论上永恒递增，所以根据这个排序是可以的。</li>
<li>10位是机器标识，可以全部用作机器ID，也可以用来标识机房ID + 机器ID，10位最多可以表示1024台机器。</li>
<li>12位是计数序列号，也就是同一台机器上同一时间，理论上还可以同时生成不同的ID，12位的序列号能够区分出4096个ID。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211015001825.png" alt="" loading="lazy"></figure>
<h3 id="优化">优化</h3>
<p>由于41位是时间戳，我们的时间计算是从1970年开始的，只能使用69年，为了不浪费，其实我们可以用时间的相对值，也就是以项目开始的时间为基准时间，往后可以使用69年。获取唯一ID的服务，对处理速度要求比较高，所以我们全部使用位运算以及位移操作，获取当前时间可以使用<code>System.currentTimeMillis()</code>。</p>
<h3 id="时间回拨问题">时间回拨问题</h3>
<p>在获取时间的时候，可能会出现<code>时间回拨</code>的问题，什么是时间回拨问题呢？就是服务器上的时间突然倒退到之前的时间。</p>
<ol>
<li>人为原因，把系统环境的时间改了。</li>
<li>有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题。</li>
</ol>
<p><strong>解决方案</strong></p>
<ol>
<li>回拨时间小的时候，不生成 ID，循环等待到时间点到达。</li>
<li>上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么超过一定大小的回拨直接报错，拒绝服务，或者有一种方案是利用拓展位，回拨之后在拓展位上加1就可以了，这样ID依然可以保持唯一。但是这个要求我们提前预留出位数，要么从机器id中，要么从序列号中，腾出一定的位，在时间回拨的时候，这个位置 <code>+1</code>。</li>
</ol>
<p>由于时间回拨导致的生产重复的ID的问题，其实百度和美团都有自己的解决方案了，有兴趣可以去看看，下面不是它们官网文档的信息：</p>
<ul>
<li>百度UIDGenerator：https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md
<ul>
<li>UidGenerator是Java实现的, 基于<a href="https://github.com/twitter/snowflake">Snowflake</a>算法的唯一ID生成器。UidGenerator以组件形式工作在应用项目中, 支持自定义workerId位数和初始化策略, 从而适用于<a href="https://www.docker.com/">docker</a>等虚拟化环境下实例自动重启、漂移等场景。 在实现上, UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万。</li>
</ul>
</li>
<li>美团Leaf:https://tech.meituan.com/2019/03/07/open-source-project-leaf.html
<ul>
<li>leaf-segment 方案
<ul>
<li>优化：双buffer + 预分配</li>
<li>容灾：Mysql DB 一主两从，异地机房，半同步方式</li>
<li>缺点：如果用segment号段式方案：id是递增，可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。</li>
</ul>
</li>
<li>leaf-snowflake方案
<ul>
<li>使用Zookeeper持久顺序节点的特性自动对snowflake节点配置workerID
<ul>
<li>1.启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li>
<li>2.如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li>
<li>3.如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li>
</ul>
</li>
<li>缓存workerID，减少第三方组件的依赖</li>
<li>由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。<strong>或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="代码展示">代码展示</h2>
<pre><code class="language-java">public class SnowFlake {

    // 数据中心(机房) id
    private long datacenterId;
    // 机器ID
    private long workerId;
    // 同一时间的序列
    private long sequence;

    public SnowFlake(long workerId, long datacenterId) {
        this(workerId, datacenterId, 0);
    }

    public SnowFlake(long workerId, long datacenterId, long sequence) {
        // 合法判断
        if (workerId &gt; maxWorkerId || workerId &lt; 0) {
            throw new IllegalArgumentException(String.format(&quot;worker Id can't be greater than %d or less than 0&quot;, maxWorkerId));
        }
        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) {
            throw new IllegalArgumentException(String.format(&quot;datacenter Id can't be greater than %d or less than 0&quot;, maxDatacenterId));
        }
        System.out.printf(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;,
                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);

        this.workerId = workerId;
        this.datacenterId = datacenterId;
        this.sequence = sequence;
    }

    // 开始时间戳（2021-10-16 22:03:32）
    private long twepoch = 1634393012000L;

    // 机房号，的ID所占的位数 5个bit 最大:11111(2进制)--&gt; 31(10进制)
    private long datacenterIdBits = 5L;

    // 机器ID所占的位数 5个bit 最大:11111(2进制)--&gt; 31(10进制)
    private long workerIdBits = 5L;

    // 5 bit最多只能有31个数字，就是说机器id最多只能是32以内
    private long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);

    // 5 bit最多只能有31个数字，机房id最多只能是32以内
    private long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);

    // 同一时间的序列所占的位数 12个bit 111111111111 = 4095  最多就是同一毫秒生成4096个
    private long sequenceBits = 12L;

    // workerId的偏移量
    private long workerIdShift = sequenceBits;

    // datacenterId的偏移量
    private long datacenterIdShift = sequenceBits + workerIdBits;

    // timestampLeft的偏移量
    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;

    // 序列号掩码 4095 (0b111111111111=0xfff=4095)
    // 用于序号的与运算，保证序号最大值在0-4095之间
    private long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);

    // 最近一次时间戳
    private long lastTimestamp = -1L;


    // 获取机器ID
    public long getWorkerId() {
        return workerId;
    }


    // 获取机房ID
    public long getDatacenterId() {
        return datacenterId;
    }


    // 获取最新一次获取的时间戳
    public long getLastTimestamp() {
        return lastTimestamp;
    }


    // 获取下一个随机的ID
    public synchronized long nextId() {
        // 获取当前时间戳，单位毫秒
        long timestamp = timeGen();

        if (timestamp &lt; lastTimestamp) {
            System.err.printf(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp);
            throw new RuntimeException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;,
                    lastTimestamp - timestamp));
        }

        // 去重
        if (lastTimestamp == timestamp) {

            sequence = (sequence + 1) &amp; sequenceMask;

            // sequence序列大于4095
            if (sequence == 0) {
                // 调用到下一个时间戳的方法
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            // 如果是当前时间的第一次获取，那么就置为0
            sequence = 0;
        }

        // 记录上一次的时间戳
        lastTimestamp = timestamp;

        // 偏移计算
        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |
                (datacenterId &lt;&lt; datacenterIdShift) |
                (workerId &lt;&lt; workerIdShift) |
                sequence;
    }

    private long tilNextMillis(long lastTimestamp) {
        // 获取最新时间戳
        long timestamp = timeGen();
        // 如果发现最新的时间戳小于或者等于序列号已经超4095的那个时间戳
        while (timestamp &lt;= lastTimestamp) {
            // 不符合则继续
            timestamp = timeGen();
        }
        return timestamp;
    }

    private long timeGen() {
        return System.currentTimeMillis();
    }

    public static void main(String[] args) {
        SnowFlake worker = new SnowFlake(1, 1);
        long timer = System.currentTimeMillis();
        for (int i = 0; i &lt; 10000; i++) {
            worker.nextId();
        }
        System.out.println(System.currentTimeMillis());
        System.out.println(System.currentTimeMillis() - timer);
    }

}


</code></pre>
<h2 id="问题分析">问题分析</h2>
<h3 id="1-第一位为什么不使用">1. 第一位为什么不使用?</h3>
<p>在计算机的表示中，第一位是符号位，0表示整数，第一位如果是1则表示负数，我们用的ID默认就是正数，所以默认就是0，那么这一位默认就没有意义。</p>
<h3 id="2机器位怎么用">2.机器位怎么用？</h3>
<p>机器位或者机房位，一共10 bit，如果全部表示机器，那么可以表示1024台机器，如果拆分，5 bit 表示机房，5bit表示机房里面的机器，那么可以有32个机房，每个机房可以用32台机器。</p>
<h3 id="3-twepoch表示什么">3. twepoch表示什么？</h3>
<p>由于时间戳只能用69年，我们的计时又是从1970年开始的，所以这个<code>twepoch</code>表示从项目开始的时间，用生成ID的时间减去<code>twepoch</code>作为时间戳，可以使用更久。</p>
<h3 id="4-1l-1l-x-表示什么">4. -1L ^ (-1L &lt;&lt; x) 表示什么？</h3>
<p>表示 x 位二进制可以表示多少个数值，假设x为3：</p>
<p>在计算机中，第一位是符号位，负数的反码是除了符号位，1变0，0变1, 而补码则是反码+1：</p>
<pre><code class="language-txt">-1L 原码：1000 0001
-1L 反码：1111 1110
-1L 补码：1111 1111
</code></pre>
<p>从上面的结果可以知道，<strong>-1L其实在二进制里面其实就是全部为1</strong>,那么 -1L 左移动 3位，其实得到 <code>1111 1000</code>，也就是最后3位是0，再与<code>-1L</code>异或计算之后，其实得到的，就是后面3位全是1。<code>-1L ^ (-1L &lt;&lt; x) </code>表示的其实就是x位全是1的值，也就是x位的二进制能表示的最大数值。</p>
<h3 id="5时间戳比较">5.时间戳比较</h3>
<p>在获取时间戳小于上一次获取的时间戳的时候，不能生成ID，而是继续循环，直到生成可用的ID，这里没有使用拓展位防止时钟回拨。</p>
<h3 id="6前端直接使用发生精度丢失">6.前端直接使用发生精度丢失</h3>
<p>如果前端直接使用服务端生成的long 类型 id，会发生精度丢失的问题，因为 JS 中Number是16位的（指的是十进制的数字），而雪花算法计算出来最长的数字是19位的，这个时候需要用 String 作为中间转换，输出到前端即可。</p>
<h2 id="秦怀の观点">秦怀の观点</h2>
<p>雪花算法其实是依赖于时间的一致性的，如果时间回拨，就可能有问题，一般使用拓展位解决。而只能使用69年这个时间限制，其实可以根据自己的需要，把时间戳的位数设置得更多一点，比如42位可以用139年，但是很多公司首先得活下来。当然雪花算法也不是银弹，它也有缺点，在单机上递增，而多台机器只是大致递增趋势，并不是严格递增的。</p>
<p><strong>没有最好的设计方案，只有合适和不合适的方案。</strong></p>
]]></content>
    </entry>
</feed>