<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="秦怀的杂货铺，欢迎你的到来~">
<meta name="theme-color" content="#000">
<title>秦怀记事本</title>
<link rel="shortcut icon" href="/favicon.ico?v=1678900821048">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>秦怀记事本</span>
            </a>  
          
        </div>
        
          <p class="subtitle">纵使缓慢，驰而不息。</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  gemini">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">秦怀</p>
    
    <div class="site-description right-motion">
      
        <p id="binft">争取当个程序员</p>
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">16</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item" style="border-top: 1px dotted #ccc; margin-top: 10px;">
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/Damaer">
              <i class="fa fa-github-alt" title="Github"></i>
            </a>
          
        
        
          
            <a class="social-img" href="#">
              <img src="/media/images/custom-array-imgSocials-1677677245634-socialImg.jpg" />
              <i class="fa fa-wechat" title="微信" ></i>
            </a>
          
        
      </div>
    </div>
  


  <div class="sidebar-item">
    
  </div>

</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          Go
          <small>标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://aphysia.cn/post/go-zhong-de-bi-bao-dao-di-shi-sha/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              01-06
              <small>Go 中的闭包到底是啥？</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      <a href="https://beian.miit.gov.cn/#/Integrated/index" target="_blank">粤ICP备2023003890号</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
    <div class="bg-img">
      <img src="/media/images/custom-bgImg.jpg" />
    </div>
  
  
    
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'Aoba'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'Aoba') {
				AIimgSrc.push(message_Path + "model/Aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'Aoba') {
							model = message_Path + "model/Aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
    

  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/java-fan-she-shi-yong-shuo-tou-che-yi-dian/"" data-c="
          &lt;p&gt;很多时候我们会遇到别人问一个问题：你给我讲一下反射，到底是什么东西？怎么实现的？我们能用反射来做什么？它有什么优缺点？下面我们会围绕着这几个问题展开：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201115212257.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;一-反射机制是什么&#34;&gt;一、反射机制是什么？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;反射是什么？什么是反？什么是正射？&lt;/strong&gt;&lt;br&gt;
有反就有正，我们知道正常情况， 如果我们希望创建一个对象，会使用以下的语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Person person = new Person();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实我们第一次执行上面的语句的时候，JVM会先加载&lt;code&gt;Person.class&lt;/code&gt;，加载到内存完之后，在方法区/堆中会创建了一个&lt;code&gt;Class&lt;/code&gt;对象,对应这个&lt;code&gt;Person&lt;/code&gt;类。这里有争议，有人说是在方法区，有些人说是在堆。个人感觉应该JVM规范说是在方法区，但是不是强制要求，而且不同版本的JVM实现也不一样。具体参考以下链接，这里不做解释：&lt;br&gt;
https://www.cnblogs.com/xy-nb/p/6773051.html&lt;br&gt;
而上面正常的初始化对象的方法，也可以说是“正射”,就是使用&lt;code&gt;Class&lt;/code&gt;对象创建出一个&lt;code&gt;Person&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;而反射则相反，是根据&lt;code&gt;Person&lt;/code&gt;对象，获取到&lt;code&gt;Class&lt;/code&gt;对象，然后可以获取到&lt;code&gt;Person&lt;/code&gt;类的相关信息，进行初始化或者调用等一系列操作。&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;运行状态时&lt;/strong&gt;，可以构造任何一个类的对象，获取到任意一个对象所属的类信息，以及这个类的成员变量或者方法，可以调用任意一个对象的属性或者方法。可以理解为具备了 &lt;strong&gt;动态加载对象&lt;/strong&gt; 以及 &lt;strong&gt;对对象的基本信息进行剖析和使用&lt;/strong&gt; 的能力。&lt;/p&gt;
&lt;p&gt;提供的功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.在运行时判断一个对象所属的类&lt;/li&gt;
&lt;li&gt;2.在运行时构造任意一个类的对象&lt;/li&gt;
&lt;li&gt;3.在运行时获取一个类定义的成员变量以及方法&lt;/li&gt;
&lt;li&gt;4.在运行时调用任意一个对象的方法&lt;/li&gt;
&lt;li&gt;5.生成动态代理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;灵活，强大，可以在运行时装配，无需在组件之间进行源代码链接，但是使用不当效率会有影响。所有类的对象都是Class的实例。&lt;br&gt;
既然我们可以对类的全限定名，方法以及参数等进行配置，完成对象的初始化，那就是相当于增加了java的可配置性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里特别需要明确的一点：类本身也是一个对象，方法也是一个对象，在Java里面万物皆可对象，除了基础数据类型...&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;二-反射的具体使用&#34;&gt;二、反射的具体使用&lt;/h2&gt;
&lt;h3 id=&#34;21-获取对象的包名以及类名&#34;&gt;2.1 获取对象的包名以及类名&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package invocation;
public class MyInvocation {
    public static void main(String[] args) {
        getClassNameTest();
    }
    
    public static void getClassNameTest(){
        MyInvocation myInvocation = new MyInvocation();
        System.out.println(&amp;quot;class: &amp;quot; + myInvocation.getClass());
        System.out.println(&amp;quot;simpleName: &amp;quot; + myInvocation.getClass().getSimpleName());
        System.out.println(&amp;quot;name: &amp;quot; + myInvocation.getClass().getName());
        System.out.println(&amp;quot;package: &amp;quot; +
                &amp;quot;&amp;quot; + myInvocation.getClass().getPackage());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class: class invocation.MyInvocation
simpleName: MyInvocation
name: invocation.MyInvocation
package: package invocation
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由上面结果我们可以看到：&lt;br&gt;
1.&lt;code&gt;getClass()&lt;/code&gt;:打印会带着class+全类名&lt;br&gt;
2.&lt;code&gt;getClass().getSimpleName()&lt;/code&gt;：只会打印出类名&lt;br&gt;
3.&lt;code&gt;getName()&lt;/code&gt;：会打印全类名&lt;br&gt;
4.&lt;code&gt;getClass().getPackage()&lt;/code&gt;:打印出package+包名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getClass()&lt;/code&gt;获取到的是一个对象，&lt;code&gt;getPackage()&lt;/code&gt;也是。&lt;/p&gt;
&lt;h3 id=&#34;22-获取class对象&#34;&gt;2.2 获取Class对象&lt;/h3&gt;
&lt;p&gt;在java中，一切皆对象。java中可以分为两种对象，实例对象和Class对象。这里我们说的获取Class对象，其实就是第二种，Class对象代表的是每个类在运行时的类型信息，指和类相关的信息。比如有一个&lt;code&gt;Student&lt;/code&gt;类，我们用&lt;code&gt;Student student = new Student()&lt;/code&gt;new一个对象出来，这个时候&lt;code&gt;Student&lt;/code&gt;这个类的信息其实就是存放在一个对象中，这个对象就是&lt;strong&gt;Class类的对象&lt;/strong&gt;，而student这个实例对象也会和&lt;strong&gt;Class对象&lt;/strong&gt;关联起来。&lt;br&gt;
我们有三种方式可以获取一个类在运行时的Class对象，分别是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Class.forName(&amp;quot;com.Student&amp;quot;)&lt;/li&gt;
&lt;li&gt;student.getClass()&lt;/li&gt;
&lt;li&gt;Student.class&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package invocation;

public class MyInvocation {
    public static void main(String[] args) {
        getClassTest();
    }
    public static void getClassTest(){
        Class&amp;lt;?&amp;gt; invocation1 = null;
        Class&amp;lt;?&amp;gt; invocation2 = null;
        Class&amp;lt;?&amp;gt; invocation3 = null;
        try {
            // 最常用的方法
            invocation1 = Class.forName(&amp;quot;invocation.MyInvocation&amp;quot;);
        }catch (Exception ex){
            ex.printStackTrace();
        }
        invocation2 = new MyInvocation().getClass();
        invocation3 = MyInvocation.class;
        System.out.println(invocation1);
        System.out.println(invocation2);
        System.out.println(invocation3);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行的结果如下,三个结果一样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class invocation.MyInvocation
class invocation.MyInvocation
class invocation.MyInvocation
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-getinstance获取指定类型的实例化对象&#34;&gt;2.3 getInstance()获取指定类型的实例化对象&lt;/h3&gt;
&lt;p&gt;首先我们有一个Student类，后面都会沿用这个类，将不再重复。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Student{
    private int age;

    private String name;

    public Student() {
    }
    public Student(int age) {
        this.age = age;
    }

    public Student(String name) {
        this.name = name;
    }
    
    public Student(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &amp;quot;Student{&amp;quot; +
                &amp;quot;age=&amp;quot; + age +
                &amp;quot;, name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以使用&lt;code&gt;getInstance()&lt;/code&gt;方法构造出一个Student的对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void getInstanceTest() {
        try {
            Class&amp;lt;?&amp;gt; stduentInvocation = Class.forName(&amp;quot;invocation.Student&amp;quot;);
            Student student = (Student) stduentInvocation.newInstance();
            student.setAge(9);
            student.setName(&amp;quot;Hahs&amp;quot;);
            System.out.println(student);

        }catch (Exception ex){
            ex.printStackTrace();
        }
    }
    
    
输出结果如下：
Student{age=9, name=&#39;Hahs&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果我们取消不写Student的无参构造方法呢？就会出现下面的报错：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.lang.InstantiationException: invocation.Student
	at java.lang.Class.newInstance(Class.java:427)
	at invocation.MyInvocation.getInstanceTest(MyInvocation.java:40)
	at invocation.MyInvocation.main(MyInvocation.java:8)
Caused by: java.lang.NoSuchMethodException: invocation.Student.&amp;lt;init&amp;gt;()
	at java.lang.Class.getConstructor0(Class.java:3082)
	at java.lang.Class.newInstance(Class.java:412)
	... 2 more
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是因为我们重写了构造方法，而且是有参构造方法，如果不写构造方法，那么每个类都会默认有无参构造方法，重写了就不会有无参构造方法了，所以我们调用&lt;code&gt;newInstance()&lt;/code&gt;的时候，会报没有这个方法的错误。值得注意的是,&lt;code&gt;newInstance()&lt;/code&gt;是一个无参构造方法。&lt;/p&gt;
&lt;h3 id=&#34;24-通过构造函数对象实例化对象&#34;&gt;2.4 通过构造函数对象实例化对象&lt;/h3&gt;
&lt;p&gt;除了&lt;code&gt;newInstance()&lt;/code&gt;方法之外，其实我们还可以通过构造函数对象获取实例化对象，怎么理解？这里只构造函数对象，而不是构造函数，也就是构造函数其实就是一个对象，我们先获取构造函数对象，当然也可以使用来实例化对象。&lt;/p&gt;
&lt;p&gt;可以先获取一个类的所有的构造方法，然后遍历输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void testConstruct(){
        try {
            Class&amp;lt;?&amp;gt; stduentInvocation = Class.forName(&amp;quot;invocation.Student&amp;quot;);
            Constructor&amp;lt;?&amp;gt; cons[] = stduentInvocation.getConstructors();
            for(int i=0;i&amp;lt;cons.length;i++){
                System.out.println(cons[i]);
            }

        }catch (Exception ex){
            ex.printStackTrace();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public invocation.Student(int,java.lang.String)
public invocation.Student(java.lang.String)
public invocation.Student(int)
public invocation.Student()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取出一个构造函数我们可以获取到它的各种信息，包括参数，参数个数，类型等等：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void constructGetInstance() {
        try {
            Class&amp;lt;?&amp;gt; stduentInvocation = Class.forName(&amp;quot;invocation.Student&amp;quot;);
            Constructor&amp;lt;?&amp;gt; cons[] = stduentInvocation.getConstructors();
            Constructor constructors = cons[0];
            System.out.println(&amp;quot;name: &amp;quot; + constructors.getName());
            System.out.println(&amp;quot;modifier: &amp;quot; + constructors.getModifiers());
            System.out.println(&amp;quot;parameterCount: &amp;quot; + constructors.getParameterCount());
            System.out.println(&amp;quot;构造参数类型如下：&amp;quot;);
            for (int i = 0; i &amp;lt; constructors.getParameterTypes().length; i++) {
                System.out.println(constructors.getParameterTypes()[i].getName());
            }
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果,&lt;code&gt;modifier&lt;/code&gt;是权限修饰符，1表示为&lt;code&gt;public&lt;/code&gt;，我们可以知道获取到的构造函数是两个参数的，第一个是int，第二个是String类型，看来获取出来的顺序并不一定是我们书写代码的顺序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;name: invocation.Student
modifier: 1
parameterCount: 2
构造参数类型如下：
int
java.lang.String
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;既然我们可以获取到构造方法这个对象了，那么我们可不可以通过它去构造一个对象呢？&lt;strong&gt;答案肯定是可以！！！&lt;/strong&gt;&lt;br&gt;
下面我们用不同的构造函数来创建对象：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static void constructGetInstanceTest() {
        try {
            Class&amp;lt;?&amp;gt; stduentInvocation = Class.forName(&amp;quot;invocation.Student&amp;quot;);
            Constructor&amp;lt;?&amp;gt; cons[] = stduentInvocation.getConstructors();
            // 一共定义了4个构造器
            Student student1 = (Student) cons[0].newInstance(9,&amp;quot;Sam&amp;quot;);
            Student student2 = (Student) cons[1].newInstance(&amp;quot;Sam&amp;quot;);
            Student student3 = (Student) cons[2].newInstance(9);
            Student student4 = (Student) cons[3].newInstance();
            System.out.println(student1);
            System.out.println(student2);
            System.out.println(student3);
            System.out.println(student4);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Student{age=9, name=&#39;Sam&#39;}
Student{age=0, name=&#39;Sam&#39;}
Student{age=9, name=&#39;null&#39;}
Student{age=0, name=&#39;null&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;构造器的顺序我们是必须一一针对的，要不会报一下的参数不匹配的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.lang.IllegalArgumentException: argument type mismatch
	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	at invocation.MyInvocation.constructGetInstanceTest(MyInvocation.java:85)
	at invocation.MyInvocation.main(MyInvocation.java:8)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;25-获取类继承的接口&#34;&gt;2.5 获取类继承的接口&lt;/h3&gt;
&lt;p&gt;通过反射我们可以获取接口的方法，如果我们知道某个类实现了接口的方法，同样可以做到通过类名创建对象调用到接口的方法。&lt;/p&gt;
&lt;p&gt;首先我们定义两个接口，一个&lt;code&gt;InSchool&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface InSchool {
    public void attendClasses();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个&lt;code&gt;AtHome&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface AtHome {
    public void doHomeWork();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建一个实现两个接口的类&lt;code&gt;Student.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Student implements AtHome, InSchool {
    public void doHomeWork() {
        System.out.println(&amp;quot;I am a student,I am doing homework at home&amp;quot;);
    }

    public void attendClasses() {
        System.out.println(&amp;quot;I am a student,I am attend class in school&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; studentClass = Class.forName(&amp;quot;invocation.Student&amp;quot;);
        Class&amp;lt;?&amp;gt;[] interfaces = studentClass.getInterfaces();
        for (Class c : interfaces) {
            // 获取接口
            System.out.println(c);
            // 获取接口里面的方法
            Method[] methods = c.getMethods();
            // 遍历接口的方法
            for (Method method : methods) {
                // 通过反射创建对象
                Student student = (Student) studentClass.newInstance();
                // 通过反射调用方法
                method.invoke(student, null);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201114003042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出其实我们可以获取到接口的数组，并且里面的顺序是我们继承的顺序，通过接口的&lt;strong&gt;Class对象&lt;/strong&gt;，我们可以获取到接口的方法，然后通过方法反射调用实现类的方法，因为这是一个无参数的方法，所以只需要传null即可。&lt;/p&gt;
&lt;h3 id=&#34;26-获取父类相关信息&#34;&gt;2.6 获取父类相关信息&lt;/h3&gt;
&lt;p&gt;主要是使用&lt;code&gt;getSuperclass()&lt;/code&gt;方法获取父类，当然也可以获取父类的方法，执行父类的方法,首先创建一个&lt;code&gt;Animal.java&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Animal {
    public void doSomething(){
        System.out.println(&amp;quot;animal do something&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Dog.java&lt;/code&gt;继承于&lt;code&gt;Animal.java&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Dog extends Animal{
    public void doSomething(){
        System.out.println(&amp;quot;Dog do something&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以通过反射创建&lt;code&gt;Dog&lt;/code&gt;对象，获取其父类&lt;code&gt;Animal&lt;/code&gt;以及创建对象，当然也可以获取&lt;code&gt;Animal&lt;/code&gt;的默认父类&lt;code&gt;Object&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; dogClass = Class.forName(&amp;quot;invocation02.Dog&amp;quot;);
        System.out.println(dogClass);
        invoke(dogClass);

        Class&amp;lt;?&amp;gt; animalClass = dogClass.getSuperclass();
        System.out.println(animalClass);
        invoke(animalClass);

        Class&amp;lt;?&amp;gt; objectClass = animalClass.getSuperclass();
        System.out.println(objectClass);
        invoke(objectClass);
    }

    public static void invoke(Class&amp;lt;?&amp;gt; myClass) throws Exception {
        Method[] methods = myClass.getMethods();
        // 遍历接口的方法
        for (Method method : methods) {
            if (method.getName().equalsIgnoreCase(&amp;quot;doSomething&amp;quot;)) {
                // 通过反射调用方法
                method.invoke(myClass.newInstance(), null);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入如下：&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201114144931.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;27-获取当前类的公有属性和私有属性以及更新&#34;&gt;2.7 获取当前类的公有属性和私有属性以及更新&lt;/h3&gt;
&lt;p&gt;创建一个&lt;code&gt;Person.java&lt;/code&gt;,里面有静态变量，非静态变量，以及&lt;code&gt;public&lt;/code&gt;，&lt;code&gt;protected&lt;/code&gt;,&lt;code&gt;private&lt;/code&gt;不同修饰的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {

    public static String type ;

    private static String subType ;

    // 名字（公开）
    public String name;

    protected String gender;

    private String address;

    @Override
    public String toString() {
        return &amp;quot;Person{&amp;quot; +
                &amp;quot;name=&#39;&amp;quot; + name + &#39;\&#39;&#39; +
                &amp;quot;, address=&#39;&amp;quot; + address + &#39;\&#39;&#39; +
                &#39;}&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;getFields()&lt;/code&gt;可以获取到public的属性，包括static属性，使用&lt;code&gt;getDeclaredFields()&lt;/code&gt;可以获取所有声明的属性，不管是&lt;code&gt;public&lt;/code&gt;，&lt;code&gt;protected&lt;/code&gt;,&lt;code&gt;private&lt;/code&gt;不同修饰的属性。&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;public&lt;/code&gt;属性,只需要&lt;code&gt;field.set(object，value)&lt;/code&gt;即可，但是&lt;code&gt;private&lt;/code&gt;属性不能直接set，否则会报以下的错误。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.IllegalAccessException: Class invocation03.Tests can not access a member of class invocation03.Person with modifiers &amp;quot;private&amp;quot;
	at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102)
	at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296)
	at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288)
	at java.lang.reflect.Field.set(Field.java:761)
	at invocation03.Tests.main(Tests.java:21)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么需要怎么做呢？private默认是不允许外界操作其值的，这里我们可以使用&lt;code&gt;field.setAccessible(true);&lt;/code&gt;，相当于打开了操作的权限。&lt;/p&gt;
&lt;p&gt;那static的属性修改和非static的一样，但是我们怎么获取呢？&lt;br&gt;
如果是&lt;code&gt;public&lt;/code&gt;修饰的，可以直接用类名获取到，如果是&lt;code&gt;private&lt;/code&gt;修饰的，那么需要使用&lt;code&gt;filed.get(object)&lt;/code&gt;,这个方法其实对上面说的所有的属性都可以的。&lt;br&gt;
测试代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Tests {
    public static void main(String[] args) throws Exception{
        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);
        Field[] fields = personClass.getFields();
        // 获取公开的属性
        for(Field field:fields){
            System.out.println(field);
        }
        System.out.println(&amp;quot;=================&amp;quot;);
        // 获取所有声明的属性
        Field[] declaredFields = personClass.getDeclaredFields();
        for(Field field:declaredFields){
            System.out.println(field);
        }
        System.out.println(&amp;quot;=================&amp;quot;);
        Person person = (Person) personClass.newInstance();
        person.name = &amp;quot;Sam&amp;quot;;
        System.out.println(person);

        // 修改public属性
        Field fieldName = personClass.getDeclaredField(&amp;quot;name&amp;quot;);
        fieldName.set(person,&amp;quot;Jone&amp;quot;);

        // 修改private属性
        Field addressName = personClass.getDeclaredField(&amp;quot;address&amp;quot;);
        // 需要修改权限
        addressName.setAccessible(true);
        addressName.set(person,&amp;quot;东风路47号&amp;quot;);
        System.out.println(person);

        // 修改static 静态public属性
        Field typeName = personClass.getDeclaredField(&amp;quot;type&amp;quot;);
        typeName.set(person,&amp;quot;人类&amp;quot;);
        System.out.println(Person.type);

        // 修改静态 private属性
        Field subType = personClass.getDeclaredField(&amp;quot;subType&amp;quot;);
        subType.setAccessible(true);
        subType.set(person,&amp;quot;黄种人&amp;quot;);
        System.out.println(subType.get(person));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201114162617.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;从结果可以看出，不管是&lt;code&gt;public&lt;/code&gt;，还是&lt;code&gt;protected&lt;/code&gt;，&lt;code&gt;private&lt;/code&gt;修饰的，我们都可以通过反射对其进行查询和修改，不管是静态变量还是非静态变量。&lt;br&gt;
&lt;code&gt;getDeclaredField()&lt;/code&gt;可以获取到所有声明的属性，而&lt;code&gt;getFields()&lt;/code&gt;则只能获取到&lt;code&gt;public&lt;/code&gt;的属性。对于非public的属性，我们需要修改其权限才能访问和修改：&lt;code&gt;field.setAccessible(true)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;获取属性值需要使用&lt;code&gt;field.get(object)&lt;/code&gt;，值得注意的是：&lt;strong&gt;每个属性，其本身就是对象&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;28-获取以及调用类的公有私有方法&#34;&gt;2.8 获取以及调用类的公有/私有方法&lt;/h3&gt;
&lt;p&gt;既然可以获取到公有属性和私有属性，那么我想，执行公有方法和私有方法应该都不是什么问题？&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201115211213.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;那下面我们一起来学习一下...&lt;/p&gt;
&lt;p&gt;先定义一个类，包含各种修饰符，以及是否包含参数，是否为静态方法，&lt;code&gt;Person.java&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Person {
    // 非静态公有无参数
    public void read(){
        System.out.println(&amp;quot;reading...&amp;quot;);
    }

    // 非静态公有无参数有返回
    public String getName(){
        return &amp;quot;Sam&amp;quot;;
    }

    // 非静态公有带参数   
    public int readABookPercent(String name){
        System.out.println(&amp;quot;read &amp;quot;+name);
        return 80;
    }

    // 私有有返回值
    private String getAddress(){
        return &amp;quot;东方路&amp;quot;;
    }

    // 公有静态无参数无返回值
    public static void staticMethod(){
        System.out.println(&amp;quot;static public method&amp;quot;);
    }

    // 公有静态有参数
    public static void staticMethodWithArgs(String args){
        System.out.println(&amp;quot;static public method:&amp;quot;+args);
    }

    // 私有静态方法
    private static void staticPrivateMethod(){
        System.out.println(&amp;quot;static private method&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先我们来看看获取里面所有的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Tests {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);
        Method[] methods = personClass.getMethods();
        for (Method method : methods) {
            System.out.println(method);
        }

        System.out.println(&amp;quot;=============================================&amp;quot;);
        Method[] declaredMethods = personClass.getDeclaredMethods();
        for (Method method : declaredMethods) {
            System.out.println(method);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116000934.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
咦，我们发现&lt;code&gt;getMethods()&lt;/code&gt;确实可以获取所有的公有的方法，但是有一个问题，就是他会把父类的也获取到，也就是上面图片绿色框里面的，我们知道所有的类默认都继承了&lt;code&gt;Object&lt;/code&gt;类，所以它把&lt;code&gt;Object&lt;/code&gt;的那些方法都获取到了。&lt;br&gt;
而&lt;code&gt;getDeclaredMethods&lt;/code&gt;确实可以获取到公有和私有的方法，不管是静态还是非静态，但是它是获取不到父类的方法的。&lt;/p&gt;
&lt;p&gt;那如果我们想调用方法呢？先试试调用非静态方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Tests {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);
        Person person = (Person) personClass.newInstance();
        Method[] declaredMethods = personClass.getDeclaredMethods();
        for (Method method : declaredMethods) {
            if(method.getName().equalsIgnoreCase(&amp;quot;read&amp;quot;)){
                method.invoke(person,null);
                System.out.println(&amp;quot;===================&amp;quot;);
            }else if(method.getName().equalsIgnoreCase(&amp;quot;getName&amp;quot;)){
                System.out.println(method.invoke(person,null));
                System.out.println(&amp;quot;===================&amp;quot;);
            }else if(method.getName().equalsIgnoreCase(&amp;quot;readABookPercent&amp;quot;)){
                System.out.println(method.invoke(person,&amp;quot;Sam&amp;quot;));
                System.out.println(&amp;quot;===================&amp;quot;);
            }
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果如下，可以看出&lt;code&gt;method.invoke(person,null);&lt;/code&gt;是调用无参数的方法，而&lt;code&gt;method.invoke(person,&amp;quot;Sam&amp;quot;)&lt;/code&gt;则是调用有参数的方法，要是有更多参数，也只需要在里面多加一个参数即可，返回值也同样可以获取到。&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116001756.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;private&lt;/code&gt;方法呢？我们照着来试试，试试就试试，who 怕 who？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Tests {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);
        Person person = (Person) personClass.newInstance();
        Method[] declaredMethods = personClass.getDeclaredMethods();
        for (Method method : declaredMethods) {
            if(method.getName().equalsIgnoreCase(&amp;quot;getAddress&amp;quot;)){
                method.invoke(person,null);
            }
        }

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果报错了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.IllegalAccessException: Class invocation03.Tests can not access a member of class invocation03.Person with modifiers &amp;quot;private&amp;quot;
	at sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102)
	at java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296)
	at java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288)
	at java.lang.reflect.Method.invoke(Method.java:491)
	at invocation03.Tests.main(Tests.java:13)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116002147.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一看就是没有权限，小场面，不要慌，我来操作一波,只要加上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;method.setAccessible(true);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;哦豁，完美解决了...&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116002514.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;那么问题来了，上面说的都是非静态的，我就想要调用静态的方法。&lt;br&gt;
当然用上面的方法，对象也可以直接调用到类的方法的：&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116002936.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;一点问题都没有，为什么输出结果有几个null,那是因为这函数是无返回值的呀，笨蛋...&lt;/p&gt;
&lt;p&gt;如果我不想用遍历方法的方式，再去判断怎么办？能不能直接获取到我想要的方法啊？那答案肯定是可以啊。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Tests {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);
        Person person = (Person) personClass.newInstance();
        Method method = personClass.getMethod(&amp;quot;readABookPercent&amp;quot;, String.class);
        method.invoke(person, &amp;quot;唐诗三百首&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果和上面调用的完全一样，图我就不放了，就一行字。要是这个方法没有参数呢？那就给一个null就可以啦。或者不给也可以。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Tests {
    public static void main(String[] args) throws Exception {
        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);
        Person person = (Person) personClass.newInstance();
        Method method = personClass.getMethod(&amp;quot;getName&amp;quot;,null);
        System.out.println(method.invoke(person));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三-反射的优缺点&#34;&gt;三、反射的优缺点&lt;/h2&gt;
&lt;h3 id=&#34;31-优点&#34;&gt;3.1 优点&lt;/h3&gt;
&lt;p&gt;反射可以在不知道会运行哪一个类的情况下，获取到类的信息，创建对象以及操作对象。这其实很方便于拓展，所以反射会是框架设计的灵魂，因为框架在设计的时候，为了降低耦合度，肯定是需要考虑拓展等功能的，不能将类型写死，硬编码。&lt;/p&gt;
&lt;p&gt;降低耦合度，变得很灵活，在运行时去确定类型，绑定对象，体现了多态功能。&lt;/p&gt;
&lt;h3 id=&#34;32-缺点&#34;&gt;3.2 缺点&lt;/h3&gt;
&lt;p&gt;这么好用，没有缺点？怎么可能！！！有利就有弊，事物都是有双面性的。&lt;br&gt;
即使功能很强大，但是反射是需要动态类型的，&lt;code&gt;JVM&lt;/code&gt;没有办法优化这部分代码，执行效率相对直接初始化对象较低。一般业务代码不建议使用。&lt;/p&gt;
&lt;p&gt;反射可以修改权限，比如上面访问到&lt;code&gt;private&lt;/code&gt;这些方法和属性，这是会破坏封装性的，有安全隐患，有时候，还会破坏单例的设计。&lt;/p&gt;
&lt;p&gt;反射会使代码变得复杂，不容易维护，毕竟代码还是要先写给人看的嘛，逃~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【作者简介】&lt;/strong&gt;：&lt;br&gt;
秦怀，公众号【&lt;strong&gt;秦怀杂货店&lt;/strong&gt;】作者，技术之路不在一时，山高水长，纵使缓慢，驰而不息。这个世界希望一切都很快，更快，但是我希望自己能走好每一步，写好每一篇文章，期待和你们一起交流。&lt;/p&gt;
&lt;p&gt;此文章仅代表自己（本菜鸟）学习积累记录，或者学习笔记，如有侵权，请联系作者核实删除。人无完人，文章也一样，文笔稚嫩，在下不才，勿喷，如果有错误之处，还望指出，感激不尽~&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201012000828.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">Java反射使用说透彻一点</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/java-native-guan-jian-zi/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;p&gt;今天一不小心跟进Object的源码中，发现一个&lt;code&gt;native&lt;/code&gt;关键字，一脸蒙蔽，怎么我从来没有用过。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 这是计算对象的hsahcode的方法，涉及到内存地址
public native int hashCode();
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201118222529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;1.汇编生&lt;code&gt;c&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;生万物,其实java要实现对底层的控制，还是需要&lt;code&gt;c/c++&lt;/code&gt;帮忙，老大毕竟是老大。&lt;/p&gt;
&lt;p&gt;2.&lt;code&gt;native&lt;/code&gt;关键字我们开发应用的时候是用不到的，那什么时候用到呢？那些开发&lt;strong&gt;java语言&lt;/strong&gt;的时候用到，&lt;code&gt;native&lt;/code&gt;关键字是与&lt;code&gt;c++&lt;/code&gt;联合开发的时候使用的，要不java控制不了底层啊，比如内存。所以还是那句：汇编生&lt;code&gt;c&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;生万物，&lt;code&gt;c++&lt;/code&gt;是&lt;code&gt;c&lt;/code&gt;的升级版。&lt;/p&gt;
&lt;p&gt;3.这是&lt;code&gt;java&lt;/code&gt;调用其他地方的接口的一个声明关键字，意思是这个方法不是java实现的,有挺多的编程语言都有这样的特性，比如&lt;code&gt;c++&lt;/code&gt;里面使用&lt;code&gt;extern &amp;quot;c&amp;quot;&lt;/code&gt;来表示告诉c++编译器去调用c里面已经实现好的函数，而不是自己去实现。&lt;code&gt;native&lt;/code&gt;方法有点像&lt;code&gt;java&lt;/code&gt; 里面的&lt;code&gt;interface&lt;/code&gt;，都不用去实现，而是有别人去实现，但是&lt;code&gt;interface&lt;/code&gt;是谁实现接口谁实现，&lt;code&gt;native&lt;/code&gt;方法是直接交给&lt;code&gt;c/c++&lt;/code&gt;来实现。&lt;code&gt;java&lt;/code&gt;只能调用，由操作系统实现。&lt;/p&gt;
&lt;p&gt;4.&lt;code&gt;native&lt;/code&gt;方法不能与&lt;code&gt;abstract&lt;/code&gt;方法一起使用，因为&lt;code&gt;native&lt;/code&gt;表示这些方法是有实现体的，但是&lt;code&gt;abstract&lt;/code&gt;却表示这些方法是没有实现体的，那么两者矛盾，肯定也不能一起使用。&lt;/p&gt;
&lt;h2 id=&#34;1怎么调用到native方法的呢&#34;&gt;1.怎么调用到native方法的呢？&lt;/h2&gt;
&lt;p&gt;上面说&lt;code&gt;native&lt;/code&gt;表示这个方法不是&lt;code&gt;java&lt;/code&gt;实现的，那么就不是原生态方法，也就不会存在这个文件中，而是存在其他地方，那么java要怎么调用才能调用到呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;JNI(Java Native Interface)这是一个本机编程的接口，它也是java jdk（开发工具包）的一部分，JNI可以支持java中使用其他语言，java要调用其他语言的接口，需要经过他处理。java所谓的跨平台，在一定程度上放弃了底层操作，因为不同的硬件或者操作系统底层的操作都是不一样的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/31426e38350ffdfdc9bd09b72d13e877.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那么我们现在来写一个程序：&lt;code&gt;helloWorld.java&lt;/code&gt;(我的所有写的文件都放在桌面，同个文件夹即可)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class helloworld{
  static
  {
    System.loadLibrary(&amp;quot;cSayHello&amp;quot;);
  }
  public static native void hello();
  @SuppressWarnings(&amp;quot;static-access&amp;quot;)
  public static void main(String[] args){
    new helloworld().hello();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接在编译器运行这段代码会出现下面错误：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/9dee6cd8edb7a01ef8ebbded3d949a3e.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201118223648.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上面的错误是说找不到&lt;code&gt;cSayHello&lt;/code&gt;:&lt;code&gt;no cSayHello in java.library.path&lt;/code&gt;,所以啊，这个&lt;code&gt;c/c++&lt;/code&gt;的方法我们要自己实现，毕竟我们用的不是操作系统以及定义好的方法。&lt;br&gt;
所以我们先来，使用cmd &lt;strong&gt;在helloworld.java所在的目录下&lt;/strong&gt; 使用命令行:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;javac helloworld
javah helloworld
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/db0557017bfcf65baf30b09cdfe13529.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;然后我们可以看到&lt;strong&gt;在helloworld.java所在的目录下&lt;/strong&gt;多了两个文件，一个是&lt;strong&gt;helloworld.class&lt;/strong&gt;文件,一个是&lt;strong&gt;helloworld.h&lt;/strong&gt;文件。&lt;/p&gt;
&lt;p&gt;打开&lt;strong&gt;helloworld.h&lt;/strong&gt;,里面引用了&lt;strong&gt;jni.h&lt;/strong&gt;这个文件，这个文件在我们安装的&lt;code&gt;java&lt;/code&gt;目录下面的&lt;code&gt;include&lt;/code&gt;文件下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/* DO NOT EDIT THIS FILE - it is machine generated */
#include &amp;lt;jni.h&amp;gt;
/* Header for class helloworld */

#ifndef _Included_helloworld
#define _Included_helloworld
#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
/*
 * Class:     helloworld
 * Method:    hello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_helloworld_hello
  (JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我的&lt;code&gt;java&lt;/code&gt;是装在&lt;code&gt;D盘&lt;/code&gt;下面：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/img_convert/c4244e20fac830111b6b8c9dcc12e6c2.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们来写需要引入的&lt;code&gt;c&lt;/code&gt;文件&lt;code&gt;cSayHello&lt;/code&gt;,我也是放在桌面，反正同一个文件夹就可以。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;#include &amp;quot;helloworld.h&amp;quot;
#include &amp;lt;stdio.h&amp;gt;
 
JNIEXPORT void JNICALL Java_helloworld_hello(JNIEnv *env, jclass jc)
{
    printf(&amp;quot;java helloworld&amp;quot;);    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;windows&lt;/code&gt;系统上，需要下载安装&lt;code&gt;WinGW Gcc&lt;/code&gt;，安装教程参考https://www.jianshu.com/p/535a3131ccd8, 安装成功&lt;code&gt;cmd&lt;/code&gt;输入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;gcc -m64  -Wl,--add-stdcall-alias -I&amp;quot;D:\Java\jdk1.8.0_111\include&amp;quot; -I&amp;quot;D:\Java\jdk1.8.0_111\include\win32&amp;quot; -shared -o cSayHello.dll helloworld.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后直接运行,就可以看到输出了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java helloworld
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-java调用自定义native方法步骤&#34;&gt;2. java调用自定义native方法步骤&lt;/h2&gt;
&lt;p&gt;在java中使用native的步骤：&lt;br&gt;
1.在java代码中声明native方法&lt;br&gt;
2.执行javah来生成一个.h文件&lt;br&gt;
3.写.cpp文件来实现native导出的方法，需要包含上面第二步产生的.h文件，同时也包含了jdk自带的jni.h&lt;br&gt;
4.将第三步的.cpp文件通过gcc 编译成动态链接库文件&lt;br&gt;
5.在java中使用的用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问&lt;br&gt;
一般情况下，我们jdk中声明的native方法，在编译的时候都会自动去加载动态链接库文件，而不需要我们自己去操作了。&lt;/p&gt;
&lt;h2 id=&#34;3使用native的缺点&#34;&gt;3.使用native的缺点&lt;/h2&gt;
&lt;p&gt;使用native的缺点：可移植性差，把对底层的控制权交给其他语言，那么也会出现不稳定性，庆幸的是现在操作系统的底层实现基本不会改变。上面hsahcode()的计算真是通过内存所在的内存块来计算的，java是无法直接操作内存的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【作者简介】&lt;/strong&gt;：&lt;br&gt;
秦怀，公众号【&lt;strong&gt;秦怀杂货店&lt;/strong&gt;】作者，技术之路不在一时，山高水长，纵使缓慢，驰而不息。这个世界希望一切都很快，更快，但是我希望自己能走好每一步，写好每一篇文章，期待和你们一起交流。&lt;/p&gt;
&lt;p&gt;此文章仅代表自己（本菜鸟）学习积累记录，或者学习笔记，如有侵权，请联系作者核实删除。人无完人，文章也一样，文笔稚嫩，在下不才，勿喷，如果有错误之处，还望指出，感激不尽~&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201012000828.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">java native关键字</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/huan-cun-chuan-tou-huan-cun-ji-chuan-huan-cun-xue-beng-de-qu-bie-yi-ji-jie-jue-fang-an/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;p&gt;平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数据，可以直接返回空。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;关于缓存，一般会有以下几个常见的问题&lt;/p&gt;
&lt;h2 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h2&gt;
&lt;p&gt;缓存穿透是指，&lt;strong&gt;缓存和数据库都没有的数据&lt;/strong&gt;，被大量请求，比如订单号不可能为&lt;code&gt;-1&lt;/code&gt;，但是用户请求了大量订单号为&lt;code&gt;-1&lt;/code&gt;的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。&lt;br&gt;
如果被恶意用户利用，疯狂请求不存在的数据，就会导致数据库压力过大，甚至垮掉。&lt;/p&gt;
&lt;p&gt;注意：穿透的意思是，都没有，直接一路打到数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那对于这种情况，我们该如何解决呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口增加业务层级的&lt;code&gt;Filter&lt;/code&gt;，进行合法校验，这可以有效拦截大部分不合法的请求。&lt;/li&gt;
&lt;li&gt;作为第一点的补充，最常见的是使用布隆过滤器，针对一个或者多个维度，把可能存在的数据值hash到bitmap中，bitmap证明该数据不存在则该数据一定不存在，但是bitmap证明该数据存在也只能是可能存在，因为不同的数值hash到的bit位很有可能是一样的，hash冲突会导致误判，多个hash方法也只能是降低冲突的概率，无法做到避免。&lt;/li&gt;
&lt;li&gt;另外一个常见的方法，则是针对数据库与缓存都没有的数据，对空的结果进行缓存，但是过期时间设置得较短，一般五分钟内。而这种数据，如果数据库有写入，或者更新，必须同时刷新缓存，否则会导致不一致的问题存在。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;缓存击穿&#34;&gt;缓存击穿&lt;/h2&gt;
&lt;p&gt;缓存击穿是指数据库原本有得数据，但是缓存中没有，一般是缓存突然失效了，这时候如果有大量用户请求该数据，缓存没有则会去数据库请求，会引发数据库压力增大，可能会瞬间打垮。&lt;/p&gt;
&lt;p&gt;针对这类问题，一般有以下做法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是热点数据，那么可以考虑设置永远不过期。&lt;/li&gt;
&lt;li&gt;如果数据一定会过期，那么就需要在数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，要不其他线程会一直拿不到锁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是缓存击穿的时候互斥锁的写法，注意：获取锁之后操作，不管成功或者失败，都应该释放锁，而其他的请求，如果没有获取到锁，应该等待，再重试。当然，如果是需要更加全面一点，应该加上一个等待次数，比如1s中，那么也就是睡眠五次，达到这个阈值，则直接返回空，不应该过度消耗机器，以免当个不可用的场景把整个应用的服务器带挂了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public static String getProductDescById(String id) {
        String desc = redis.get(id);
        // 缓存为空，过期了
        if (desc == null) {
            // 互斥锁，只有一个请求可以成功
            if (redis.setnx(lock_id, 1, 60) == 1) {
                try {
                    // 从数据库取出数据
                    desc = getFromDB(id);
                    redis.set(id, desc, 60 * 60 * 24);
                } catch (Exception ex) {
                    LogHelper.error(ex);
                } finally {
                    // 确保最后删除，释放锁
                    redis.del(lock_id);
                    return desc;
                }
            } else {
                // 否则睡眠200ms，接着获取锁
                Thread.sleep(200);
                return getProductDescById(id);
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h2&gt;
&lt;p&gt;缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。&lt;/p&gt;
&lt;p&gt;针对这种情况，一般我们都是使用以下方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果是热点数据，那么可以考虑设置永远不过期。&lt;/li&gt;
&lt;li&gt;缓存的过期时间除非比较严格，要不考虑设置一个波动随机值，比如理论十分钟，那这类key的缓存时间都加上一个1&lt;sub&gt;3分钟，过期时间在7&lt;/sub&gt;13分钟内波动，有效防止都在同一个时间点上大量过期。&lt;/li&gt;
&lt;li&gt;方法1避免了有效过期的情况，但是要是所有的热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此将热点数据打散分不到不同的机房中，也可以有效减少这种情况。&lt;/li&gt;
&lt;li&gt;也可以考虑双缓存的方式，数据库数据同步到缓存A和B，A设置过期时间，B不设置过期时间，如果A为空的时候去读B，同时异步去更新缓存，但是更新的时候需要同时更新两个缓存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如设置产品的缓存时间：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;redis.set(id,value,60*60 + Math.random()*1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;缓存穿透是指数据库原本就没有的数据，请求如入无人之境，直奔数据库，而缓存击穿，则是指数据库有数据，缓存也本应该有数据，但是突然缓存过期了，这层保护屏障被击穿了，请求直奔数据库，缓存雪崩则是指很多缓存同一个时间失效了，流量全部涌入数据库，造成数据库极大的压力。&lt;/p&gt;
">缓存穿透，缓存击穿，缓存雪崩的区别以及解决方案</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/bu-long-guo-lu-qi-de-san-chong-shi-jian/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;p&gt;前面我们已经讲过布隆过滤器的原理，都理解是这么运行的，那么一般我们使用布隆过滤器，是怎么去使用呢？如果自己去实现，又是怎么实现呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;布隆过滤器&#34;&gt;布隆过滤器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;再念一次定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;布隆过滤器（&lt;code&gt;Bloom Filter&lt;/code&gt;）是由布隆（&lt;code&gt;Burton Howard Bloom&lt;/code&gt;）在 1970 年提出的，它实际上是由一个很长的二进制向量和一系列随机&lt;code&gt;hash&lt;/code&gt;映射函数组成（说白了，就是用二进制数组存储数据的特征）。&lt;/p&gt;
&lt;p&gt;譬如下面例子：有三个&lt;code&gt;hash&lt;/code&gt;函数，那么“陈六”就会被三个&lt;code&gt;hash&lt;/code&gt;函数分别&lt;code&gt;hash&lt;/code&gt;，并且对位数组的长度，进行取余，分别hash到三个位置。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果对原理还有不理解的地方，可以查看我的上一篇文章。&lt;/p&gt;
&lt;h2 id=&#34;手写布隆过滤器&#34;&gt;手写布隆过滤器&lt;/h2&gt;
&lt;p&gt;那么我们手写布隆过滤器的时候，首先需要一个位数组，在&lt;code&gt;Java&lt;/code&gt;里面有一个封装好的位数组，&lt;code&gt;BitSet&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;简单介绍一下&lt;code&gt;BitSet&lt;/code&gt;，也就是位图，里面实现了使用紧凑的存储空间来表示大空间的位数据。使用的时候，我们可以直接指定大小，也就是相当于创建出指定大小的位数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BitSet bits = new BitSet(size);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时，&lt;code&gt;BitSet&lt;/code&gt;提供了大量的&lt;code&gt;API&lt;/code&gt;，基本的操作主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清空位数组的数据&lt;/li&gt;
&lt;li&gt;翻转某一位的数据&lt;/li&gt;
&lt;li&gt;设置某一位的数据&lt;/li&gt;
&lt;li&gt;获取某一位的数据&lt;/li&gt;
&lt;li&gt;获取当前的&lt;code&gt;bitSet&lt;/code&gt;的位数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面就讲一下，写一个简单的布隆过滤器需要考虑的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;位数组的大小空间，需要指定，其他相同的时候，位数组的大小越大，&lt;code&gt;hash&lt;/code&gt;冲突的可能性越小。&lt;/li&gt;
&lt;li&gt;多个&lt;code&gt;hash&lt;/code&gt;函数，我们需要使用&lt;code&gt;hash&lt;/code&gt;数组来存，&lt;code&gt;hash&lt;/code&gt;函数需要如何设置呢？为了避免冲突，我们应该使用多个不同的质数来当种子。&lt;/li&gt;
&lt;li&gt;方法：主要实现两个方法，一个往布隆过滤器里面添加元素，另一个是判断布隆过滤器是否包含某个元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是具体的实现,只是简单的模拟，不可用于生产环境，&lt;code&gt;hash&lt;/code&gt;函数较为简单，主要是使用 &lt;code&gt;hash&lt;/code&gt; 值得高低位进行异或，然后乘以种子，再对位数组大小进行取余数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.BitSet;

public class MyBloomFilter {

    // 默认大小
    private static final int DEFAULT_SIZE = Integer.MAX_VALUE;

    // 最小的大小
    private static final int MIN_SIZE = 1000;

    // 大小为默认大小
    private int SIZE = DEFAULT_SIZE;

    // hash函数的种子因子
    private static final int[] HASH_SEEDS = new int[]{3, 5, 7, 11, 13, 17, 19, 23, 29, 31};

    // 位数组，0/1,表示特征
    private BitSet bitSet = null;

    // hash函数
    private HashFunction[] hashFunctions = new HashFunction[HASH_SEEDS.length];

    // 无参数初始化
    public MyBloomFilter() {
        // 按照默认大小
        init();
    }

    // 带参数初始化
    public MyBloomFilter(int size) {
        // 大小初始化小于最小的大小
        if (size &amp;gt;= MIN_SIZE) {
            SIZE = size;
        }
        init();
    }

    private void init() {
        // 初始化位大小
        bitSet = new BitSet(SIZE);
        // 初始化hash函数
        for (int i = 0; i &amp;lt; HASH_SEEDS.length; i++) {
            hashFunctions[i] = new HashFunction(SIZE, HASH_SEEDS[i]);
        }
    }

    // 添加元素，相当于把元素的特征添加到位数组
    public void add(Object value) {
        for (HashFunction f : hashFunctions) {
            // 将hash计算出来的位置为true
            bitSet.set(f.hash(value), true);
        }
    }

    // 判断元素的特征是否存在于位数组
    public boolean contains(Object value) {
        boolean result = true;
        for (HashFunction f : hashFunctions) {
            result = result &amp;amp;&amp;amp; bitSet.get(f.hash(value));
            // hash函数只要有一个计算出为false，则直接返回
            if (!result) {
                return result;
            }
        }
        return result;
    }

    // hash函数
    public static class HashFunction {
        // 位数组大小
        private int size;
        // hash种子
        private int seed;

        public HashFunction(int size, int seed) {
            this.size = size;
            this.seed = seed;
        }

        // hash函数
        public int hash(Object value) {
            if (value == null) {
                return 0;
            } else {
                // hash值
                int hash1 = value.hashCode();
                // 高位的hash值
                int hash2 = hash1 &amp;gt;&amp;gt;&amp;gt; 16;
                // 合并hash值(相当于把高低位的特征结合)
                int combine = hash1 ^ hash1;
                // 相乘再取余
                return Math.abs(combine * seed) % size;
            }
        }

    }

    public static void main(String[] args) {
        Integer num1 = new Integer(12321);
        Integer num2 = new Integer(12345);
        MyBloomFilter myBloomFilter =new MyBloomFilter();
        System.out.println(myBloomFilter.contains(num1));
        System.out.println(myBloomFilter.contains(num2));

        myBloomFilter.add(num1);
        myBloomFilter.add(num2);

        System.out.println(myBloomFilter.contains(num1));
        System.out.println(myBloomFilter.contains(num2));

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果,符合预期：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;false
false
true
true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是上面的这种做法是不支持预期的误判率的，只是可以指定位数组的大小。&lt;/p&gt;
&lt;p&gt;当然我们也可以提供数据量，以及期待的大致的误判率来初始化，大致的初始化代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    // 带参数初始化
    public BloomFilter(int num,double rate) {
        // 计算位数组的大小
        this.size = (int) (-num * Math.log(rate) / Math.pow(Math.log(2), 2));
        // hsah 函数个数
        this.hashSize = (int) (this.size * Math.log(2) / num);
        // 初始化位数组
        this.bitSet = new BitSet(size);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;redis实现&#34;&gt;Redis实现&lt;/h2&gt;
&lt;p&gt;平时我们可以选择使用&lt;code&gt;Redis&lt;/code&gt;的特性于布隆过滤器，为什么呢？因为&lt;code&gt;Redis&lt;/code&gt;里面有类似于&lt;code&gt;BitSet&lt;/code&gt;的指令，比如设置位数组的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;setbit key offset value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的&lt;code&gt;key&lt;/code&gt;是键，&lt;code&gt;offset&lt;/code&gt;是偏移量，&lt;code&gt;value&lt;/code&gt;就是&lt;code&gt;1&lt;/code&gt;或者&lt;code&gt;0&lt;/code&gt;。比如下面的就是将key1 的第7位置为1。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210314110134.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而获取某一位的数值可以使用下面这个命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;gitbit key offset
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;借助&lt;code&gt;redis&lt;/code&gt;这个功能我们可以实现优秀的布隆过滤器，但是实际上我们不需要自己去写了，&lt;code&gt;Redisson&lt;/code&gt;这个客户端已经有较好的实现。&lt;br&gt;
下面就是用法：&lt;br&gt;
使用&lt;code&gt;maven&lt;/code&gt;构建项目，首先需要导包到&lt;code&gt;pom.xml&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.11.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码如下，我使用的&lt;code&gt;docker&lt;/code&gt;，启动的时候记得设置密码，运行的时候修改密码不起效果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;docker run -d --name redis -p 6379:6379 redis --requirepass &amp;quot;password&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现的代码如下，首先需要连接上&lt;code&gt;redis&lt;/code&gt;，然后创建&lt;code&gt;redission&lt;/code&gt;，使用&lt;code&gt;redission&lt;/code&gt;创建布隆过滤器，直接使用即可。（&lt;strong&gt;可以指定预计的数量以及期待的误判率&lt;/strong&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.redisson.Redisson;
import org.redisson.api.RBloomFilter;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

public class BloomFilterTest {
    public static void main(String[] args) {
        Config config = new Config();
        config.useSingleServer().setAddress(&amp;quot;redis://localhost:6379&amp;quot;);
        config.useSingleServer().setPassword(&amp;quot;password&amp;quot;);
        // 相当于创建了redis的连接
        RedissonClient redisson = Redisson.create(config);

        RBloomFilter&amp;lt;String&amp;gt; bloomFilter = redisson.getBloomFilter(&amp;quot;myBloomFilter&amp;quot;);
        //初始化,预计元素数量为100000000,期待的误差率为4%
        bloomFilter.tryInit(100000000,0.04);
        //将号码10086插入到布隆过滤器中
        bloomFilter.add(&amp;quot;12345&amp;quot;);

        System.out.println(bloomFilter.contains(&amp;quot;123456&amp;quot;));//false
        System.out.println(bloomFilter.contains(&amp;quot;12345&amp;quot;));//true
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下：值得注意的是，这是单台&lt;code&gt;redis&lt;/code&gt;的情况，如果是&lt;code&gt;redis&lt;/code&gt;集群的做法略有不同。&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210314233301.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;google-guava实现&#34;&gt;Google GUAVA实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Google&lt;/code&gt;提供的&lt;code&gt;guava&lt;/code&gt;包里面也提供了布隆过滤器,引入&lt;code&gt;pom&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;18.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体的实现调用的代码如下,同样可以指定具体的存储数量以及预计的误判率：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.google.common.base.Charsets;
import com.google.common.hash.BloomFilter;
import com.google.common.hash.Funnels;

public class GuavaBloomFilter {
    public static void main(String[] args) {
        BloomFilter&amp;lt;String&amp;gt; bloomFilter = BloomFilter.create(
                Funnels.stringFunnel(Charsets.UTF_8),1000000,0.04);

        bloomFilter.put(&amp;quot;Sam&amp;quot;);

        System.out.println(bloomFilter.mightContain(&amp;quot;Jane&amp;quot;));
        System.out.println(bloomFilter.mightContain(&amp;quot;Sam&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行的结果如下,符合预期&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210314234457.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面三种分别是手写，&lt;code&gt;redis&lt;/code&gt;，&lt;code&gt;guava&lt;/code&gt;实践了布隆过滤器，只是简单的用法，其实&lt;code&gt;redis&lt;/code&gt;和&lt;code&gt;guava&lt;/code&gt;里面的实现也可以看看，有兴趣可以了解一下，我先立一个&lt;code&gt;Flag&lt;/code&gt;。&lt;/p&gt;
">布隆过滤器的三种实践</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/bu-long-guo-lu-qi-xiang-jie/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;p&gt;前面我们提到，在防止缓存穿透的情况（缓存穿透是指，&lt;strong&gt;缓存和数据库都没有的数据&lt;/strong&gt;，被大量请求，比如订单号不可能为&lt;code&gt;-1&lt;/code&gt;，但是用户请求了大量订单号为&lt;code&gt;-1&lt;/code&gt;的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。）,我们可以考虑使用布隆过滤器，来过滤掉绝对不存于集合中的元素。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;布隆过滤器是什么呢&#34;&gt;布隆过滤器是什么呢？&lt;/h2&gt;
&lt;p&gt;布隆过滤器（Bloom Filter）是由布隆（Burton Howard Bloom）在1970年提出的，它实际上是由一个很长的二进制向量和一系列随机hash映射函数组成（说白了，就是用二进制数组存储数据的特征）。可以使用它来判断一个元素是否存在于集合中，它的优点在于查询效率高，空间小，缺点是存在一定的误差，以及我们想要剔除元素的时候，可能会相互影响。&lt;/p&gt;
&lt;p&gt;也就是当一个元素被加入集合的时候，通过多个hash函数，将元素映射到位数组中的k个点，置为1。&lt;/p&gt;
&lt;h2 id=&#34;为什么需要布隆过滤器&#34;&gt;为什么需要布隆过滤器？&lt;/h2&gt;
&lt;p&gt;一般情况下，我们想要判断是否存在某个元素，一开始考虑肯定是使用数组，但是使用数组的情况，查找的时候效率比较慢，要判断一个元素不存在于数组中，需要每次遍历完所有的元素。删除完一个元素后，还得把后面的其他元素往前面移动。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308225741.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;其实可以考虑使用&lt;code&gt;hash&lt;/code&gt;表，如果有&lt;code&gt;hash&lt;/code&gt;表来存储，将是以下的结构：&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308230509.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是这种结构，虽然满足了大部分的需求，可能存在两点缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有一个hash函数，其实两个元素hash到一块，也就是产生hash冲突的可能性，还是比较高的。虽然可以用拉链法（后面跟着一个链表）的方式解决，但是操作时间复杂度可能有所升高。&lt;/li&gt;
&lt;li&gt;存储的时候，我们需要把元素引用给存储进去，要是上亿的数据，我们要将上亿的数据存储到一个hash表里面，不太建议这样操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于上面存在的缺陷，其实我们可以考虑，用多个hash函数来减少冲突（注意：冲突时不可以避免的，只能减少），用位来存储每一个hash值。这样既可以减少hash冲突，还可以减少存储空间。&lt;/p&gt;
&lt;p&gt;假设有三个hash函数，那么不同的元素，都会使用三个hash函数，hash到三个位置上。&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233116.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;假设后面又来了一个张三，那么在hash的时候，同样会hash到以下位置，所有位都是1，我们就可以说张三已经存在在里面了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233607.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那么有没有可能出现误判的情况呢？这是有可能的，比如现在只有张三，李四，王五，蔡八，hash映射值如下：&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233752.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;后面来了陈六，但是不凑巧的是，它hash的三个函数hash出来的位，刚刚好就是被别的元素hash之后，改成1了，判断它已经存在了，但是实际上，陈六之前是不存在的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上面的情况，就是误判，布隆过滤器都会不可避免的出现误判。但是它有一个好处是，&lt;strong&gt;布隆过滤器，判断存在的元素，可能不存在，但是判断不存在的元素，一定不存在。&lt;/strong&gt;，因为判断不存在说明至少有一位hash出来是对不上的。&lt;/p&gt;
&lt;p&gt;也是由于会出现多个元素可能hash到一起，但有一个数据被踢出了集合，我们想把它映射的位，置为0，相当于删除该数据。这个时候，就会影响到其他的元素，可能会把别的元素映射的位，置为了0。这也就是为什么布隆过滤器不能删除的原因。&lt;/p&gt;
&lt;h2 id=&#34;具体步骤&#34;&gt;具体步骤&lt;/h2&gt;
&lt;p&gt;添加元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;使用多个hash函数对元素item进行hash运算，得到多个hash值。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;每一个hash值对bit位数组取模，得到位数组中的位置索引index。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;如果index的位置不为1，那么就将该位置为1。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判断元素是否存在：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;使用多个hash函数对元素item进行hash运算，得到多个hash值。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;每一个hash值对bit位数组取模，得到位数组中的位置索引index。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;如果index所处的位置都为1，说明元素可能已经存在了。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;误判率推导&#34;&gt;误判率推导&lt;/h2&gt;
&lt;p&gt;庆幸的是，布隆过滤器的误判率是可以预测的，由上面的分析，也可以得知，其实是与位数组的大小，以及hash函数的个数等，这些都是息息相关的。&lt;/p&gt;
&lt;p&gt;假设位数组的大小是m，我们一共有k个hash函数，那么每一个hash函数，进行hash的时候，只能hash到m位中的一个位置，所以没有被hash到的概率是：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1-\frac{1}{m}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.00744em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;k个hash函数都hash之后，该位还是没有被hash到1的概率是：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(1-\frac{1}{m})^k
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.00744em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8991079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果我们插入了n个元素，也就是hash了n*k次，该位还是没有被hash成1的概率是：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(1-\frac{1}{m})^{kn}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.00744em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8991079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那该位为1的概率就是：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1-(1-\frac{1}{m})^{kn}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.00744em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8991079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果需要检测某一个元素是不是在集合中，也就是该元素对应的k个hash元素hash出来的值，都需要设置为1。也就是该元素不存在，但是该元素对应的所有位都被hash成为1的概率是：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;≈&lt;/mo&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{(1-(1-\frac{1}{m})^{kn})}^{k}\approx {(1-e^{-kn/m})}^k 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.246448em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.32144em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8991079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.560448em;&#34;&gt;&lt;span style=&#34;top:-3.7743400000000005em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≈&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.4270079999999998em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.938em;&#34;&gt;&lt;span style=&#34;top:-3.113em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.1770079999999998em;&#34;&gt;&lt;span style=&#34;top:-3.3909000000000002em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以大致看出，随着位数组大小m和hash函数个数的增加，其实概率会下降，随着插入的元素n的增加，概率会有所上升。&lt;/p&gt;
&lt;p&gt;最后也可以通过自己期待的误判率P和期待添加的个数n，来大致计算出布隆过滤器的位数组的长度：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;m=-(\frac{nInP}{(In2)^2})
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.29633em;vertical-align:-0.936em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.36033em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.740108em;&#34;&gt;&lt;span style=&#34;top:-2.9890000000000003em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.936em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面就是误判率的大致计算方式，同时也提示我们，可以根据自己业务的数据量以及误判率，来调整我们的数组的大小。&lt;/p&gt;
&lt;h2 id=&#34;布隆过滤器的作用&#34;&gt;布隆过滤器的作用&lt;/h2&gt;
&lt;p&gt;除了我们前面说的过滤爬虫恶意请求，还可以对一些URL进行去重，过滤海量数据里面的重复数据，过滤数据库里面不存在的id等等。&lt;/p&gt;
&lt;p&gt;但是，即使有布隆过滤器，我们也不可能完全避免，或者彻底解决缓存穿透这个问题。只是相当于做了优化，将准确率提高。&lt;/p&gt;
&lt;p&gt;很多的key-value数据库也会使用布隆过滤器来加快查询效率，因为全部挨个判断一遍，这个效率太低了。&lt;/p&gt;
">布隆过滤器详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/bing-fa-zhong-fen-bu-shi-suo-setnx-jie-xi/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
前面讲解到，如果出现网络延迟的情况下，多个请求阻塞，那么恶意攻击就可以全部请求领取接口成功，而针对这种做法，我们使用`setnx`来解决，确保只有一个请求可以进入接口请求。
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226230957.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String receiveGitf(int activityId,int giftId,String uid){
        // isExist判断活动是否存在，内部包括redis和数据库请求，省略
        if(isActivityExist(activityId,giftId)){
            // 活动和礼品有效,判断是否领取过
            if(!userReceived(uid,activityId,giftId)){
                // 没有领取过，调用C系统
                try {
                    // setnx
                    if(redis.setnx(&amp;quot;uid_activityId_giftId&amp;quot;)){
                        boolean receivedResult = Http.getMethod(C_Client.class, &amp;quot;distributeGift&amp;quot;);
                        if(receivedResult){
                            // 领取成功更新mysql
                            updateMysql(uid,activityId,giftId);
                        }else{
                            // 领取成功更新redis
                            deleteRedis(uid,activityId,giftId);
                            return &amp;quot;已经领过/领取失败&amp;quot;;
                        }
                    }else{
                        return &amp;quot;已经领过/领取失败&amp;quot;;
                    }
                }catch (Exception e){
                    // 记录日志
                    logHelper.log(e);
                    return &amp;quot;调用领券系统失败，请重试&amp;quot;;
                }
            }
        }
        return &amp;quot;领取失败，活动不存在&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面，我们就专门讲解一下&lt;code&gt;setnx&lt;/code&gt;，&lt;code&gt;setnx&lt;/code&gt;可以用作分布式锁，但是&lt;strong&gt;这个场景并不是分布式锁的一个较好的实践，因为每个用户的key都是不一样的，我们主要是防止同一个用户恶意领取&lt;/strong&gt;，&lt;code&gt;setnx&lt;/code&gt;本身是一个原子操作，可以保证多个线程只有一个能拿到锁，能返回&lt;code&gt;true&lt;/code&gt;,其他的都会返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是上面的做法，没有设置过期时间，在生产上一般是不可以这么使用。&lt;strong&gt;不设置过期时间的key多了之后，redis服务器很容易内存打满，这时候不知道哪些是强制依赖的，只能扩容，从代码层面去清理，如果直接清理不常用的，也很难保证不出事。&lt;/strong&gt;（基本不允许这么干，除非是基础数据，跟着服务器启动，写入&lt;code&gt;redis&lt;/code&gt;的，不会变更的，比如城市数据，国家数据等等，当然，这些也可以考虑在本地内存中实现）&lt;/p&gt;
&lt;p&gt;如果在上面的代码中，加入超时时间，假设是一个月或者半年，流程变成这样：&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210228165201.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;设置key的超时时间使用&lt;code&gt;expire&lt;/code&gt;,但是这样还有缺陷么？&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;redis 2.6.12&lt;/code&gt;之前，&lt;code&gt;setnx&lt;/code&gt;和&lt;code&gt;expire&lt;/code&gt;都不是原子操作，也就是很有可能在&lt;code&gt;setnx&lt;/code&gt;成功之后，redis当季，expire设置失败，也就不会有超时时间了。虽然这个影响在当前业务不是很大，但是还是一个小缺陷。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Redis2.6.12&lt;/code&gt;以上版本，可以用&lt;code&gt;set&lt;/code&gt;获取锁,set包含&lt;code&gt;setnx&lt;/code&gt;和&lt;code&gt;expire&lt;/code&gt;，实现了原子操作。也就是两步要么一起成功，要么一起失败。&lt;/p&gt;
&lt;p&gt;除此之外，上面的流程可能还存在的一个问题，是请求&lt;code&gt;C&lt;/code&gt;服务的时候出现超时，然后删除key，恰好这个时候&lt;code&gt;redis&lt;/code&gt;有问题，删除失败了，这个&lt;code&gt;key&lt;/code&gt;就永远存在了。表现在业务上，就是&lt;code&gt;A&lt;/code&gt;用户点击了领取，领取失败了，但是后面再怎么点，都是已经领取的状态了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那这种现象怎么优化呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况，其实已经是很少见的情况，按照我们当前的业务场景也看，就是当前的用户，&lt;code&gt;redis&lt;/code&gt;记录了它已经领取过了，但是由于接口的失败，成功之后还没将&lt;code&gt;mysql/其他数据库&lt;/code&gt;更新,两个数据库不一致了。&lt;/p&gt;
&lt;p&gt;我能想到的一个方法，就是再删除失败的时候，告警，并且将业务相关的数据记录下来，比如&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;uid&lt;/code&gt;等等，针对这部分数据，做一次补发，或者手动删除key。&lt;/p&gt;
&lt;p&gt;或者，启动一个定时任务或者&lt;code&gt;lua&lt;/code&gt;脚本，去判定&lt;code&gt;redis&lt;/code&gt;和数据库不一致的情况，但是切记不要全部查询，应该是隔一段时间，查询最后增加的部分，做一个校验以及相应的处理。枚举&lt;code&gt;key&lt;/code&gt;是十分耗时的操作！！！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setnx&lt;/code&gt; 除了解决上面的问题，还可以应用在解决&lt;strong&gt;缓存击穿&lt;/strong&gt;的问题上。&lt;/p&gt;
&lt;p&gt;譬如现在有热点数据，不仅在&lt;code&gt;mysql&lt;/code&gt;数据库存储了，还在&lt;code&gt;redis&lt;/code&gt;中存了一份缓存，那么如果有一个时间点，缓存失效了，这时候，大量的请求打过来，同时到达，缓存拿不到数据，都去数据库取数据，假设数据库操作比较耗时，那么压力全都在数据库服务器上了。&lt;/p&gt;
&lt;p&gt;这个时候所有的请求都去更新数据，明显是不合适的，应该是使用分布式锁，让一个线程去请求&lt;code&gt;mysql&lt;/code&gt;一次即可。但是为了避免死锁的情况，如果超时，得及时额外释放锁，要不可能请求&lt;code&gt;mysql&lt;/code&gt;都失败了，其他线程又拿不到锁，那么数据就会一直为&lt;code&gt;null&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;可以使用以下的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;SETNX lock.foo &amp;lt;current Unix time + lock timeout + 1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于这个场景下的&lt;code&gt;setnx&lt;/code&gt;先讲到这里，后面再讲讲分布式锁相关的知识。&lt;/p&gt;
">并发中分布式锁setnx解析</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/she-ji-ling-qu-li-pin-de-jia-gou-yi-ji-bing-fa-wen-ti-jie-jue/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;p&gt;现在 有一个场景，领取礼品，每个用户有次数限制，用户通过前端点击，调用了应用A的接口，里面调用了服务B，服务B里面去调用了服务C，注意服务C是其他部门的服务。服务C负责真正的发放礼品。（假设这个服务C我们是不可修改的，A,B是自己团队负责的，并且可能出现高并发的情况）&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226212257.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们应该如何做这个次数限制呢？&lt;/p&gt;
&lt;p&gt;假设每次领取礼品的活动有一个&lt;code&gt;activityId&lt;/code&gt;，一个用户一个活动可以领取一件礼品，礼品有&lt;code&gt;giftId&lt;/code&gt;，不可以多领，每个用户对应一个&lt;code&gt;uid&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;查询是否可以领取&#34;&gt;查询是否可以领取&lt;/h2&gt;
&lt;p&gt;首先对于前端而言，进入系统，首先需要获取用户是否已经领取过，而这个是否已经领取过，具体的实现我们应该写在B服务中，用户通过应用A，请求到服务B，返回用户是否已经领取的结果。&lt;/p&gt;
&lt;p&gt;查询是否领取的流程大致如下：&lt;br&gt;
用户进入页面，前端如果有缓存的话，可以为他展示之前缓存的结果，假设没有缓存，就会请求A应用，A应用会去请求B服务，B服务首先需要判断礼品或者活动是否存在。&lt;/p&gt;
&lt;p&gt;去redis里面取活动或者礼品是否存在，如果redis没有查询到，那么就查询数据库，返回结果，如果数据库都没有，说明这个前端请求很可能是捏造的，直接返回结果“活动或者礼品不存在”，如果此时查询出来，确实存在，那么就需要去查询是否领取过，同样是查询redis，不存在的情况下，查询数据库，再返回结果。，如果领取过，则会有领取结果，前端将按键置灰，否者用户按键可以领取。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226214848.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上面的redis肯定是需要我们维护的，这里不展开讲。比如增加活动的时候，除了改数据库，同时需要&lt;code&gt;redis&lt;/code&gt;里面写一份数据，key可以是&lt;code&gt;activityId_giftId&lt;/code&gt;，记录已经有的活动，用户成功领取的时候，同样是不仅增加数据库记录，也需要往&lt;code&gt;redis&lt;/code&gt;写一份数据，key可以是&lt;code&gt;activityId_giftId_uid&lt;/code&gt;，记录该用户已经领取过该活动的奖品。&lt;/p&gt;
&lt;p&gt;但是上面的系统，有一个问题，就是活动/礼品不存在的时候，请求会每一次都直接打到数据库，如果是恶意攻击，数据库就挂了。这里当然可以考虑使用布隆过滤器，对请求参数中的活动/礼品做过滤，同时也可以考虑其他的防爬虫手段，比如滑动窗口统计请求数，根据&lt;code&gt;ip&lt;/code&gt;，客户端&lt;code&gt;id&lt;/code&gt;,&lt;code&gt;uid&lt;/code&gt;等等。&lt;/p&gt;
&lt;p&gt;当然，如果可以保证&lt;code&gt;redis&lt;/code&gt;数据可靠，稳定，可以不请求数据库，&lt;code&gt;redis&lt;/code&gt;不包含则说明不存在，直接返回。但是这种做法需要在增加活动/修改商品的时候，同时将&lt;code&gt;redis&lt;/code&gt;一同修改同步。如果redis挂掉的情况，或者请求&lt;code&gt;redis&lt;/code&gt;异常，再去查询数据库。如果能接受修改数据库活动信息不立马更新，也可以考虑更新完数据库，用消息队列发一条消息，收到再做&lt;code&gt;redis&lt;/code&gt;更新。当然，这个不是一种好的做法，解耦合之后，增加了复杂度。前面说的做法，只要&lt;code&gt;redis&lt;/code&gt;挂了，数据库理论上也支撑不了多久（极端情况）。&lt;/p&gt;
&lt;p&gt;（当然，上面不是完美的方案，是个大致流程）&lt;/p&gt;
&lt;h2 id=&#34;领取礼品接口怎么处理&#34;&gt;领取礼品接口怎么处理？&lt;/h2&gt;
&lt;p&gt;首先流程上与上面的查询是否领取过有些类似，，但是在查询是否领取过这一步之后，有所不同。如果已经领取过，则直接返回，但是如果没有领取过，需要调用C服务进行领取，如果调用C接口失败，或者返回领取失败，B服务需要做的事，就是记录日志或者告警，同时返回失败。&lt;br&gt;
如果C服务返回领取成功，那么需要记录领取记录到数据库，并且更新缓存，表示已经领取过该礼品，这也是上面为什么一般能直接查询缓存就可以知道用户是否领取过的原因。&lt;br&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226230957.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个设计中，其实C服务才是真正实现方法奖品的服务，我们做的A和B相当于调用别人的服务，做了中间服务，这种情况更需要记录日志，控制爬虫，恶意攻击等等，同时做好异常处理。&lt;/p&gt;
&lt;p&gt;上面的设计，如果我们来写段伪代码，来看看有什么问题？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String receiveGitf(int activityId,int giftId,String uid){
        // isExist判断活动是否存在，内部包括redis和数据库请求，省略
        if(isActivityExist(activityId,giftId)){
            // 活动和礼品有效,判断是否领取过
            if(!userReceived(uid,activityId,giftId)){
                // 没有领取过，调用C系统
                try {
                    boolean receivedResult = Http.getMethod(C_Client.class, &amp;quot;distributeGift&amp;quot;);
                    if(receivedResult){
                        // 领取成功更新mysql
                        updateMysql(uid,activityId,giftId);
                        // 领取成功更新redis
                        updateRedis(uid,activityId,giftId);
                    }else{
                        return &amp;quot;已经领过/领取失败&amp;quot;;
                    }
                }catch (Exception e){
                    // 记录日志
                    logHelper.log(e);
                    return &amp;quot;调用领券系统失败，请重试&amp;quot;;
                }
            }
        }
        return &amp;quot;领取失败，活动不存在&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来好像没有什么问题，领取成功写&lt;code&gt;redis&lt;/code&gt;，之后读到就不会再领取。但是高并发环境下呢？高并发环境下，很有可能出现领取多次的情况，因为网络请求不是瞬时可以返回的，如果有很多个同一个uid的请求，同时进来，C服务的处理或者延迟比较高。所有的请求都会堵塞在请求C服务这里。（网络请求需要时间！！！）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226233336.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这时候还没有任何请求成功，所以&lt;code&gt;redis&lt;/code&gt;根本不会更新，数据库也不会，所以的请求都会打到C服务，假设别人的服务是不可靠的，可以多次领取，那么所有的请求都会成功，并且会有多条成功的记录！！！&lt;/p&gt;
&lt;p&gt;那如何来改进这个问题呢？&lt;br&gt;
我们可以使用&lt;code&gt;setnx&lt;/code&gt;来处理，先请求&lt;code&gt;setnx&lt;/code&gt;，更新缓存，然后只有一个可以成功进来，如果真的成功，再写数据库，如果异常或者请求失败，将缓存删除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public String receiveGitf(int activityId,int giftId,String uid){
        // isExist判断活动是否存在，内部包括redis和数据库请求，省略
        if(isActivityExist(activityId,giftId)){
            // 活动和礼品有效,判断是否领取过
            if(!userReceived(uid,activityId,giftId)){
                // 没有领取过，调用C系统
                try {
                    // setnx
                    if(redis.setnx(&amp;quot;uid_activityId_giftId&amp;quot;)){
                        boolean receivedResult = Http.getMethod(C_Client.class, &amp;quot;distributeGift&amp;quot;);
                        if(receivedResult){
                            // 领取成功更新mysql
                            updateMysql(uid,activityId,giftId);
                        }else{
                            // 领取成功更新redis
                            deleteRedis(uid,activityId,giftId);
                            return &amp;quot;已经领过/领取失败&amp;quot;;
                        }
                    }else{
                        return &amp;quot;已经领过/领取失败&amp;quot;;
                    }
                }catch (Exception e){
                    // 记录日志
                    logHelper.log(e);
                    return &amp;quot;调用领券系统失败，请重试&amp;quot;;
                }
            }
        }
        return &amp;quot;领取失败，活动不存在&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;Redis&lt;/code&gt; 里，所谓 &lt;code&gt;SETNX&lt;/code&gt;，是&lt;code&gt;「SET if Not eXists」&lt;/code&gt;缩写，也就是只有&lt;code&gt;key&lt;/code&gt;不存在的时候才设置，可以利用它来实现锁的效果。这样只有一个请求可以进入。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;redis&amp;gt; EXISTS id                # id 不存在

redis&amp;gt; SETNX id &amp;quot;1&amp;quot;    # id 设置成功1

redis&amp;gt; SETNX id &amp;quot;2&amp;quot;   # 尝试覆盖 id ，返回失败 0

redis&amp;gt; GET job                   # 没有被覆盖&amp;quot;2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个场景下的问题已经得到初步的解决，那这个&lt;code&gt;setnx&lt;/code&gt;有没有坑呢？下次我们聊一下...&lt;/p&gt;
">设计领取礼品的架构以及并发问题解决</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/she-ji-yi-ge-duan-lian-jie-sheng-cheng-xi-tong/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;
&lt;p&gt;相信大家在生活中，特别是最近的双十一活动期间，会收到很多短信，而那些短信都有两个特征，第一个是几乎都是垃圾短信，这个特点此处可以忽略不计，第二个特点是&lt;strong&gt;链接很短&lt;/strong&gt;，比如下面这个：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211110222405.png&#34; style=&#34;zoom:40%;&#34; /&gt;
&lt;p&gt;我们知道，短信有些是有字数限制的，直接放一个带满各种参数的链接，不合适，另外一点是，不想暴露参数。好处无非以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;太长的链接容易被限制长度&lt;/li&gt;
&lt;li&gt;短链接看着简洁，长链接看着容易懵&lt;/li&gt;
&lt;li&gt;安全，不想暴露参数&lt;/li&gt;
&lt;li&gt;可以统一链接转换，当然也可以实现统计点击次数等操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那背后的原理是什么呢？怎么实现的？让你实现这样的系统，你会怎么设计呢？【来自于某鹅场面试官】&lt;/p&gt;
&lt;h2 id=&#34;短链接的原理&#34;&gt;短链接的原理&lt;/h2&gt;
&lt;h3 id=&#34;短链接展示的逻辑&#34;&gt;短链接展示的逻辑&lt;/h3&gt;
&lt;p&gt;这里最重要的知识点是重定向，先复习一下&lt;code&gt;http&lt;/code&gt;的状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;分类&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器收到请求，需要请求者继续执行操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;成功，操作被成功接收并处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;重定向，需要进一步的操作以完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端错误，请求包含语法错误或无法完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;5**&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;服务器错误，服务器在处理请求的过程中发生了错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;那么以 3 开头的状态码都是关于重定向的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;300：多种选择，可以在多个位置存在&lt;/li&gt;
&lt;li&gt;301：永久重定向，浏览器会缓存，自动重定向到新的地址&lt;/li&gt;
&lt;li&gt;302：临时重定向，客户端还是会继续使用旧的URL&lt;/li&gt;
&lt;li&gt;303：查看其他的地址，类似于301&lt;/li&gt;
&lt;li&gt;304：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。&lt;/li&gt;
&lt;li&gt;305：需要使用代理才能访问到资源&lt;/li&gt;
&lt;li&gt;306：废弃的状态码&lt;/li&gt;
&lt;li&gt;307：临时重定向，使用Get请求重定向&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个跳转的流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.用户访问短链接，请求到达服务器&lt;/li&gt;
&lt;li&gt;2.服务器将短链接装换成为长链接，然后给浏览器返回重定向的状态码301/302
&lt;ul&gt;
&lt;li&gt;301永久重定向会导致浏览器缓存重定向地址，短链接系统统计访问次数会不正确&lt;/li&gt;
&lt;li&gt;302临时重定向可以解决次数不准的问题，但是每次都会到短链接系统转换，服务器压力会变大。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3.浏览器拿到重定向的状态码，以及真正需要访问的地址，重定向到真正的长链接上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从下图可以看出，确实链接被&lt;code&gt;302&lt;/code&gt;重定向到新的地址上去，返回的头里面有一个字段&lt;code&gt;Location&lt;/code&gt;就是所要重定向的地址：&lt;/p&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211110235518.png&#34; style=&#34;zoom:70%;&#34; /&gt;
&lt;h3 id=&#34;短链接怎么设计的&#34;&gt;短链接怎么设计的？&lt;/h3&gt;
&lt;h4 id=&#34;全局发号器&#34;&gt;全局发号器&lt;/h4&gt;
&lt;p&gt;肯定我们第一点想到的是压缩，像文件压缩那样，压缩之后再解压还原到原来的链接，重定向到原来的链接，但是很不幸的是，这个是行不通的，你有见过什么压缩方式能把这么长的数字直接压缩到这么短么？事实上不可能。就像是&lt;code&gt;Huffman&lt;/code&gt;树，也只能对那种重复字符较多的字符串压缩时效率较高，像链接这种，可能带很多参数，而且各种不规则的情况都有，直接压缩算法不现实。&lt;/p&gt;
&lt;p&gt;那&lt;code&gt;https://dx.10086.cn/tzHLFw&lt;/code&gt;与&lt;code&gt;https://gd.10086.cn/gmccapp/webpage/payPhonemoney/index.html?channel=&lt;/code&gt;之间的装换是怎么样的呢？前面路径不变，变化的是后面，也就是&lt;code&gt;tzHLFw&lt;/code&gt;与&lt;code&gt;gmccapp/webpage/payPhonemoney/index.html?channel=&lt;/code&gt;之间的转换。&lt;/p&gt;
&lt;p&gt;实际也很简单，就是数据库里面的一条数据，一个&lt;code&gt;id&lt;/code&gt;对应长链接（相当于全局的发号器，全局唯一的ID）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;id&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;url&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;https://gd.10086.cn/gmccapp/webpage/payPhonemoney/index.html?channel=&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里用到的，也就是我们之前说过的分布式全局唯一ID，如果我们直接用&lt;code&gt;id&lt;/code&gt;作为参数，貌似也可以：&lt;code&gt;https://dx.10086.cn/1&lt;/code&gt;，访问这个链接时，去数据库查询获得真正的url，再重定向。&lt;/p&gt;
&lt;p&gt;单机的唯一&lt;code&gt;ID&lt;/code&gt;很简单，用原子类&lt;code&gt;AtomicLong&lt;/code&gt;就可以，但是分布式的就不行了，简单点可以用 &lt;code&gt;redis&lt;/code&gt;，或者数据库自增，或者可以考虑&lt;code&gt;Zookeeper&lt;/code&gt;之类的。&lt;/p&gt;
&lt;h4 id=&#34;id-转换策略&#34;&gt;id 转换策略&lt;/h4&gt;
&lt;p&gt;但是直接用递增的数字，有两个坏处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字很大的时候，还是很长&lt;/li&gt;
&lt;li&gt;递增的数字，不安全，规律性太强了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;明显我们平时看到的链接也不是数字的，一般都是大小写字母加上数字。为了缩短链接的长度，我们必须把&lt;code&gt;id&lt;/code&gt;转换掉，比如我们的短链接由&lt;code&gt;a-z&lt;/code&gt;,&lt;code&gt;A-Z&lt;/code&gt;,&lt;code&gt;0-9&lt;/code&gt;组成，相当于&lt;code&gt;62&lt;/code&gt;进制的数字，将&lt;code&gt;id&lt;/code&gt;转换成为&lt;code&gt;62&lt;/code&gt;进制的数字:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ShortUrl {

    private static final String BASE = &amp;quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot;;

    public static String toBase62(long num) {
        StringBuilder result = new StringBuilder();
        do {
            int i = (int) (num % 62);
            result.append(BASE.charAt(i));
            num /= 62;
        } while (num &amp;gt; 0);

        return result.reverse().toString();
    }

    public static long toBase10(String str) {
        long result = 0;
        for (int i = 0; i &amp;lt; str.length(); i++) {
            result = result * 62 + BASE.indexOf(str.charAt(i));
        }
        return result;
    }

    public static void main(String[] args) {
        // tzHLFw
        System.out.println(toBase10(&amp;quot;tzHLFw&amp;quot;));
        System.out.println(toBase62(27095455234L));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt;转 &lt;code&gt;62&lt;/code&gt;位的&lt;code&gt;key&lt;/code&gt; 或者&lt;code&gt;key&lt;/code&gt;装换成为&lt;code&gt;id&lt;/code&gt;都已经实现了，不过计算还是比较耗时的，不如加个字段存起来，于是数据库变成了：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;id&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;key&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;url&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;27095455234&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;tzHLFw&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;https://gd.10086.cn/gmccapp/webpage/payPhonemoney/index.html?channel=&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;但是这样还是很容易被猜出这个&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;key&lt;/code&gt;的对应关系，要是被遍历访问，那还是很不安全的，如果担心，可以随机将短链接的字符顺序打乱，或者在适当的位置加上一些随机生成的字符，比如第&lt;code&gt;1，4，5 &lt;/code&gt;位是随机字符，其他位置不变，只要我们计算的时候，将它对应的关系存到数据库，我们就可以通过连接的&lt;code&gt;key&lt;/code&gt;找到对应的&lt;code&gt;url&lt;/code&gt;。（值得注意的是，&lt;code&gt;key&lt;/code&gt;必须是全局唯一的，如果冲突，必须重新生成）&lt;/p&gt;
&lt;p&gt;一般短链接都有过期时间，那么我们也必须在数据库里面加上对应的字段，访问的时候，先判断是否过期，过期则不给予重定向。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211115003828.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;性能考虑&#34;&gt;性能考虑&lt;/h4&gt;
&lt;p&gt;如果有很多短链接暴露出去了，数据库里面数据很多，这个时候可以考虑使用缓存优化，生成的时候顺便把缓存写入，然后读取的时候，走缓存即可，因为一般短链接和长链接的关系不会修改，即使修改，也是很低频的事情。&lt;/p&gt;
&lt;p&gt;如果系统的&lt;code&gt;id&lt;/code&gt;用完了怎么办？这种概率很小，如果真的发生，可以重用旧的已经失效的&lt;code&gt;id&lt;/code&gt;号。&lt;/p&gt;
&lt;p&gt;如果被人疯狂请求一些不存在的短链接怎么办？其实这就是缓存穿透，缓存穿透是指，&lt;strong&gt;缓存和数据库都没有的数据&lt;/strong&gt;，被大量请求，比如订单号不可能为&lt;code&gt;-1&lt;/code&gt;，但是用户请求了大量订单号为&lt;code&gt;-1&lt;/code&gt;的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。如果被恶意用户利用，疯狂请求不存在的数据，就会导致数据库压力过大，甚至垮掉。&lt;/p&gt;
&lt;p&gt;针对这种情况，一般可以用布隆过滤器过滤掉不存在的数据请求，但是我们这里&lt;code&gt;id&lt;/code&gt;本来就是递增且有序的，其实我们范围大致都是已知的，更加容易判断，超出的肯定不存在，或者请求到的时候，缓存里面放一个空对象也是没有问题的。&lt;/p&gt;
">设计一个短链接生成系统</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/man-you-shu-ju-jie-gou-shi-jie/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;blockquote&gt;
&lt;p&gt;程序 = 数据结构 + 算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是的，上面这句话是非常经典的，程序由数据结构以及算法组成，当然数据结构和算法也是相辅相成的，不能完全独立来看待，但是本文会相对重点聊聊那些常用的数据结构。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;数据结构是什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先得知道数据是什么？&lt;strong&gt;数据是对客观事务的符号表示&lt;/strong&gt;，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号总称。那为何加上**“结构”**两字？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据元素是数据的基本单位&lt;/strong&gt;，而任何问题中，数据元素都不是独立存在的，它们之间总是存在着某种关系，这种&lt;strong&gt;数据元素之间的关系我们称之为结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，我们有了以下定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据结构是&lt;a href=&#34;https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338&#34;&gt;计算机&lt;/a&gt;存储、组织&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE&#34;&gt;数据&lt;/a&gt;的方式。数据结构是指相互之间存在一种或多种特定关系的&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313&#34;&gt;数据元素&lt;/a&gt;的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%88%E7%8E%87/868847&#34;&gt;效率&lt;/a&gt;。数据结构往往同高效的检索&lt;a href=&#34;https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025&#34;&gt;算法&lt;/a&gt;和&lt;a href=&#34;https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853&#34;&gt;索引&lt;/a&gt;技术有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单讲，数据结构就是组织，管理以及存储数据的方式。虽然理论上所有的数据都可以混杂，或者糅合，或者饥不择食，随便存储，但是计算机是追求高效的，如果我们能了解数据结构，找到较为适合当前问题场景的数据结构，将数据之间的关系表现在存储上，计算的时候可以较为高效的利用适配的算法，那么程序的运行效率肯定也会有所提高。&lt;/p&gt;
&lt;p&gt;常用的4种数据结构有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集合：只有同属于一个集合的关系，没有其他关系&lt;/li&gt;
&lt;li&gt;线性结构：结构中的数据元素之间存在一个对一个的关系&lt;/li&gt;
&lt;li&gt;树形结构：结构中的数据元素之间存在一个对多个的关系&lt;/li&gt;
&lt;li&gt;图状结构或者网状结构：图状结构或者网状结构&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104211919.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;何为逻辑结构和存储结构？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据元素之间的逻辑关系，称之为逻辑结构&lt;/strong&gt;，也就是我们定义了对操作对象的一种数学描述。但是我们还必须知道在计算机中如何表示它。&lt;strong&gt;数据结构在计算机中的表示（又称为映像），称之为数据的物理结构，又称存储结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据元素之前的关系在计算机中有两种不同的表示方法：&lt;strong&gt;顺序映像和非顺序映像&lt;/strong&gt;，并且由此得到两种不同的存储结构：&lt;strong&gt;顺序存储结构&lt;/strong&gt;和&lt;strong&gt;链式存储结构&lt;/strong&gt;，比如顺序存储结构，我们要表示复数&lt;code&gt;z1 =3.0 - 2.3i &lt;/code&gt;,可以直接借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104213735.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而链式结构，则是以&lt;strong&gt;指针&lt;/strong&gt;表示数据元素之间的逻辑关系，同样是&lt;code&gt;z1 =3.0 - 2.3i &lt;/code&gt;，先找到下一个是 &lt;code&gt;100&lt;/code&gt;，是一个地址，根据地址找到真实的数据&lt;code&gt;-2.3i&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104214041.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;位bit&#34;&gt;位（bit）&lt;/h2&gt;
&lt;p&gt;在计算机中表示信息的最小的单位是二进制数中的一位，叫做&lt;strong&gt;位&lt;/strong&gt;。也就是我们常见的类似&lt;code&gt;01010101010&lt;/code&gt;这种数据，计算机的底层就是各种晶体管，电路板，所以不管是什么数据，即使是图片，声音，在最底层也是&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;,如果有八条电路，那么每条电路有自己的闭合状态，有&lt;code&gt;8&lt;/code&gt;个&lt;code&gt;2&lt;/code&gt;相乘，2&lt;sup&gt;8&lt;/sup&gt;，也就是&lt;code&gt;256&lt;/code&gt;种不同的信号。&lt;/p&gt;
&lt;p&gt;但是一般我们需要表示负数，也就是最高的一位表示符号位，&lt;code&gt;0&lt;/code&gt;表示正数，&lt;code&gt;1&lt;/code&gt;表示负数，也就是8位的最大值是&lt;code&gt;01111111&lt;/code&gt;，也就是&lt;code&gt;127&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;值得我们注意的是，计算机的世界里，多了原码，反码，补码的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原码：用第一位表示符号，其余位表示值&lt;/li&gt;
&lt;li&gt;反码：正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反。&lt;/li&gt;
&lt;li&gt;补码：正数的补码是其本身，负数的补码是在其反码的基础上 + 1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么有了原码还要反码和补码&#34;&gt;为什么有了原码还要反码和补码？&lt;/h3&gt;
&lt;p&gt;我们知道加减法是高频的运算，人可以很直观的看出加号减号，马上就可以算出来，但是计算机如果区分不同的符号，那么加减就会比较复杂，比如正数+正数，正数-正数，正数-负数，负数+负数...等等。于是，有人就想用同一个运算器（加号运算器），解决所有的加减法计算，可以减少很多复杂的电路，以及各种符号转换的开销，计算也更加高效。&lt;/p&gt;
&lt;p&gt;我们可以看到，下面负数参加运算的结果也是符合补码的规则的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;        00100011		35
 +      11011101	   -35
-------------------------
        00000000       0
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;        00100011		35
 + 	    11011011	   -37
-------------------------
        11111110       -2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，如果计算结果超出了位数所能表示的范围，那就是溢出，就说明需要更多的位数才能正确表示。&lt;/p&gt;
&lt;p&gt;一般能用位运算的，都尽量使用位运算，因为它比较高效, 常见的位运算：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt;：按位取反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;：按为与运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt;：按位或运算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt;：按位异或&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;: 带符号左移，比如&lt;code&gt;35(00100011)&lt;/code&gt;,左移一位为 &lt;code&gt;70(01000110)&lt;/code&gt;,&lt;code&gt;-35(11011101)&lt;/code&gt;左移一位为&lt;code&gt;-70(10111010)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;：带符号右移，比如&lt;code&gt;35(00100011)&lt;/code&gt;,右移一位为 &lt;code&gt;17(00010001)&lt;/code&gt;,&lt;code&gt;-35(11011101)&lt;/code&gt;左移一位为&lt;code&gt;-18(11101110)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;:无符号左移，比如&lt;code&gt;35(00100011)&lt;/code&gt;,左移一位为&lt;code&gt;70(01000110)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;:无符号右移，比如&lt;code&gt;-35(11011101)&lt;/code&gt;,右移一位为&lt;code&gt;110(01101110)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x ^= y; y ^= x; x ^= y;&lt;/code&gt;:交换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s &amp;amp;= ~(1 &amp;lt;&amp;lt; k)&lt;/code&gt;:第&lt;code&gt;k&lt;/code&gt;位置0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要说哪里使用位运算比较经典，那么要数&lt;strong&gt;布隆过滤器&lt;/strong&gt;，需要了解详情的可以参考：http://aphysia.cn/archives/cachebloomfilter&lt;/p&gt;
&lt;h3 id=&#34;布隆过滤器是什么呢&#34;&gt;布隆过滤器是什么呢？&lt;/h3&gt;
&lt;p&gt;布隆过滤器（&lt;code&gt;Bloom Filter&lt;/code&gt;）是由布隆（&lt;code&gt;Burton Howard Bloom&lt;/code&gt;）在1970年提出的，它实际上是由一个很长的二进制向量和一系列随机hash映射函数组成（说白了，就是用二进制数组存储数据的特征）。可以使用它来判断一个元素是否存在于集合中，它的优点在于查询效率高，空间小，缺点是存在一定的误差，以及我们想要剔除元素的时候，可能会相互影响。&lt;/p&gt;
&lt;p&gt;也就是当一个元素被加入集合的时候，通过多个&lt;code&gt;hash&lt;/code&gt;函数，将元素映射到位数组中的&lt;code&gt;k&lt;/code&gt;个点，置为&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点是多个hash函数，可以将数据hash到不同的位上，也只有这些位全部为1的时候，我们才能判断该数据已经存在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设有三个&lt;code&gt;hash&lt;/code&gt;函数，那么不同的元素，都会使用三个&lt;code&gt;hash&lt;/code&gt;函数，&lt;code&gt;hash&lt;/code&gt;到三个位置上。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233116.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;假设后面又来了一个张三，那么在&lt;code&gt;hash&lt;/code&gt;的时候，同样会&lt;code&gt;hash&lt;/code&gt;到以下位置，所有位都是&lt;code&gt;1&lt;/code&gt;，我们就可以说张三已经存在在里面了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233607.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那么有没有可能出现误判的情况呢？这是有可能的，比如现在只有张三，李四，王五，蔡八，&lt;code&gt;hash&lt;/code&gt;映射值如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233752.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;后面来了陈六，但是不凑巧的是，它&lt;code&gt;hash&lt;/code&gt;的三个函数hash出来的位，刚刚好就是被别的元素&lt;code&gt;hash&lt;/code&gt;之后，改成&lt;code&gt;1&lt;/code&gt;了，判断它已经存在了，但是实际上，陈六之前是不存在的。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233900.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;上面的情况，就是误判，布隆过滤器都会不可避免的出现误判。但是它有一个好处是，&lt;strong&gt;布隆过滤器，判断存在的元素，可能不存在，但是判断不存在的元素，一定不存在。&lt;/strong&gt;，因为判断不存在说明至少有一位&lt;code&gt;hash&lt;/code&gt;出来是对不上的。&lt;/p&gt;
&lt;p&gt;也是由于会出现多个元素可能&lt;code&gt;hash&lt;/code&gt;到一起，但有一个数据被踢出了集合，我们想把它映射的位，置为&lt;code&gt;0&lt;/code&gt;，相当于删除该数据。这个时候，就会影响到其他的元素，可能会把别的元素映射的位，置为了&lt;code&gt;0&lt;/code&gt;。这也就是为什么布隆过滤器不能删除的原因。&lt;/p&gt;
&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;
&lt;p&gt;线性表示最常用而且最为简单的一种数据结构，一个线性表示 n 个数据元素的有限序列，有以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存在唯一的第一个的数据元素&lt;/li&gt;
&lt;li&gt;存在唯一被称为最后一个的数据元素&lt;/li&gt;
&lt;li&gt;除了第一个以外，集合中每一个元素均有一个前驱&lt;/li&gt;
&lt;li&gt;除了最后一个元素之外，集合中的每一个数据元素都有一个后继元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线性表包括下面几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组：查询 / 更新快，查找/删除慢&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;队列&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数组是线性表的一种，线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素&lt;/strong&gt;：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104223923.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;中表示为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;int[] nums = new int[100];
int[] nums = {1,2,3,4,5};

Object[] Objects = new Object[100];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;C++&lt;/code&gt; 中表示为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;int nums[100];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组是一种线性的结构，一般在底层是连续的空间，存储相同类型的数据，由于连续紧凑结构以及天然索引支持，查询数据效率高:&lt;/p&gt;
&lt;p&gt;假设我们知道数组&lt;code&gt;a&lt;/code&gt;的第 1 个值是 地址是  &lt;code&gt;296&lt;/code&gt;,里面的数据类型占 &lt;code&gt;2&lt;/code&gt; 个 单位，那么我们如果期望得到第 5 个： &lt;code&gt;296+（5-1）*2 = 304&lt;/code&gt;,&lt;code&gt;O(1)&lt;/code&gt;的时间复杂度就可以获取到。&lt;/p&gt;
&lt;p&gt;更新的本质也是查找，先查找到该元素，就可以动手更新了：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104224829.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但是如果期望插入数据的话，需要移动后面的数据，比如下面的数组，插入元素&lt;code&gt;6&lt;/code&gt;，最差的是移动所有的元素，时间复杂度为&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220104225524289.png&#34; alt=&#34;image-20220104225524289&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而删除元素则需要把后面的数据移动到前面，最差的时间复杂度同样为&lt;code&gt;O(n)&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104230125.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Java代码实现数组的增删改查：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;package datastruction;

import java.util.Arrays;

public class MyArray {
    private int[] data;

    private int elementCount;

    private int length;

    public MyArray(int max) {
        length = max;
        data = new int[max];
        elementCount = 0;
    }

    public void add(int value) {
        if (elementCount == length) {
            length = 2 * length;
            data = Arrays.copyOf(data, length);
        }
        data[elementCount] = value;
        elementCount++;
    }

    public int find(int searchKey) {
        int i;
        for (i = 0; i &amp;lt; elementCount; i++) {
            if (data[i] == searchKey)
                break;
        }
        if (i == elementCount) {
            return -1;
        }
        return i;
    }

    public boolean delete(int value) {
        int i = find(value);
        if (i == -1) {
            return false;
        }
        for (int j = i; j &amp;lt; elementCount - 1; j++) {
            data[j] = data[j + 1];
        }
        elementCount--;
        return true;
    }

    public boolean update(int oldValue, int newValue) {
        int i = find(oldValue);
        if (i == -1) {
            return false;
        }
        data[i] = newValue;
        return true;
    }
}

// 测试类
public class Test {
    public static void main(String[] args) {
        MyArray myArray = new MyArray(2);
        myArray.add(1);
        myArray.add(2);
        myArray.add(3);
        myArray.delete(2);
        System.out.println(myArray);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;链表&#34;&gt;链表&lt;/h2&gt;
&lt;p&gt;上面的例子中，我们可以看到数组是需要连续的空间，这里面如果空间大小只有 &lt;code&gt;2&lt;/code&gt;，放到第 &lt;code&gt;3&lt;/code&gt; 个元素的时候，就不得不扩容，不仅如此，还得拷贝元素。一些删除，插入操作会引起较多的数据移动的操作。&lt;/p&gt;
&lt;p&gt;链表，也就是链式数据结构，由于它不要求逻辑上相邻的数据元素在物理位置上也相邻，所以它没有顺序存储结构所具有的缺点，但是同时也失去了通过索引下标直接查找元素的优点。&lt;/p&gt;
&lt;p&gt;重点：&lt;strong&gt;链表在计算机的存储中不是连续的，而是前一个节点存储了后一个节点的指针（地址），通过地址找到后一个节点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是单链表的结构：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220105084859.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一般我们会手动在单链表的前面设置一个前置结点，也可以称为头结点，但是这并非绝对：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220105085243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一般链表结构分为以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单向链表&lt;/strong&gt;：链表中的每一个结点，都有且只有一个指针指向下一个结点，并且最后一个节点指向空。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;双向链表&lt;/strong&gt;：每个节点都有两个指针（为方便，我们称之为&lt;strong&gt;前指针&lt;/strong&gt;，&lt;strong&gt;后指针&lt;/strong&gt;），分别指向上一个节点和下一个节点，第一个节点的前指针指向&lt;code&gt;NULL&lt;/code&gt;，最后一个节点的后指针指向&lt;code&gt;NULL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;循环链表&lt;/strong&gt;：每一个节点的指针指向下一个节点，并且最后一个节点的指针指向第一个节点（虽然是循环链表，但是必要的时候还需要标识头结点或者尾节点，避免死循环）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复杂链表&lt;/strong&gt;：每一个链表有一个后指针，指向下一个节点，同时有一个随机指针，指向任意一个结点。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220105235909.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;链表操作的时间复杂度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询：&lt;code&gt;O(n)&lt;/code&gt;,需要遍历链表&lt;/li&gt;
&lt;li&gt;插入：&lt;code&gt;O(1)&lt;/code&gt;，修改前后指针即可&lt;/li&gt;
&lt;li&gt;删除：&lt;code&gt;O(1)&lt;/code&gt;，同样是修改前后指针即可&lt;/li&gt;
&lt;li&gt;修改：不需要查询则为&lt;code&gt;O(1)&lt;/code&gt;，需要查询则为&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链表的结构代码怎么表示呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面只表示单链表结构，&lt;code&gt;C++&lt;/code&gt;表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;// 结点
typedef struct LNode{
  // 数据
  ElemType data;
  // 下一个节点的指针
  struct LNode *next;
}*Link,*Position;

// 链表
typedef struct{
  // 头结点，尾节点
  Link head,tail;
  // 长度
  int len;
}LinkList;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 代码表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;    public class ListNode {
        int val;
        ListNode next = null;

        ListNode(int val) {
            this.val = val;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自己实现简单链表，实现增删改查功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;class ListNode&amp;lt;T&amp;gt; {
    T val;
    ListNode next = null;

    ListNode(T val) {
        this.val = val;
    }
}

public class MyList&amp;lt;T&amp;gt; {
    private ListNode&amp;lt;T&amp;gt; head;
    private ListNode&amp;lt;T&amp;gt; tail;
    private int size;

    public MyList() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    public void add(T element) {
        add(size, element);
    }

    public void add(int index, T element) {
        if (index &amp;lt; 0 || index &amp;gt; size) {
            throw new IndexOutOfBoundsException(&amp;quot;超出链表长度范围&amp;quot;);
        }
        ListNode current = new ListNode(element);
        if (index == 0) {
            if (head == null) {
                head = current;
                tail = current;
            } else {
                current.next = head;
                head = current;
            }
        } else if (index == size) {
            tail.next = current;
            tail = current;
        } else {
            ListNode preNode = get(index - 1);
            current.next = preNode.next;
            preNode.next = current;
        }
        size++;
    }

    public ListNode get(int index) {
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            throw new IndexOutOfBoundsException(&amp;quot;超出链表长度&amp;quot;);
        }
        ListNode temp = head;
        for (int i = 0; i &amp;lt; index; i++) {
            temp = temp.next;
        }
        return temp;
    }

    public ListNode delete(int index) {
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            throw new IndexOutOfBoundsException(&amp;quot;超出链表节点范围&amp;quot;);
        }
        ListNode node = null;
        if (index == 0) {
            node = head;
            head = head.next;
        } else if (index == size - 1) {
            ListNode preNode = get(index - 1);
            node = tail;
            preNode.next = null;
            tail = preNode;
        } else {
            ListNode pre = get(index - 1);
            pre.next = pre.next.next;
            node = pre.next;
        }
        size--;
        return node;
    }

    public void update(int index, T element) {
        if (index &amp;lt; 0 || index &amp;gt;= size) {
            throw new IndexOutOfBoundsException(&amp;quot;超出链表节点范围&amp;quot;);
        }
        ListNode node = get(index);
        node.val = element;
    }

    public void display() {
        ListNode temp = head;
        while (temp != null) {
            System.out.print(temp.val + &amp;quot; -&amp;gt; &amp;quot;);
            temp = temp.next;
        }
        System.out.println(&amp;quot;&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        MyList myList = new MyList();
        myList.add(1);
        myList.add(2);
        // 1-&amp;gt;2
        myList.display();

        // 1
        System.out.println(myList.get(0).val);

        myList.update(1,3);
        // 1-&amp;gt;3
        myList.display();

        myList.add(4);
        // 1-&amp;gt;3-&amp;gt;4
        myList.display();

        myList.delete(1);
        // 1-&amp;gt;4
        myList.display();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;1 -&amp;gt; 2 -&amp;gt; 
1
1 -&amp;gt; 3 -&amp;gt; 
1 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 
1 -&amp;gt; 4 -&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单向链表的查找更新比较简单，我们看看插入新节点的具体过程（这里只展示中间位置的插入，头尾插入比较简单）：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108113826.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108113852.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;那如何删除一个中间的节点呢？下面是具体的过程：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220108114627633.png&#34; alt=&#34;image-20220108114627633&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;或许你会好奇，&lt;code&gt;a5&lt;/code&gt;节点只是指针没有了，那它去哪里了？&lt;/p&gt;
&lt;p&gt;如果是&lt;code&gt;Java&lt;/code&gt;程序，垃圾回收器会收集这种没有被引用的节点，帮我们回收掉了这部分内存，但是为了加快垃圾回收的速度，一般不需要的节点我们需要置空，比如 &lt;code&gt;node = null&lt;/code&gt;, 如果在&lt;code&gt;C++&lt;/code&gt; 程序中，那么就需要手动回收了，否则容易造成内存泄漏等问题。&lt;/p&gt;
&lt;p&gt;复杂链表的操作暂时讲到这里，后面我会单独把链表这一块的数据结构以及常用算法单独分享一下，本文章主要讲数据结构全貌。&lt;/p&gt;
&lt;h3 id=&#34;跳表&#34;&gt;跳表&lt;/h3&gt;
&lt;p&gt;上面我们可以观察到，链表如果搜索，是很麻烦的，如果这个节点在最后，需要遍历所有的节点，才能找到，查找效率实在太低，有没有什么好的办法呢？&lt;/p&gt;
&lt;p&gt;办法总比问题多，但是想要绝对的”&lt;code&gt;多快好省&lt;/code&gt;“是不存在的，有舍有得，计算机的世界里，充满哲学的味道。既然搜索效率有问题，那么我们不如给链表排个序。排序后的链表，还是只能知道头尾节点，知道中间的范围，但是要找到中间的节点，还是得走遍历的老路。如果我们把中间节点存储起来呢？存起来，确实我们就知道数据在前一半，还是在后一半。比如找&lt;code&gt;7&lt;/code&gt;，肯定就从中间节点开始找。如果查找&lt;code&gt;4&lt;/code&gt;,就得从头开始找，最差到中间节点，就停止查找。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108120726.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但是如此，还是没有彻底解决问题，因为链表很长的情况，只能通过前后两部分查找。不如回到原则：&lt;code&gt;空间和时间，我们选择时间，那就要舍弃一部分空间&lt;/code&gt;,我们每个节点再加一个指针，现在有 2 层指针（注意：&lt;strong&gt;节点只有一份，都是同一个节点，只是为了好看，弄了两份，实际上是同一个节点，有两个指针，比如 1 ，既指向2，也指向5&lt;/strong&gt;）：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108121514.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;两层指针，问题依然存在，那就不断加层，比如每两个节点，就加一层：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108122738.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这就是跳表了，跳表的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要的原理是用空间换时间，可以实现近乎二分查找的效率，实际上消耗的空间，假设每两个加一层， &lt;code&gt;1 + 2 + 4 + ... + n = 2n-1&lt;/code&gt;,多出了差不多一倍的空间。你看它像不像书的目录，一级目录，二级，三级 ...&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108123726.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果我们不断往跳表中插入数据，可能出现某一段节点会特别多的情况，这个时候就需要动态更新索引，除了插入数据，还要插入到上一层的链表中，保证查询效率。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redis&lt;/code&gt; 中使用了跳表来实现&lt;code&gt;zset&lt;/code&gt;,&lt;code&gt;redis&lt;/code&gt;中使用一个随机算法来计算层级，计算出每个节点到底多少层索引，虽然不能绝对保证比较平衡，但是基本保证了效率，实现起来比那些平衡树，红黑树的算法简单一点。&lt;/p&gt;
&lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;p&gt;栈是一种数据结构，在&lt;code&gt;Java&lt;/code&gt;里面体现是&lt;code&gt;Stack&lt;/code&gt;类。它的本质是&lt;strong&gt;先进后出&lt;/strong&gt;，就像是一个桶，只能不断的放在上面，取出来的时候，也只能不断的取出最上面的数据。要想取出底层的数据，只有等到上面的数据都取出来，才能做到。当然，如果有这种需求，我们一般会使用双向队列。&lt;/p&gt;
&lt;p&gt;以下是栈的特性演示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211228083751.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;栈的底层用什么实现的？其实可以用链表，也可以用数组，但是&lt;code&gt;JDK&lt;/code&gt;底层的栈，是用数组实现的，封装之后，通过&lt;code&gt;API&lt;/code&gt;操作的永远都只能是最后一个元素，栈经常用来实现递归的功能。如果想要了解&lt;code&gt;Java&lt;/code&gt;里面的栈或者其他集合实现分析，可以看看这系列文章：http://aphysia.cn/categories/collection&lt;/p&gt;
&lt;p&gt;元素加入称之为入栈（压栈），取出元素，称之为出栈，栈顶元素则是最后一次放进去的元素。&lt;/p&gt;
&lt;p&gt;使用数组实现简单的栈(注意仅供参考测试，实际会有线程安全等问题)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;import java.util.Arrays;

public class MyStack&amp;lt;T&amp;gt; {
    private T[] data;
    private int length = 2;
    private int maxIndex;

    public MyStack() {
        data = (T[]) new Object[length];
        maxIndex = -1;
    }

    public void push(T element) {
        if (isFull()) {
            length = 2 * length;
            data = Arrays.copyOf(data, length);
        }
        data[maxIndex + 1] = element;
        maxIndex++;
    }

    public T pop() {
        if (isEmpty()) {
            throw new IndexOutOfBoundsException(&amp;quot;栈内没有数据&amp;quot;);
        } else {
            T[] newdata = (T[]) new Object[data.length - 1];
            for (int i = 0; i &amp;lt; data.length - 1; i++) {
                newdata[i] = data[i];
            }
            T element = data[maxIndex];
            maxIndex--;
            data = newdata;
            return element;
        }
    }

    private boolean isFull() {
        return data.length - 1 == maxIndex;
    }

    public boolean isEmpty() {
        return maxIndex == -1;
    }

    public void display() {
        for (int i = 0; i &amp;lt; data.length; i++) {
            System.out.print(data[i]+&amp;quot; &amp;quot;);
        }
        System.out.println(&amp;quot;&amp;quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class MyStackTest {
    public static void main(String[] args) {
        MyStack&amp;lt;Integer&amp;gt; myStack = new MyStack&amp;lt;&amp;gt;();
        myStack.push(1);
        myStack.push(2);
        myStack.push(3);
        myStack.push(4);
        myStack.display();

        System.out.println(myStack.pop());

        myStack.display();

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果如下，符合预期：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;1 2 3 4 
4
1 2 3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;栈的特点就是先进先出，但是如果需要随机取出前面的数据，效率会比较低，需要倒腾出来，但是如果底层使用数组，理论上是可以通过索引下标取出的，&lt;code&gt;Java&lt;/code&gt;里面正是这样实现。&lt;/p&gt;
&lt;h2 id=&#34;队列&#34;&gt;队列&lt;/h2&gt;
&lt;p&gt;既然前面有先进后出的数据结构，那我们必定也有先进先出的数据结构，疫情的时候，排队估计大家都有测过核酸，那排队老长了，排在前面先测，排在后面后测，这道理大家都懂。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108162737.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;队列是一种特殊的&lt;a href=&#34;https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081&#34;&gt;线性表&lt;/a&gt;，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;队列的特点是先进先出，以下是例子：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108164851.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一般只要说到先进先出（&lt;code&gt;FIFO&lt;/code&gt;）,全称&lt;code&gt;First In First Out&lt;/code&gt;,就会想到队列，但是如果你想拥有队列即可以从队头取出元素，又可以从队尾取出元素，那就需要用到特殊的队列（双向队列），双向队列一般使用双向链表实现会简单一点。&lt;/p&gt;
&lt;p&gt;下面我们用&lt;code&gt;Java&lt;/code&gt;实现简单的单向队列：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;class Node&amp;lt;T&amp;gt; {
    public T data;
    public Node next;

    public Node(T data) {
        this.data = data;
    }
}

public class MyQueue&amp;lt;T&amp;gt; {
    private Node&amp;lt;T&amp;gt;  head;
    private Node&amp;lt;T&amp;gt;  rear;
    private int size;

    public MyQueue() {
        size = 0;
    }

    public void pushBack(T element) {
        Node newNode = new Node(element);
        if (isEmpty()) {
            head = newNode;
        } else {
            rear.next = newNode;
        }
        rear = newNode;
        size++;
    }

    public boolean isEmpty() {
        return head == null;
    }

    public T popFront() {
        if (isEmpty()) {
            throw new NullPointerException(&amp;quot;队列没有数据&amp;quot;);
        } else {
            Node&amp;lt;T&amp;gt; node = head;
            head = head.next;
            size--;
            return node.data;
        }
    }

    public void dispaly() {
        Node temp = head;
        while (temp != null) {
            System.out.print(temp.data +&amp;quot; -&amp;gt; &amp;quot;);
            temp = temp.next;
        }
        System.out.println(&amp;quot;&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class MyStackTest {
    public static void main(String[] args) {
        MyStack&amp;lt;Integer&amp;gt; myStack = new MyStack&amp;lt;&amp;gt;();
        myStack.push(1);
        myStack.push(2);
        myStack.push(3);
        myStack.push(4);
        myStack.display();

        System.out.println(myStack.pop());

        myStack.display();

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 
1
2 -&amp;gt; 3 -&amp;gt; 
2
3 -&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用的队列类型如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单向队列：也就是我们说的普通队列，先进先出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双向队列：可以从不同方向进出队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优先队列：内部是自动排序的，按照一定顺序出队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞队列：从队列取出元素的时候，队列没有元素则会阻塞，同样如果队列满了，往队列里面放入元素也会被阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环队列：可以理解为一个循环链表，但是一般需要标识出头尾节点，防止死循环，尾节点的&lt;code&gt;next&lt;/code&gt;指向头结点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;队列一般可以用来保存需要顺序的数据，或者保存任务，在树的层次遍历中可以使用队列解决，一般广度优先搜索都可以使用队列解决。&lt;/p&gt;
&lt;h2 id=&#34;哈希表&#34;&gt;哈希表&lt;/h2&gt;
&lt;p&gt;前面的数据结构，查找的时候，一般都是使用&lt;code&gt;=&lt;/code&gt;或者&lt;code&gt;!=&lt;/code&gt;,在折半查找或者其他范围查询的时候，可能会使用&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;,理想的时候，我们肯定希望不经过任何的比较，直接能定位到某个位置（存储位置），这种在数组中，可以通过索引取得元素。那么，如果我们将需要存储的数据和数组的索引对应起来，并且是一对一的关系，那不就可以很快定位到元素的位置了么？&lt;/p&gt;
&lt;p&gt;只要通过函数&lt;code&gt;f(k)&lt;/code&gt;就能找到&lt;code&gt;k&lt;/code&gt;对应的位置，这个函数&lt;code&gt;f(k)&lt;/code&gt;就是&lt;code&gt;hash&lt;/code&gt;函数。它表示的是一种映射关系，但是对不同的值，可能会映射到同一个值（同一个&lt;code&gt;hash&lt;/code&gt;地址），也就是&lt;code&gt;f(k1) = f(k2)&lt;/code&gt;，这种现象我们称之为&lt;code&gt;冲突&lt;/code&gt;或者&lt;code&gt;碰撞&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;表定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108174206.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一般常用的&lt;code&gt;hash&lt;/code&gt; 函数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接定址法：取出关键字或者关键字的某个线性函数的值为哈希函数，比如&lt;code&gt;H(key) = key&lt;/code&gt;或者&lt;code&gt;H(key) = a * key + b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数字分析法：对于可能出现的数值全部了解，取关键字的若干数位组成哈希地址&lt;/li&gt;
&lt;li&gt;平方取中法：取关键字平方后的中间几位作为哈希地址&lt;/li&gt;
&lt;li&gt;折叠法：将关键字分割成为位数相同的几部分（最后一部分的位数可以不同），取这几部分的叠加和（舍去进位），作为哈希地址。&lt;/li&gt;
&lt;li&gt;除留余数法：取关键字被某个不大于散列表表长&lt;code&gt;m&lt;/code&gt;的数&lt;code&gt;p&lt;/code&gt;除后所得的余数为散列地址。即h&lt;code&gt;ash(k)=k mod p&lt;/code&gt;，&lt;code&gt;p&amp;lt; =m&lt;/code&gt;。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对&lt;code&gt;p&lt;/code&gt;的选择很重要，一般取素数或&lt;code&gt;m&lt;/code&gt;，若&lt;code&gt;p&lt;/code&gt;选择不好，容易产生冲突。&lt;/li&gt;
&lt;li&gt;随机数法：取关键字的随机函数值作为它的哈希地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是这些方法，都无法避免哈希冲突，只能有意识的减少。那处理&lt;code&gt;hash&lt;/code&gt;冲突，一般有哪些方法呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开放地址法：&lt;code&gt;hash&lt;/code&gt;计算后，如果该位置已经有数据，那么对该地址&lt;code&gt;+1&lt;/code&gt;，也就是往后找，知道找到一个空的位置。&lt;/li&gt;
&lt;li&gt;重新&lt;code&gt;hash&lt;/code&gt;法：发生哈希冲突后，可以使用另外的&lt;code&gt;hash&lt;/code&gt;函数重新极计算，找到空的&lt;code&gt;hash&lt;/code&gt;地址,如果有，还可以再叠加&lt;code&gt;hash&lt;/code&gt;函数。&lt;/li&gt;
&lt;li&gt;链地址法：所有&lt;code&gt;hash&lt;/code&gt;值一样的,链接成为一个链表，挂在数组后面。&lt;/li&gt;
&lt;li&gt;建立公共溢出区：不常见，意思是所有元素，如果和表中的元素&lt;code&gt;hash&lt;/code&gt;冲突，都弄到另外一个表，也叫溢出表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;里面，用的就是链地址法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108175944.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但是如果&lt;code&gt;hash&lt;/code&gt;冲突比较严重，链表会比较长，查询的时候，需要遍历后面的链表，因此&lt;code&gt;JDK&lt;/code&gt;优化了一版，链表的长度超过阈值的时候，会变成&lt;strong&gt;红黑树&lt;/strong&gt;，红黑树有一定的规则去平衡子树，避免退化成为链表，影响查询效率。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108180256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;但是你肯定会想到，如果数组太小了，放了比较多数据了，怎么办？再放冲突的概率会越来越高，其实这个时候会触发一个扩容机制，将数组扩容成为 &lt;code&gt;2&lt;/code&gt;倍大小，重新&lt;code&gt;hash&lt;/code&gt;以前的数据，哈希到不同的数组中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;表的优点是查找速度快，但是如果不断触发重新 &lt;code&gt;hash&lt;/code&gt;, 响应速度也会变慢。同时，如果希望范围查询，&lt;code&gt;hash&lt;/code&gt;表不是好的选择。&lt;/p&gt;
&lt;h2 id=&#34;树&#34;&gt;树&lt;/h2&gt;
&lt;p&gt;数组和链表都是线性结构，而这里要介绍的树，则是非线性结构。现实中树是金字塔结构，数据结构中的树，最上面称之为根节点。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108212239.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;我们该如何定义树结构呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;是一种&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450&#34;&gt;数据结构&lt;/a&gt;，它是由&lt;em&gt;n(n≥1&lt;/em&gt;)个有限节点组成一个具有层次关系的&lt;a href=&#34;https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117&#34;&gt;集合&lt;/a&gt;。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：&lt;/p&gt;
&lt;p&gt;每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树。(百度百科)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是树的基本术语（来自于清华大学数据结构&lt;code&gt;C&lt;/code&gt;语言版）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的度：一个节点含有的子树的个数称为该节点的度&lt;/li&gt;
&lt;li&gt;树的度：一棵树中，最大的节点度称为树的度；&lt;/li&gt;
&lt;li&gt;叶节点或终端节点：度为零的节点；&lt;/li&gt;
&lt;li&gt;非终端节点或分支节点：度不为零的节点；&lt;/li&gt;
&lt;li&gt;父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；&lt;/li&gt;
&lt;li&gt;孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；&lt;/li&gt;
&lt;li&gt;兄弟节点：具有相同父节点的节点互称为兄弟节点；&lt;/li&gt;
&lt;li&gt;节点的层次：从根开始定义起，根为第&lt;code&gt;1&lt;/code&gt;层，根的子节点为第&lt;code&gt;2&lt;/code&gt;层，以此类推；&lt;/li&gt;
&lt;li&gt;深度：对于任意节点&lt;code&gt;n&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;的深度为从根到n的唯一路径长，根的深度为&lt;code&gt;0&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;高度：对于任意节点&lt;code&gt;n&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;的高度为从&lt;code&gt;n&lt;/code&gt;到一片树叶的最长路径长，所有树叶的高度为&lt;code&gt;0&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;堂兄弟节点：父节点在同一层的节点互为堂兄弟；&lt;/li&gt;
&lt;li&gt;节点的祖先：从根到该节点所经分支上的所有节点；&lt;/li&gt;
&lt;li&gt;子孙：以某节点为根的子树中任一节点都称为该节点的子孙。&lt;/li&gt;
&lt;li&gt;有序树：将树种的节点的各个子树看成从左至右是有次序的（不能互换），则应该称该树为有序树，否则为无序树&lt;/li&gt;
&lt;li&gt;第一个孩子：在有序树中最左边的子树的根称为第一个孩子&lt;/li&gt;
&lt;li&gt;最后一个孩子：在有序树种最右边的子树的根称为最后一个孩子&lt;/li&gt;
&lt;li&gt;森林：由&lt;code&gt;m&lt;/code&gt;（&lt;code&gt;m&amp;gt;=0&lt;/code&gt;）棵互不相交的树的集合称为森林；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;树，其实我们最常用的是二叉树：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108213545.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;二叉树的特点是每个节点最多只有两个子树，并且子树有左右之分，左右子节点的次序不能任意颠倒。&lt;/p&gt;
&lt;p&gt;二叉树在&lt;code&gt;Java&lt;/code&gt;中表示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class TreeLinkNode {
    int val;
    TreeLinkNode left = null;
    TreeLinkNode right = null;
    TreeLinkNode next = null;

    TreeLinkNode(int val) {
        this.val = val;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;满二叉树：一棵深度为 k 且有 2&lt;sup&gt;k&lt;/sup&gt;-1 个节点的二叉树，称之为满二叉树&lt;/p&gt;
&lt;p&gt;完全二叉树：深度为 k 的，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中编号从 1 到 n 的节点一一对应是，称之为完全二叉树。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108214243.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一般二叉树的遍历有几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历：遍历顺序 根节点 --&amp;gt; 左子节点 --&amp;gt; 右子节点&lt;/li&gt;
&lt;li&gt;中序遍历：遍历顺序  左子节点  --&amp;gt; 根节点 --&amp;gt; 右子节点&lt;/li&gt;
&lt;li&gt;后序遍历：遍历顺序 左子节点 --&amp;gt; 右子节点 --&amp;gt; 根节点&lt;/li&gt;
&lt;li&gt;广度 / 层次遍历： 从上往下，一层一层的遍历&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是一棵混乱的二叉树，那查找或者搜索的效率也会比较低，和一条混乱的链表没有什么区别，何必弄更加复杂的结构呢？&lt;/p&gt;
&lt;p&gt;其实，二叉树是可以用在排序或者搜索中的，因为二叉树有严格的左右子树之分，我们可以定义根节点，左子节点，右子节点的大小之分。于是有了二叉搜索树：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/7077965&#34;&gt;二叉查找树&lt;/a&gt;（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的&lt;a href=&#34;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879&#34;&gt;二叉树&lt;/a&gt;： 若它的左子树不空，则左子树上所有结点的值均小于它的&lt;a href=&#34;https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93%E7%82%B9/9795570&#34;&gt;根结点&lt;/a&gt;的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为&lt;a href=&#34;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079&#34;&gt;二叉排序树&lt;/a&gt;。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二叉查找树样例如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108220407.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;比如上面的树，如果我们需要查找到 &lt;code&gt;4&lt;/code&gt;， 从 &lt;code&gt;5&lt;/code&gt;开始，&lt;code&gt;4&lt;/code&gt;比&lt;code&gt;5&lt;/code&gt;小，往左子树走，查找到&lt;code&gt;3&lt;/code&gt;，&lt;code&gt;4&lt;/code&gt;比&lt;code&gt;3&lt;/code&gt;大，往右子树走，找到了&lt;code&gt;4&lt;/code&gt;，也就是一个 &lt;code&gt;7&lt;/code&gt;个节点的树，我们只查找了&lt;code&gt;3&lt;/code&gt;次，也就是层数，假设&lt;code&gt;n&lt;/code&gt;个节点，那就是&lt;code&gt;log(n+1)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;树维护好了，查询效率固然高，但是如果树没维护好，容易退化成为链表，查询效率也会下降，比如：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108222210.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;一棵对查询友好的二叉树，应该是一个平衡或者接近平衡的二叉树，何为平衡二叉树：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;平衡二叉搜索树的任何结点的左子树和右子树高度最多相差1。平衡二叉树也称为 AVL 树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了保证插入或者删除数据等之后，二叉树还是平衡二叉树，那么就需要调整节点，这个也称为平衡过程，里面会涉及各种旋转调整，这里暂时不展开。&lt;/p&gt;
&lt;p&gt;但是如果涉及大量的更新，删除操作，平衡树种的各种调整需要牺牲不小的性能，为了解决这个问题，有大佬提出了红黑树.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在&lt;a href=&#34;https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA&#34;&gt;计算机&lt;/a&gt;科学中用到的一种&lt;a href=&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450&#34;&gt;数据结构&lt;/a&gt;，典型的用途是实现&lt;a href=&#34;https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/3317025&#34;&gt;关联数组&lt;/a&gt;。 [1]&lt;/p&gt;
&lt;p&gt;红黑树是在1972年由[Rudolf Bayer](https://baike.baidu.com/item/Rudolf Bayer/3014716)发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。 [2]&lt;/p&gt;
&lt;p&gt;红黑树是一种特化的AVL树（&lt;a href=&#34;https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057&#34;&gt;平衡二叉树&lt;/a&gt;），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;红黑树有以下的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;性质1. 结点是红色或黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性质2. 根结点是黑色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性质3. 所有叶子都是黑色。（叶子是NIL结点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正是这些特性，让红黑树在调整的时候，不像普通的平衡二叉树调整那般困难，频繁。也就是加上了条条框框，让它符合一定的标准，减少平衡过程的混乱以及频次。&lt;/p&gt;
&lt;p&gt;前面说的哈希表，&lt;code&gt;Java&lt;/code&gt; 中的实现，正是应用了红黑树，在&lt;code&gt;hash&lt;/code&gt;冲突较多的时候，会将链表转换成为红黑树。&lt;/p&gt;
&lt;p&gt;上面说的都是二叉树，但是我们不得不扯一下多叉树，为什么呢？虽然二叉树中的各种搜索树，红黑树已经很优秀了，但是在与磁盘交互的时候，大多数是数据存储中，我们不得不考虑 IO 的因素，因为磁盘IO比内存慢太多了。如果索引树的层高有几千上万，那么磁盘读取的时候，需要次数太多了。B树更加适合磁盘存储。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;970年，R.Bayer和E.mccreight提出了一种适用于外查找的&lt;a href=&#34;https://baike.baidu.com/item/%E6%A0%91/2699484&#34;&gt;树&lt;/a&gt;，它是一种平衡的多叉树，称为B树（或B-树、B_树）。&lt;/p&gt;
&lt;p&gt;一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：&lt;/p&gt;
&lt;p&gt;1、根结点至少有两个子女；&lt;/p&gt;
&lt;p&gt;2、每个非根节点所包含的关键字个数 j 满足：m/2 - 1 &amp;lt;= j &amp;lt;= m - 1；&lt;/p&gt;
&lt;p&gt;3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故&lt;strong&gt;内部子树&lt;/strong&gt;个数 k 满足：m/2 &amp;lt;= k &amp;lt;= m ；&lt;/p&gt;
&lt;p&gt;4、所有的叶子结点都位于同一层。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个节点放多一点数据，查找的时候，内存中的操作比磁盘快很多，&lt;code&gt;b&lt;/code&gt;树可以减少磁盘IO的次数。B 树：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108231118.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而每个节点的&lt;code&gt;data&lt;/code&gt;可能很大,这样会导致每一页查出来的数据很少，IO查询次数自然就增加了，那我们不如只在叶子节点中存储数据：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108231837.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:&lt;/p&gt;
&lt;p&gt;(1)每个结点至多有m个子女；&lt;/p&gt;
&lt;p&gt;(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；&lt;/p&gt;
&lt;p&gt;(3)有k个子女的结点必有k个关键字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一般b+树的叶子节点，会用链表连接起来，方便遍历以及范围遍历。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是&lt;code&gt;b+&lt;/code&gt;树，&lt;code&gt;b+&lt;/code&gt;树相对于&lt;code&gt;B树&lt;/code&gt;多了以下优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;b+&lt;/code&gt;树的中间节点不保存数据，每次IO查询能查到更多的索引，,是一个矮胖的树。&lt;/li&gt;
&lt;li&gt;对于范围查找来说，&lt;code&gt;b+&lt;/code&gt;树只需遍历叶子节点链表即可，&lt;code&gt;b&lt;/code&gt;树却需要从根节点都叶子节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了上面的树，其实还有一种叫&lt;code&gt;Huffman&lt;/code&gt;树：给定N个权值作为N个&lt;a href=&#34;https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/3620239&#34;&gt;叶子结点&lt;/a&gt;，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。&lt;/p&gt;
&lt;p&gt;一般用来作为压缩使用，因为数据中，每个字符出现的频率不一样，出现频率越高的字符，我们用越短的编码保存，就可以达到压缩的目的。那这个编码怎么来的呢？&lt;/p&gt;
&lt;p&gt;假设字符是&lt;code&gt;hello&lt;/code&gt;,那么编码可能是（只是编码的大致雏形，高频率出现的字符，编码更短），编码就是从根节点到当前字符的路径的&lt;code&gt;01&lt;/code&gt;串：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109140839.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过不同权值的编码，哈夫曼树到了有效的压缩。&lt;/p&gt;
&lt;h2 id=&#34;堆&#34;&gt;堆&lt;/h2&gt;
&lt;p&gt;堆，其实也是二叉树中的一种，堆必须是完全二叉树，完全二叉树是：除了最后一层，其他层的节点个数都是满的，最后一层的节点都集中在左部连续位置。&lt;/p&gt;
&lt;p&gt;而堆还有一个要求：堆中每一个节点的值都必须大于等于（或小于等于）其左右子节点的值。&lt;/p&gt;
&lt;p&gt;堆主要分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大顶堆：每个节点都大于等于其子树节点（堆顶是最大值）&lt;/li&gt;
&lt;li&gt;小顶堆：每个节点都小于等于其子树节点（堆顶是最小值）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般情况下，我们都是用数组来表示堆，比如下面的小顶堆：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220109000632499.png&#34; alt=&#34;image-20220109000632499&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;数组中父子节点以及左右节点的关系如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i &lt;/code&gt;结点的父结点 &lt;code&gt;parent = floor((i-1)/2) &lt;/code&gt;(向下取整)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i &lt;/code&gt;结点的左子结点 &lt;code&gt;2 * i +1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i &lt;/code&gt;结点的右子结点 &lt;code&gt;2 * i + 2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然是存储数据的，那么一定会涉及到插入删除等操作，堆里面插入删除，会涉及到堆的调整，调整之后才能重新满足它的定义，这个调整的过程，叫做&lt;strong&gt;堆化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;用小顶堆举例，调整主要是为了保证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;还是完全二叉树&lt;/li&gt;
&lt;li&gt;堆中每一个节点都还小于等于其左右子节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于小顶堆，调整的时候是：小元素往上浮，大元素往下沉，就是不断交换的过程。&lt;/p&gt;
&lt;p&gt;堆一般可以用来求解&lt;code&gt;TOP K&lt;/code&gt; 问题，或者前面我们说的优先队列等。&lt;/p&gt;
&lt;h2 id=&#34;图&#34;&gt;图&lt;/h2&gt;
&lt;p&gt;终于来到了图的讲解，图其实就是二维平面，之前写过扫雷，扫雷的整个方块区域，其实也可以说是图相关的。图是非线性的数据结构，主要是由边和顶点组成。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220109002114134.png&#34; alt=&#34;image-20220109002114134&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;同时图又分为有向图与无向图，上面的是无向图，因为边没有指明方向，只是表示两者关联关系，而有向图则是这样：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109002313.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果每个顶点是一个地方，每条边是路径，那么这就是一张地图网络，因此图也经常被用于求解最短距离。先来看看图相关的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶点：图最基本的单元，那些节点&lt;/li&gt;
&lt;li&gt;边：顶点之间的关联关系&lt;/li&gt;
&lt;li&gt;相邻顶点：由边直接关联的顶点&lt;/li&gt;
&lt;li&gt;度：一个顶点直接连接的相邻顶点的数量&lt;/li&gt;
&lt;li&gt;权重：边的权值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般表示图有以下几种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;邻接矩阵，使用二维数组表示，为1 表示联通，0表示不连通，当然如果表示路径长度的时候，可以用大于&lt;code&gt;0&lt;/code&gt;的数表示路径长度，用&lt;code&gt;-1&lt;/code&gt;表示不连通。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面的图片中，0和 1，2连通，我们可以看到第 0行的第1，2列是1 ，表示连通。还有一点：顶点自身我们是标识了0，表示不连通，但是有些情况可以视为连通状态。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109115154.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;邻接表&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;邻接表，存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的&lt;a href=&#34;https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782&#34;&gt;存储结构&lt;/a&gt;。如这个表头结点所对应的顶点存在&lt;a href=&#34;https://baike.baidu.com/item/%E7%9B%B8%E9%82%BB/1534684&#34;&gt;相邻&lt;/a&gt;顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。&lt;/p&gt;
&lt;p&gt;对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109123929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;图里面遍历一般分为广度优先遍历和深度优先遍历，广度优先遍历是指优先遍历与当前顶点&lt;strong&gt;直接相关&lt;/strong&gt;的顶点，一般借助队列实现。而深度优先遍历则是往一个方向一直走到不能再走，有点不撞南墙不回头的意思，一般使用递归实现。&lt;/p&gt;
&lt;p&gt;图，除了用了计算最小路径以外，还有一个概念：最小生成树。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有一种说法，图是平面上的点，我们把其中一个点拎起来，能将其他顶点带起来的边，取最小权值，多余的边去掉，就是最小生成树。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109141906.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;当然，最小生成树并不一定是唯一的，可能存在多种结果。&lt;/p&gt;
&lt;h2 id=&#34;秦怀观点&#34;&gt;秦怀@观点&lt;/h2&gt;
&lt;p&gt;了解这些基本的数据结构，在写代码或者数据建模的时候，能够选择更加合适的，这是最大的用处。计算机是为人服务的，代码也是，数据结构的全部类型我们是无法一下子一一掌握的，但是基本的东西是变动不会很大，除非新一代革命性变化。&lt;/p&gt;
&lt;p&gt;程序是由数据结构和算法组成，数据结构就像是基石，借助《数据结构C语言》版本中的一句话结尾：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了编写出一个”好“的程序，必须分析待处理的对象的特性以及各处理对象之间存在的关系，这就是”数据结构“这门学科和发展的背景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E7%82%B9%E8%B5%9EV2.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">漫游数据结构世界</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/xue-hua-suan-fa-de-xi-zhi-mo-jie-jiang-jie/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;p&gt;前面文章在谈论分布式唯一ID生成的时候，有提到雪花算法，这一次，我们详细点讲解，只讲它。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;snowflake算法&#34;&gt;SnowFlake算法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;据国家大气研究中心的查尔斯·奈特称，一般的雪花大约由10^19个水分子组成。在雪花形成过程中，会形成不同的结构分支，所以说大自然中不存在两片完全一样的雪花，每一片雪花都拥有自己漂亮独特的形状。雪花算法表示生成的id如雪花般独一无二。&lt;/p&gt;
&lt;p&gt;snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;核心思想：分布式，唯一。&lt;/p&gt;
&lt;h2 id=&#34;算法具体介绍&#34;&gt;算法具体介绍&lt;/h2&gt;
&lt;p&gt;雪花算法是 64 位 的二进制，一共包含了四部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1位是符号位，也就是最高位，始终是0，没有任何意义，因为要是唯一计算机二进制补码中就是负数，0才是正数。&lt;/li&gt;
&lt;li&gt;41位是时间戳，具体到毫秒，41位的二进制可以使用69年，因为时间理论上永恒递增，所以根据这个排序是可以的。&lt;/li&gt;
&lt;li&gt;10位是机器标识，可以全部用作机器ID，也可以用来标识机房ID + 机器ID，10位最多可以表示1024台机器。&lt;/li&gt;
&lt;li&gt;12位是计数序列号，也就是同一台机器上同一时间，理论上还可以同时生成不同的ID，12位的序列号能够区分出4096个ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211015001825.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;
&lt;p&gt;由于41位是时间戳，我们的时间计算是从1970年开始的，只能使用69年，为了不浪费，其实我们可以用时间的相对值，也就是以项目开始的时间为基准时间，往后可以使用69年。获取唯一ID的服务，对处理速度要求比较高，所以我们全部使用位运算以及位移操作，获取当前时间可以使用&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;时间回拨问题&#34;&gt;时间回拨问题&lt;/h3&gt;
&lt;p&gt;在获取时间的时候，可能会出现&lt;code&gt;时间回拨&lt;/code&gt;的问题，什么是时间回拨问题呢？就是服务器上的时间突然倒退到之前的时间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;人为原因，把系统环境的时间改了。&lt;/li&gt;
&lt;li&gt;有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回拨时间小的时候，不生成 ID，循环等待到时间点到达。&lt;/li&gt;
&lt;li&gt;上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么超过一定大小的回拨直接报错，拒绝服务，或者有一种方案是利用拓展位，回拨之后在拓展位上加1就可以了，这样ID依然可以保持唯一。但是这个要求我们提前预留出位数，要么从机器id中，要么从序列号中，腾出一定的位，在时间回拨的时候，这个位置 &lt;code&gt;+1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于时间回拨导致的生产重复的ID的问题，其实百度和美团都有自己的解决方案了，有兴趣可以去看看，下面不是它们官网文档的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;百度UIDGenerator：https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md
&lt;ul&gt;
&lt;li&gt;UidGenerator是Java实现的, 基于&lt;a href=&#34;https://github.com/twitter/snowflake&#34;&gt;Snowflake&lt;/a&gt;算法的唯一ID生成器。UidGenerator以组件形式工作在应用项目中, 支持自定义workerId位数和初始化策略, 从而适用于&lt;a href=&#34;https://www.docker.com/&#34;&gt;docker&lt;/a&gt;等虚拟化环境下实例自动重启、漂移等场景。 在实现上, UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;美团Leaf:https://tech.meituan.com/2019/03/07/open-source-project-leaf.html
&lt;ul&gt;
&lt;li&gt;leaf-segment 方案
&lt;ul&gt;
&lt;li&gt;优化：双buffer + 预分配&lt;/li&gt;
&lt;li&gt;容灾：Mysql DB 一主两从，异地机房，半同步方式&lt;/li&gt;
&lt;li&gt;缺点：如果用segment号段式方案：id是递增，可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;leaf-snowflake方案
&lt;ul&gt;
&lt;li&gt;使用Zookeeper持久顺序节点的特性自动对snowflake节点配置workerID
&lt;ul&gt;
&lt;li&gt;1.启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。&lt;/li&gt;
&lt;li&gt;2.如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。&lt;/li&gt;
&lt;li&gt;3.如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓存workerID，减少第三方组件的依赖&lt;/li&gt;
&lt;li&gt;由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。&lt;strong&gt;或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码展示&#34;&gt;代码展示&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SnowFlake {

    // 数据中心(机房) id
    private long datacenterId;
    // 机器ID
    private long workerId;
    // 同一时间的序列
    private long sequence;

    public SnowFlake(long workerId, long datacenterId) {
        this(workerId, datacenterId, 0);
    }

    public SnowFlake(long workerId, long datacenterId, long sequence) {
        // 合法判断
        if (workerId &amp;gt; maxWorkerId || workerId &amp;lt; 0) {
            throw new IllegalArgumentException(String.format(&amp;quot;worker Id can&#39;t be greater than %d or less than 0&amp;quot;, maxWorkerId));
        }
        if (datacenterId &amp;gt; maxDatacenterId || datacenterId &amp;lt; 0) {
            throw new IllegalArgumentException(String.format(&amp;quot;datacenter Id can&#39;t be greater than %d or less than 0&amp;quot;, maxDatacenterId));
        }
        System.out.printf(&amp;quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&amp;quot;,
                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);

        this.workerId = workerId;
        this.datacenterId = datacenterId;
        this.sequence = sequence;
    }

    // 开始时间戳（2021-10-16 22:03:32）
    private long twepoch = 1634393012000L;

    // 机房号，的ID所占的位数 5个bit 最大:11111(2进制)--&amp;gt; 31(10进制)
    private long datacenterIdBits = 5L;

    // 机器ID所占的位数 5个bit 最大:11111(2进制)--&amp;gt; 31(10进制)
    private long workerIdBits = 5L;

    // 5 bit最多只能有31个数字，就是说机器id最多只能是32以内
    private long maxWorkerId = -1L ^ (-1L &amp;lt;&amp;lt; workerIdBits);

    // 5 bit最多只能有31个数字，机房id最多只能是32以内
    private long maxDatacenterId = -1L ^ (-1L &amp;lt;&amp;lt; datacenterIdBits);

    // 同一时间的序列所占的位数 12个bit 111111111111 = 4095  最多就是同一毫秒生成4096个
    private long sequenceBits = 12L;

    // workerId的偏移量
    private long workerIdShift = sequenceBits;

    // datacenterId的偏移量
    private long datacenterIdShift = sequenceBits + workerIdBits;

    // timestampLeft的偏移量
    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;

    // 序列号掩码 4095 (0b111111111111=0xfff=4095)
    // 用于序号的与运算，保证序号最大值在0-4095之间
    private long sequenceMask = -1L ^ (-1L &amp;lt;&amp;lt; sequenceBits);

    // 最近一次时间戳
    private long lastTimestamp = -1L;


    // 获取机器ID
    public long getWorkerId() {
        return workerId;
    }


    // 获取机房ID
    public long getDatacenterId() {
        return datacenterId;
    }


    // 获取最新一次获取的时间戳
    public long getLastTimestamp() {
        return lastTimestamp;
    }


    // 获取下一个随机的ID
    public synchronized long nextId() {
        // 获取当前时间戳，单位毫秒
        long timestamp = timeGen();

        if (timestamp &amp;lt; lastTimestamp) {
            System.err.printf(&amp;quot;clock is moving backwards.  Rejecting requests until %d.&amp;quot;, lastTimestamp);
            throw new RuntimeException(String.format(&amp;quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&amp;quot;,
                    lastTimestamp - timestamp));
        }

        // 去重
        if (lastTimestamp == timestamp) {

            sequence = (sequence + 1) &amp;amp; sequenceMask;

            // sequence序列大于4095
            if (sequence == 0) {
                // 调用到下一个时间戳的方法
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            // 如果是当前时间的第一次获取，那么就置为0
            sequence = 0;
        }

        // 记录上一次的时间戳
        lastTimestamp = timestamp;

        // 偏移计算
        return ((timestamp - twepoch) &amp;lt;&amp;lt; timestampLeftShift) |
                (datacenterId &amp;lt;&amp;lt; datacenterIdShift) |
                (workerId &amp;lt;&amp;lt; workerIdShift) |
                sequence;
    }

    private long tilNextMillis(long lastTimestamp) {
        // 获取最新时间戳
        long timestamp = timeGen();
        // 如果发现最新的时间戳小于或者等于序列号已经超4095的那个时间戳
        while (timestamp &amp;lt;= lastTimestamp) {
            // 不符合则继续
            timestamp = timeGen();
        }
        return timestamp;
    }

    private long timeGen() {
        return System.currentTimeMillis();
    }

    public static void main(String[] args) {
        SnowFlake worker = new SnowFlake(1, 1);
        long timer = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 10000; i++) {
            worker.nextId();
        }
        System.out.println(System.currentTimeMillis());
        System.out.println(System.currentTimeMillis() - timer);
    }

}


&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;
&lt;h3 id=&#34;1-第一位为什么不使用&#34;&gt;1. 第一位为什么不使用?&lt;/h3&gt;
&lt;p&gt;在计算机的表示中，第一位是符号位，0表示整数，第一位如果是1则表示负数，我们用的ID默认就是正数，所以默认就是0，那么这一位默认就没有意义。&lt;/p&gt;
&lt;h3 id=&#34;2机器位怎么用&#34;&gt;2.机器位怎么用？&lt;/h3&gt;
&lt;p&gt;机器位或者机房位，一共10 bit，如果全部表示机器，那么可以表示1024台机器，如果拆分，5 bit 表示机房，5bit表示机房里面的机器，那么可以有32个机房，每个机房可以用32台机器。&lt;/p&gt;
&lt;h3 id=&#34;3-twepoch表示什么&#34;&gt;3. twepoch表示什么？&lt;/h3&gt;
&lt;p&gt;由于时间戳只能用69年，我们的计时又是从1970年开始的，所以这个&lt;code&gt;twepoch&lt;/code&gt;表示从项目开始的时间，用生成ID的时间减去&lt;code&gt;twepoch&lt;/code&gt;作为时间戳，可以使用更久。&lt;/p&gt;
&lt;h3 id=&#34;4-1l-1l-x-表示什么&#34;&gt;4. -1L ^ (-1L &amp;lt;&amp;lt; x) 表示什么？&lt;/h3&gt;
&lt;p&gt;表示 x 位二进制可以表示多少个数值，假设x为3：&lt;/p&gt;
&lt;p&gt;在计算机中，第一位是符号位，负数的反码是除了符号位，1变0，0变1, 而补码则是反码+1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;-1L 原码：1000 0001
-1L 反码：1111 1110
-1L 补码：1111 1111
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面的结果可以知道，&lt;strong&gt;-1L其实在二进制里面其实就是全部为1&lt;/strong&gt;,那么 -1L 左移动 3位，其实得到 &lt;code&gt;1111 1000&lt;/code&gt;，也就是最后3位是0，再与&lt;code&gt;-1L&lt;/code&gt;异或计算之后，其实得到的，就是后面3位全是1。&lt;code&gt;-1L ^ (-1L &amp;lt;&amp;lt; x) &lt;/code&gt;表示的其实就是x位全是1的值，也就是x位的二进制能表示的最大数值。&lt;/p&gt;
&lt;h3 id=&#34;5时间戳比较&#34;&gt;5.时间戳比较&lt;/h3&gt;
&lt;p&gt;在获取时间戳小于上一次获取的时间戳的时候，不能生成ID，而是继续循环，直到生成可用的ID，这里没有使用拓展位防止时钟回拨。&lt;/p&gt;
&lt;h3 id=&#34;6前端直接使用发生精度丢失&#34;&gt;6.前端直接使用发生精度丢失&lt;/h3&gt;
&lt;p&gt;如果前端直接使用服务端生成的long 类型 id，会发生精度丢失的问题，因为 JS 中Number是16位的（指的是十进制的数字），而雪花算法计算出来最长的数字是19位的，这个时候需要用 String 作为中间转换，输出到前端即可。&lt;/p&gt;
&lt;h2 id=&#34;秦怀の观点&#34;&gt;秦怀の观点&lt;/h2&gt;
&lt;p&gt;雪花算法其实是依赖于时间的一致性的，如果时间回拨，就可能有问题，一般使用拓展位解决。而只能使用69年这个时间限制，其实可以根据自己的需要，把时间戳的位数设置得更多一点，比如42位可以用139年，但是很多公司首先得活下来。当然雪花算法也不是银弹，它也有缺点，在单机上递增，而多台机器只是大致递增趋势，并不是严格递增的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有最好的设计方案，只有合适和不合适的方案。&lt;/strong&gt;&lt;/p&gt;
">雪花算法的细枝末节讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/fen-bu-shi-xi-tong-wei-yi-id-zen-me-sheng-cheng/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
分布式系统全局唯一的 id 是所有系统都会遇到的场景，往往会被用在搜索，存储方面，用于作为唯一的标识或者排序，比如全局唯一的订单号，优惠券的券码等，如果出现两个相同的订单号，对于用户无疑将是一个巨大的bug。
&lt;!-- more --&gt;
&lt;h2 id=&#34;分布式唯一id介绍&#34;&gt;分布式唯一ID介绍&lt;/h2&gt;
&lt;p&gt;在单体的系统中，生成唯一的 id 没有什么挑战，因为只有一台机器一个应用，直接使用单例加上一个原子操作自增即可。而在分布式系统中，不同的应用，不同的机房，不同的机器，要想生成的 ID 都是唯一的，确实需要下点功夫。&lt;/p&gt;
&lt;p&gt;一句话总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;分布式唯一ID是为了给数据进行唯一标识。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;分布式唯一id的特征&#34;&gt;分布式唯一ID的特征&lt;/h3&gt;
&lt;p&gt;分布式唯一ID的核心是唯一性，其他的都是附加属性，一般来说，一个优秀的全局唯一ID方案有以下的特点，仅供参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局唯一：不可以重复，核心特点！&lt;/li&gt;
&lt;li&gt;大致有序或者单调递增：自增的特性有利于搜索，排序，或者范围查询等&lt;/li&gt;
&lt;li&gt;高性能：生成ID响应要快，延迟低&lt;/li&gt;
&lt;li&gt;高可用：要是只能单机，挂了，全公司依赖全局唯一ID的服务，全部都不可用了，所以生成ID的服务必须高可用&lt;/li&gt;
&lt;li&gt;方便使用：对接入者友好，能封装到开箱即用最好&lt;/li&gt;
&lt;li&gt;信息安全：有些场景，如果连续，那么很容易被猜到，攻击也是有可能的，这得取舍。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式唯一id的生成方案&#34;&gt;分布式唯一ID的生成方案&lt;/h2&gt;
&lt;h3 id=&#34;uuid直接生成&#34;&gt;UUID直接生成&lt;/h3&gt;
&lt;p&gt;写过 Java 的朋友都知道，有时候我们写日志会用到一个类 UUID，会生成一个随机的ID，去作为当前用户请求记录的唯一识别码,只要用以下的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;String uuid = UUID.randomUUID();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用法简单粗暴，UUID的全称其实是&lt;code&gt;Universally Unique IDentifier&lt;/code&gt;,或者&lt;code&gt;GUID(Globally Unique IDentifier)&lt;/code&gt;,它本质上是一个 128 位的二进制整数，通常我们会表示成为 32 个 16 进制数组成的字符串，几乎不会重复，2 的 128 次方，那是无比庞大的数字。&lt;/p&gt;
&lt;p&gt;以下是百度百科说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UUID由以下几部分的组合：&lt;/p&gt;
&lt;p&gt;（1）UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。&lt;/p&gt;
&lt;p&gt;（2）时钟序列。&lt;/p&gt;
&lt;p&gt;（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。&lt;/p&gt;
&lt;p&gt;UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。 [2]&lt;/p&gt;
&lt;p&gt;（4）在 hibernate（Java orm框架）中， 采用 IP-JVM启动时间-当前时间右移32位-当前时间-内部计数（8-8-4-8-4）来组成UUID&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要想重复，两台完全相同的虚拟机，开机时间一致，随机种子一致，同一时间生成uuid，才有极小的概率会重复，因此我们可认为，理论上会重复，实际不可能重复！！！&lt;/p&gt;
&lt;p&gt;uuid优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;性能好，效率高&lt;/li&gt;
&lt;li&gt;不用网络请求，直接本地生成&lt;/li&gt;
&lt;li&gt;不同的机器个干个的，不会重复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;uuid 这么好，难不成是银弹？当然缺点也很突出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没办法保证递增趋势，没法排序&lt;/li&gt;
&lt;li&gt;uuid太长了，存储占用空间大，特别落在数据库，对建立索引不友好&lt;/li&gt;
&lt;li&gt;没有业务属性，这东西就是一串数字，没啥意义，或者说规律&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然也有人想要改进这家伙，比如不可读性改造，用&lt;code&gt;uuid to int64&lt;/code&gt;，把它转成 long 类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;byte[] bytes = Guid.NewGuid().ToByteArray();
return BitConverter.ToInt64(bytes, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;又比如，改造无序性，比如 &lt;code&gt;NHibernate&lt;/code&gt; 的 &lt;code&gt;Comb&lt;/code&gt; 算法，把 uuid 的前 20 个字符保留下来，后面 12 个字符用 &lt;code&gt;guid&lt;/code&gt; 生成的时间,时间是大致有序的，是一种小改进。&lt;/p&gt;
&lt;p&gt;点评：&lt;strong&gt;UUID不存在数据库当索引，作为一些日志，上下文的识别，还是挺香的，但是要是这玩意用来当订单号，真是令人崩溃&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;数据库自增序列&#34;&gt;数据库自增序列&lt;/h3&gt;
&lt;h4 id=&#34;单机的数据库&#34;&gt;单机的数据库&lt;/h4&gt;
&lt;p&gt;数据库的主键本身就拥有一个自增的天然特性，只要设置ID为主键并且自增，我们就可以向数据库中插入一条记录，可以返回自增的ID，比如以下的建表语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE DATABASE `test`;
use test;
CREATE TABLE id_table (
    id bigint(20) unsigned NOT NULL auto_increment, 
    value char(10) NOT NULL default &#39;&#39;,
    PRIMARY KEY (id),
) ENGINE=MyISAM;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;插入语句：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;insert into id_table(value)  VALUES (&#39;v1&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单机，简单，速度也很快&lt;/li&gt;
&lt;li&gt;天然自增，原子性&lt;/li&gt;
&lt;li&gt;数字id排序，搜索，分页都比较有利&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点也很明显：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单机，挂了就要提桶跑路了&lt;/li&gt;
&lt;li&gt;一台机器，高并发也不可能&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;集群的数据库&#34;&gt;集群的数据库&lt;/h4&gt;
&lt;p&gt;既然单机高并发和高可用搞不定，那就加机器，搞集群模式的数据库，既然集群模式，如果有多个master，那肯定不能每台机器自己生成自己的id，这样会导致重复的id。&lt;/p&gt;
&lt;p&gt;这个时候，每台机器设置&lt;strong&gt;起始值&lt;/strong&gt;和&lt;strong&gt;步长&lt;/strong&gt;，就尤为重要。比如三台机器V1，V2，V3：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;统一步长：3
V1起始值：1
V2起始值：2
V3起始值：3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成的ID：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;V1：1, 4, 7, 10...
V2：2, 5, 8, 11...
V3：3, 6, 9, 12...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置命令行可以使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;set @@auto_increment_offset = 1;     // 起始值
set @@auto_increment_increment = 3;  // 步长
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样确实在master足够多的情况下，高性能保证了，就算有的机器宕机了，slave 也可以补充上来，基于主从复制就可以，可以大大降低对单台机器的压力。但是这样做还是有缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主从复制延迟了，master宕机了，从节点切换成为主节点之后，可能会重复发号。&lt;/li&gt;
&lt;li&gt;起始值和步长设置好之后，要是后面需要增加机器（水平拓展），要调整很麻烦，很多时候可能需要停机更新&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;批量号段式数据库&#34;&gt;批量号段式数据库&lt;/h4&gt;
&lt;p&gt;上面的访问数据库太频繁了，并发量一上来，很多小概率问题都可能发生，那为什么我们不直接一次性拿出一段id呢？直接放在内存里，以供使用，用完了再申请一段就可以了。同样也可以保留集群模式的优点，每次从数据库取出一个范围的id，比如3台机器，发号：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;每次取1000，每台步长3000
V1：1-1000,3001-4000,
V2：1001-2000,4001-5000
V3：2001-3000,5001-6000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，如果不搞多台机器，也是可以的，一次申请10000个号码，用乐观锁实现，加一个版本号，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE id_table (
  id int(10) NOT NULL,
  max_id bigint(20) NOT NULL COMMENT &#39;当前最大id&#39;,
  step int(20) NOT NULL COMMENT &#39;号段的步长&#39;,
  version int(20) NOT NULL COMMENT &#39;版本号&#39;,
  `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只有用完的时候，才会重新去数据库申请，竞争的时候乐观锁保证只能一个请求成功，其他的直接等着别人取出来放在应用内存里面，再取就可以了，取的时候其实就是一个update操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;update id_table set max_id = #{max_id+step}, version = version + 1 where version = # {version}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批量获取，减少数据库请求&lt;/li&gt;
&lt;li&gt;乐观锁，保证数据准确&lt;/li&gt;
&lt;li&gt;获取只能从数据库中获取，批量获取可以做成异步定时任务，发现少于某个阈值，自动补充&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;redis自增&#34;&gt;Redis自增&lt;/h3&gt;
&lt;p&gt;redis有一个原子命令&lt;code&gt;incr&lt;/code&gt;,原子自增，redis速度快，基于内存：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;127.0.0.1:6379&amp;gt; set id 1
OK
127.0.0.1:6379&amp;gt; incr id      
(integer) 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，redis 如果单机有问题，也可以上集群，同样可以用初始值 + 步长，可以用 &lt;code&gt;INCRBY&lt;/code&gt; 命令，搞几台机器基本能抗住高并发。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于内存，速度快&lt;/li&gt;
&lt;li&gt;天然排序，自增，有利于排序搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;步长确定之后，增加机器也比较难调整&lt;/li&gt;
&lt;li&gt;需要关注持久化，可用性等，增加系统复杂度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;redis持久化如果是RDB，一段时间打一个快照，那么可能会有数据没来得及被持久化到磁盘，就挂掉了，重启可能会出现重复的ID，同时要是主从延迟，主节点挂掉了，主从切换，也可能出现重复的ID。如果使用AOF，一条命令持久化一次，可能会拖慢速度，一秒钟持久化一次，那么就可能最多丢失一秒钟的数据，同时，数据恢复也会比较慢，这是一个取舍的过程。&lt;/p&gt;
&lt;h3 id=&#34;zookeeper生成唯一id&#34;&gt;Zookeeper生成唯一ID&lt;/h3&gt;
&lt;p&gt;zookeeper其实是可以用来生成唯一ID的，但是大家不用，因为性能不高。znode有数据版本，可以生成32或者64位的序列号，这个序列号是唯一的，但是如果竞争比较大，还需要加分布式锁，不值得，效率低。&lt;/p&gt;
&lt;h3 id=&#34;美团的leaf&#34;&gt;美团的Leaf&lt;/h3&gt;
&lt;p&gt;下面均来自美团的官方文档：https://tech.meituan.com/2019/03/07/open-source-project-leaf.html&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Leaf在设计之初就秉承着几点要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局唯一，绝对不会出现重复的ID，且ID整体趋势递增。&lt;/li&gt;
&lt;li&gt;高可用，服务完全基于分布式架构，即使MySQL宕机，也能容忍一段时间的数据库不可用。&lt;/li&gt;
&lt;li&gt;高并发低延时，在CentOS 4C8G的虚拟机上，远程调用QPS可达5W+，TP99在1ms内。&lt;/li&gt;
&lt;li&gt;接入简单，直接通过公司RPC服务或者HTTP调用即可接入。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;文档里面讲得很清晰，一共有两个版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;V1：预分发的方式提供ID，也就是前面说的号段式分发，表设计也差不多，意思就是批量的拉取id&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20211012002835752.png&#34; alt=&#34;image-20211012002835752&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这样做的缺点就是更新号段的时候，耗时比较高，还有就是如果这时候宕机或者主从复制，就不可用。&lt;/p&gt;
&lt;p&gt;优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1.先做了一个双Buffer优化，就是异步更新，意思就是搞两个号段出来，一个号段比如被消耗10%的时候，就开始分配下一个号段，有种提前分配的意思，而且异步线程更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2.上面的方案，号段可能固定，跨度可能太大或者太小，那就做成动态变化，根据流量来决定下一次的号段的大小，动态调整&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;V2：Leaf-snowflake，Leaf提供了Java版本的实现，同时对Zookeeper生成机器号做了弱依赖处理，即使Zookeeper有问题，也不会影响服务。Leaf在第一次从Zookeeper拿取workerID后，会在本机文件系统上缓存一个workerID文件。即使ZooKeeper出现问题，同时恰好机器也在重启，也能保证服务的正常运行。这样做到了对第三方组件的弱依赖，一定程度上提高了SLA。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;snowflake雪花算法&#34;&gt;snowflake(雪花算法）&lt;/h3&gt;
&lt;p&gt;snowflake 是 twitter 公司内部分布式项目采用的 ID 生成算法,开源后广受欢迎，它生成的ID是 &lt;code&gt;Long&lt;/code&gt; 类型，8个字节，一共64位，从左到右：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1位：不使用，二进制中最高位是为1都是负数，但是要生成的唯一ID都是正整数，所以这个1位固定为0。&lt;/li&gt;
&lt;li&gt;41位：记录时间戳(毫秒)，这个位数可以用 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;41&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;60&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;60&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;24&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;365&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;69&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(2^{41}-1) / (1000 * 60 * 60 * 24 * 365) = 69&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;年&lt;/li&gt;
&lt;li&gt;10位：记录工作机器的ID，可以机器ID，也可以机房ID + 机器ID&lt;/li&gt;
&lt;li&gt;12位：序列号，就是某个机房某台机器上这一毫秒内同时生成的 id 序号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么每台机器按照上面的逻辑去生成ID，就会是趋势递增的，因为时间在递增，而且不需要搞个分布式的，简单很多。&lt;/p&gt;
&lt;p&gt;可以看出 snowflake 是强依赖于时间的，因为时间理论上是不断往前的，所以这一部分的位数，也是趋势递增的。但是有一个问题，是时间回拨，也就是时间突然间倒退了，可能是故障，也可能是重启之后时间获取出问题了。那我们该如何解决时间回拨问题呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种方案：获取时间的时候判断，如果小于上一次的时间戳，那么就不要分配，继续循环获取时间，直到时间符合条件。&lt;/li&gt;
&lt;li&gt;第二种方案：上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么超过一定大小的回拨直接报错，拒绝服务，或者有一种方案是利用拓展位，回拨之后在拓展位上加1就可以了，这样ID依然可以保持唯一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Java代码实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SnowFlake {

    // 数据中心(机房) id
    private long datacenterId;
    // 机器ID
    private long workerId;
    // 同一时间的序列
    private long sequence;

    public SnowFlake(long workerId, long datacenterId) {
        this(workerId, datacenterId, 0);
    }

    public SnowFlake(long workerId, long datacenterId, long sequence) {
        // 合法判断
        if (workerId &amp;gt; maxWorkerId || workerId &amp;lt; 0) {
            throw new IllegalArgumentException(String.format(&amp;quot;worker Id can&#39;t be greater than %d or less than 0&amp;quot;, maxWorkerId));
        }
        if (datacenterId &amp;gt; maxDatacenterId || datacenterId &amp;lt; 0) {
            throw new IllegalArgumentException(String.format(&amp;quot;datacenter Id can&#39;t be greater than %d or less than 0&amp;quot;, maxDatacenterId));
        }
        System.out.printf(&amp;quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&amp;quot;,
                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);

        this.workerId = workerId;
        this.datacenterId = datacenterId;
        this.sequence = sequence;
    }

    // 开始时间戳
    private long twepoch = 1420041600000L;

    // 机房号，的ID所占的位数 5个bit 最大:11111(2进制)--&amp;gt; 31(10进制)
    private long datacenterIdBits = 5L;

    // 机器ID所占的位数 5个bit 最大:11111(2进制)--&amp;gt; 31(10进制)
    private long workerIdBits = 5L;

    // 5 bit最多只能有31个数字，就是说机器id最多只能是32以内
    private long maxWorkerId = -1L ^ (-1L &amp;lt;&amp;lt; workerIdBits);

    // 5 bit最多只能有31个数字，机房id最多只能是32以内
    private long maxDatacenterId = -1L ^ (-1L &amp;lt;&amp;lt; datacenterIdBits);

    // 同一时间的序列所占的位数 12个bit 111111111111 = 4095  最多就是同一毫秒生成4096个
    private long sequenceBits = 12L;

    // workerId的偏移量
    private long workerIdShift = sequenceBits;

    // datacenterId的偏移量
    private long datacenterIdShift = sequenceBits + workerIdBits;

    // timestampLeft的偏移量
    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;

    // 序列号掩码 4095 (0b111111111111=0xfff=4095)
    // 用于序号的与运算，保证序号最大值在0-4095之间
    private long sequenceMask = -1L ^ (-1L &amp;lt;&amp;lt; sequenceBits);

    // 最近一次时间戳
    private long lastTimestamp = -1L;


    // 获取机器ID
    public long getWorkerId() {
        return workerId;
    }


    // 获取机房ID
    public long getDatacenterId() {
        return datacenterId;
    }


    // 获取最新一次获取的时间戳
    public long getLastTimestamp() {
        return lastTimestamp;
    }


    // 获取下一个随机的ID
    public synchronized long nextId() {
        // 获取当前时间戳，单位毫秒
        long timestamp = timeGen();

        if (timestamp &amp;lt; lastTimestamp) {
            System.err.printf(&amp;quot;clock is moving backwards.  Rejecting requests until %d.&amp;quot;, lastTimestamp);
            throw new RuntimeException(String.format(&amp;quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&amp;quot;,
                    lastTimestamp - timestamp));
        }

        // 去重
        if (lastTimestamp == timestamp) {

            sequence = (sequence + 1) &amp;amp; sequenceMask;

            // sequence序列大于4095
            if (sequence == 0) {
                // 调用到下一个时间戳的方法
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            // 如果是当前时间的第一次获取，那么就置为0
            sequence = 0;
        }

        // 记录上一次的时间戳
        lastTimestamp = timestamp;

        // 偏移计算
        return ((timestamp - twepoch) &amp;lt;&amp;lt; timestampLeftShift) |
                (datacenterId &amp;lt;&amp;lt; datacenterIdShift) |
                (workerId &amp;lt;&amp;lt; workerIdShift) |
                sequence;
    }

    private long tilNextMillis(long lastTimestamp) {
        // 获取最新时间戳
        long timestamp = timeGen();
        // 如果发现最新的时间戳小于或者等于序列号已经超4095的那个时间戳
        while (timestamp &amp;lt;= lastTimestamp) {
            // 不符合则继续
            timestamp = timeGen();
        }
        return timestamp;
    }

    private long timeGen() {
        return System.currentTimeMillis();
    }

    public static void main(String[] args) {
        SnowFlake worker = new SnowFlake(1, 1);
        long timer = System.currentTimeMillis();
        for (int i = 0; i &amp;lt; 100; i++) {
            worker.nextId();
        }
        System.out.println(System.currentTimeMillis());
        System.out.println(System.currentTimeMillis() - timer);
    }

}
  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;百度-uid-generator&#34;&gt;百度 uid-generator&lt;/h3&gt;
&lt;p&gt;换汤不换药，百度开发的，基于&lt;code&gt;Snowflake&lt;/code&gt;算法，不同的地方是可以自己定义每部分的位数,也做了不少优化和拓展：https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UidGenerator是Java实现的, 基于&lt;a href=&#34;https://github.com/twitter/snowflake&#34;&gt;Snowflake&lt;/a&gt;算法的唯一ID生成器。UidGenerator以组件形式工作在应用项目中, 支持自定义workerId位数和初始化策略, 从而适用于&lt;a href=&#34;https://www.docker.com/&#34;&gt;docker&lt;/a&gt;等虚拟化环境下实例自动重启、漂移等场景。 在实现上, UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;秦怀の观点&#34;&gt;秦怀の观点&lt;/h2&gt;
&lt;p&gt;不管哪一种uid生成器，保证唯一性是核心，在这个核心上才能去考虑其他的性能，或者高可用等问题，总体的方案分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中心化：第三方的一个中心，比如 Mysql，Redis，Zookeeper
&lt;ul&gt;
&lt;li&gt;优点：趋势自增&lt;/li&gt;
&lt;li&gt;缺点：增加复杂度，一般得集群，提前约定步长之类&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无中心化：直接本地机器上生成，snowflake，uuid
&lt;ul&gt;
&lt;li&gt;优点：简单，高效，没有性能瓶颈&lt;/li&gt;
&lt;li&gt;缺点：数据比较长，自增属性较弱&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有哪一种是完美的，只有符合业务以及当前体量的方案，技术方案里面，没有最优解。&lt;/p&gt;
">分布式系统唯一id怎么生成</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/xian-cheng-chi-na-xie-shi-xia-pian/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
# 线程池
&lt;p&gt;&lt;strong&gt;本文关键字：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;线程&lt;/code&gt;，&lt;code&gt;线程池&lt;/code&gt;，&lt;code&gt;单线程&lt;/code&gt;，&lt;code&gt;多线程&lt;/code&gt;，&lt;code&gt;线程池的好处&lt;/code&gt;，&lt;code&gt;线程回收&lt;/code&gt;，&lt;code&gt;创建方式&lt;/code&gt;，&lt;code&gt;核心参数&lt;/code&gt;，&lt;code&gt;底层机制&lt;/code&gt;，&lt;code&gt;拒绝策略&lt;/code&gt;,&lt;code&gt;参数设置&lt;/code&gt;,&lt;code&gt;动态监控&lt;/code&gt;，&lt;code&gt;线程隔离&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;线程和线程池相关的知识，是Java学习或者面试中一定会遇到的知识点，本篇我们会从线程和进程，并行与并发，单线程和多线程等，一直讲解到线程池，线程池的好处，创建方式，重要的核心参数，几个重要的方法，底层实现，拒绝策略，参数设置，动态调整，线程隔离等等。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;主要的大纲如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.svg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;线程池的好处&#34;&gt;线程池的好处&lt;/h2&gt;
&lt;p&gt;线程池，使用了池化思想来管理线程，池化技术就是为了最大化效益，最小化用户风险，将资源统一放在一起管理的思想。这种思想在很多地方都有使用到，不仅仅是计算机，比如金融，企业管理，设备管理等。&lt;/p&gt;
&lt;p&gt;为什么要线程池？如果在并发的场景，编码人员根据需求来创建线程池，可能会有以下的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们很难确定系统有多少线程在运行，如果使用就创建，不使用就销毁，那么创建和销毁线程的消耗也是比较大的&lt;/li&gt;
&lt;li&gt;假设来了很多请求，可能是爬虫，疯狂创建线程，可能把系统资源耗尽。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现线程池有什么好处呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低资源消耗：池化技术可以重复利用已经创建的线程，降低线程创建和销毁的损耗。&lt;/li&gt;
&lt;li&gt;提高响应速度：利用已经存在的线程进行处理，少去了创建线程的时间&lt;/li&gt;
&lt;li&gt;管理线程可控：线程是稀缺资源，不能无限创建，线程池可以做到统一分配和监控&lt;/li&gt;
&lt;li&gt;拓展其他功能：比如定时线程池，可以定时执行任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实池化技术，用在比较多地方，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库连接池：数据库连接是稀缺资源，先创建好，提高响应速度，重复利用已有的连接&lt;/li&gt;
&lt;li&gt;实例池：先创建好对象放到池子里面，循环利用，减少来回创建和销毁的消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程池相关的类&#34;&gt;线程池相关的类&lt;/h2&gt;
&lt;p&gt;下面是与线程池相关的类的继承关系：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619135200.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;executor&#34;&gt;Executor&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Executor&lt;/code&gt; 是顶级接口，里面只有一个方法&lt;code&gt;execute(Runnable command)&lt;/code&gt;，定义的是调度线程池来执行任务，它定义了线程池的基本规范，执行任务是它的天职。&lt;/p&gt;
&lt;h3 id=&#34;executorservice&#34;&gt;ExecutorService&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ExecutorService&lt;/code&gt; 继承了&lt;code&gt;Executor&lt;/code&gt;，但是它仍然是一个接口，它多了一些方法：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619135250.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void shutdown()&lt;/code&gt;:关闭线程池，会等待任务执行完。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;List&amp;lt;Runnable&amp;gt; shutdownNow()&lt;/code&gt;:立刻关闭线程池，尝试停止所有正在积极执行的任务，停止等待任务的处理，并&lt;strong&gt;返回一个正在等待执行的任务列表（还没有执行的）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isShutdown()&lt;/code&gt;:判断线程池是不是已经关闭，但是可能线程还在执行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean isTerminated()&lt;/code&gt;:在执行shutdown/shutdownNow之后，所有的任务已经完成，这个状态就是true。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean awaitTermination(long timeout, TimeUnit unit)&lt;/code&gt;:执行shutdown之后，阻塞等到terminated状态，除非超时或者被打断。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task)&lt;/code&gt;: 提交一个有返回值的任务，并且返回该任务尚未有结果的Future，调用future.get()方法，可以返回任务完成的时候的结果。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result)&lt;/code&gt;:提交一个任务，传入返回结果，这个result没有什么作用，只是指定类型和一个返回的结果。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future&amp;lt;?&amp;gt; submit(Runnable task)&lt;/code&gt;: 提交任务，返回Future&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)&lt;/code&gt;:批量执行tasks，获取Future的list，可以批量提交任务。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,long timeout, TimeUnit unit)&lt;/code&gt;:批量提交任务，并指定超时时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)&lt;/code&gt;: 阻塞，获取第一个完成任务的结果值，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,long timeout, TimeUnit unit)&lt;/code&gt;:阻塞，获取第一个完成结果的值，指定超时时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能有同学对前面的&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result)&lt;/code&gt;有疑问，这个reuslt有什么作用？&lt;/p&gt;
&lt;p&gt;其实它没有什么作用，只是持有它，任务完成后，还是调用 &lt;code&gt;future.get（）&lt;/code&gt;返回这个结果，用&lt;code&gt;result&lt;/code&gt; new 了一个 &lt;code&gt;ftask&lt;/code&gt;，其内部其实是使用了Runnable的包装类 &lt;code&gt;RunnableAdapter&lt;/code&gt;,没有对result做特殊的处理，调用 &lt;code&gt;call()&lt;/code&gt; 方法的时候，直接返回这个结果。（Executors 中具体的实现）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) {
        if (task == null) throw new NullPointerException();
        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);
        execute(ftask);
        return ftask;
    }

    static final class RunnableAdapter&amp;lt;T&amp;gt; implements Callable&amp;lt;T&amp;gt; {
        final Runnable task;
        final T result;
        RunnableAdapter(Runnable task, T result) {
            this.task = task;
            this.result = result;
        }
        public T call() {
            task.run();
            // 返回传入的结果
            return result;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还有一个方法值得一提：&lt;code&gt;invokeAny()&lt;/code&gt;: 在 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中使用&lt;code&gt;ExecutorService&lt;/code&gt; 中的方法 &lt;code&gt;invokeAny()&lt;/code&gt; 取得第一个完成的任务的结果，当第一个任务执行完成后，会调用 &lt;code&gt;interrupt()&lt;/code&gt; 方法将其他任务中断。&lt;/p&gt;
&lt;p&gt;注意，&lt;code&gt;ExecutorService&lt;/code&gt;是接口，里面都是定义，并没有涉及实现，而前面的讲解都是基于它的名字（规定的规范）以及它的普遍实现来说的。&lt;/p&gt;
&lt;p&gt;可以看到 &lt;code&gt;ExecutorService&lt;/code&gt; 定义的是线程池的一些操作，包括关闭，判断是否关闭，是否停止，提交任务，批量提交任务等等。&lt;/p&gt;
&lt;h3 id=&#34;abstractexecutorservice&#34;&gt;AbstractExecutorService&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;AbstractExecutorService&lt;/code&gt; 是一个抽象类，实现了 &lt;code&gt;ExecutorService&lt;/code&gt;接口，这是大部分线程池的基本实现，定时的线程池先不关注，主要的方法如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619163946.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;不仅实现了&lt;code&gt;submit&lt;/code&gt;，&lt;code&gt;invokeAll&lt;/code&gt;，&lt;code&gt;invokeAny&lt;/code&gt; 等方法，而且提供了一个 &lt;code&gt;newTaskFor&lt;/code&gt; 方法用于构建 &lt;code&gt;RunnableFuture&lt;/code&gt; 对象，那些能够获取到任务返回结果的对象都是通过 &lt;code&gt;newTaskFor&lt;/code&gt; 来获取的。不展开里面所有的源码的介绍，仅以submit()方法为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public Future&amp;lt;?&amp;gt; submit(Runnable task) {
        if (task == null) throw new NullPointerException();
        // 封装任务
        RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
        // 执行任务
        execute(ftask);
        // 返回 RunnableFuture 对象
        return ftask;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是在 &lt;code&gt;AbstractExecutorService&lt;/code&gt; 是没有对最最重要的方法进行实现的，也就是 &lt;code&gt;execute()&lt;/code&gt; 方法。线程池具体是怎么执行的，这个不同的线程池可以有不同的实现，一般都是继承 &lt;code&gt;AbstractExecutorService&lt;/code&gt; (定时任务有其他的接口)，我们最最常用的就是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619165858.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;threadpoolexecutor&#34;&gt;ThreadPoolExecutor&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;重点来了!!!&lt;/strong&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 一般就是我们平时常用到的线程池类，所谓创建线程池，如果不是定时线程池，就是使用它。&lt;/p&gt;
&lt;p&gt;先看&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的内部结构(属性)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ThreadPoolExecutor extends AbstractExecutorService {
    // 状态控制，主要用来控制线程池的状态，是核心的遍历，使用的是原子类
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
  	// 用来表示线程数量的位数（使用的是位运算，一部分表示线程的数量，一部分表示线程池的状态）
    // SIZE = 32 表示32位，那么COUNT_BITS就是29位
    private static final int COUNT_BITS = Integer.SIZE - 3;
  	// 线程池的容量，也就是27位表示的最大值
    private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

    // 状态量，存储在高位，32位中的前3位
  	// 111（第一位是符号位，1表示负数），线程池运行中
    private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS; 
  	// 000
    private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
  	// 001
    private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
  	// 010
    private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
  	// 011
    private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;

    // 取出运行状态
    private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
  	// 取出线程数量
    private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
  	// 用运行状态和线程数获取ctl
    private static int ctlOf(int rs, int wc) { return rs | wc; }
  	
  	// 任务等待队列
    private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;
  	// 可重入主锁（保证一些操作的线程安全）
    private final ReentrantLock mainLock = new ReentrantLock();
  	// 线程的集合
    private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();
  
  	// 在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，
    // 传统线程的通信方式，Condition都可以实现，Condition和传统的线程通信没什么区别，Condition的强大之处在于它可以为多个线程间建立不同的Condition
    private final Condition termination = mainLock.newCondition();
  
  	// 最大线程池大小
    private int largestPoolSize;
  	// 完成的任务数量
    private long completedTaskCount;
  	// 线程工厂
    private volatile ThreadFactory threadFactory;
  	// 任务拒绝处理器
    private volatile RejectedExecutionHandler handler;
 		// 非核心线程的存活时间
    private volatile long keepAliveTime;
  	// 允许核心线程的超时时间
    private volatile boolean allowCoreThreadTimeOut;
 		// 核心线程数
    private volatile int corePoolSize;
		// 工作线程最大容量
    private volatile int maximumPoolSize;
 		// 默认的拒绝处理器（丢弃任务）
  	private static final RejectedExecutionHandler defaultHandler =
        new AbortPolicy();
  	// 运行时关闭许可
    private static final RuntimePermission shutdownPerm =
        new RuntimePermission(&amp;quot;modifyThread&amp;quot;);
  	// 上下文
    private final AccessControlContext acc;
  	// 只有一个线程
    private static final boolean ONLY_ONE = true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;线程池状态&#34;&gt;线程池状态&lt;/h4&gt;
&lt;p&gt;从上面的代码可以看出，用一个32位的对象保存线程池的状态以及线程池的容量，高3位是线程池的状态，而剩下的29位，则是保存线程的数量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    // 状态量，存储在高位，32位中的前3位
  	// 111（第一位是符号位，1表示负数），线程池运行中
    private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS; 
  	// 000
    private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
  	// 001
    private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
  	// 010
    private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
  	// 011
    private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;各种状态之间是不一样的，他们的状态之间变化如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619211431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;RUNNING：运行状态，可以接受任务，也可以处理任务&lt;/li&gt;
&lt;li&gt;SHUTDOWN：不可以接受任务，但是可以处理任务&lt;/li&gt;
&lt;li&gt;STOP：不可以接受任务，也不可以处理任务，中断当前任务&lt;/li&gt;
&lt;li&gt;TIDYING：所有线程停止&lt;/li&gt;
&lt;li&gt;TERMINATED：线程池的最后状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;worker-实现&#34;&gt;Worker 实现&lt;/h4&gt;
&lt;p&gt;线程池，肯定得有池子，并且是放线程的地方，在 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 中表现为 &lt;code&gt;Worker&lt;/code&gt;，这是内部类：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619170610.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;线程池其实就是 &lt;code&gt;Worker&lt;/code&gt; (打工人，不断的领取任务，完成任务)的集合，这里使用的是 &lt;code&gt;HashSet&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Worker&lt;/code&gt; 怎么实现的呢？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Worker&lt;/code&gt; 除了继承了 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;,也就是 &lt;code&gt;AQS&lt;/code&gt; ， &lt;code&gt;AQS&lt;/code&gt; 本质上就是个队列锁，一个简单的互斥锁，一般是在中断或者修改 &lt;code&gt;worker&lt;/code&gt; 状态的时候使用。&lt;/p&gt;
&lt;p&gt;内部引入&lt;code&gt;AQS&lt;/code&gt;，是为了线程安全，线程执行任务的时候，调用的是&lt;code&gt;runWorker(Worker w)&lt;/code&gt;，这个方法不是worker的方法，而是 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的方法。从下面的代码可以看出，每次修改&lt;code&gt;Worke&lt;/code&gt;r的状态的时候，都是线程安全的。&lt;code&gt;Worker&lt;/code&gt;里面，持有了一个线程&lt;code&gt;Thread&lt;/code&gt;,可以理解为是对线程的封装。&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;runWorker(Worker w)&lt;/code&gt;是怎么运行的？先保持这个疑问，后面详细讲解。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    // 实现 Runnable，封装了线程
    private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        // 序列化id
        private static final long serialVersionUID = 6138294804551838833L;

        // worker运行的线程
        final Thread thread;
        
        // 初始化任务，有可能是空的，如果任务不为空的时候，其他进来的任务，可以直接运行，不在添加到任务队列
        Runnable firstTask;
        // 线程任务计数器
        volatile long completedTasks;

        // 指定一个任务让工人忙碌起来，这个任务可能是空的
        Worker(Runnable firstTask) {
          	// 初始化AQS队列锁的状态
            setState(-1); // 禁止中断直到 runWorker
            this.firstTask = firstTask;
            // 从线程工厂，取出一个线程初始化
            this.thread = getThreadFactory().newThread(this);
        }

        // 实际上运行调用的是runWorker
        public void run() {
          	// 不断循环获取任务进行执行
            runWorker(this);
        }

        // 0表示没有被锁
        // 1表示被锁的状态
        protected boolean isHeldExclusively() {
            return getState() != 0;
        }
        // 独占，尝试获取锁，如果成功返回true，失败返回false
        protected boolean tryAcquire(int unused) {
            // CAS 乐观锁
            if (compareAndSetState(0, 1)) {
                // 成功，当前线程独占锁
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
        // 独占方式，尝试释放锁
        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }
        // 上锁，调用的是AQS的方法
        public void lock()        { acquire(1); }
        // 尝试上锁
        public boolean tryLock()  { return tryAcquire(1); }
        // 解锁
        public void unlock()      { release(1); }
        // 是否锁住
        public boolean isLocked() { return isHeldExclusively(); }

        // 如果开始可就中断
        void interruptIfStarted() {
            Thread t;
            if (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != null &amp;amp;&amp;amp; !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;任务队列&#34;&gt;任务队列&lt;/h4&gt;
&lt;p&gt;除了放线程池的地方，要是任务很多，没有那么多线程，肯定需要一个地方放任务，充当缓冲作用，也就是任务队列，在代码中表现为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;拒绝策略和处理器&#34;&gt;拒绝策略和处理器&lt;/h4&gt;
&lt;p&gt;计算机的内存总是有限的，我们不可能一直往队列里面增加内容，所以线程池为我们提供了选择，可以选择多种队列。同时当任务实在太多，占满了线程，并且把任务队列也占满的时候，我们需要做出一定的反应，那就是拒绝还是抛出错误，丢掉任务？丢掉哪些任务，这些都是可能需要定制的内容。&lt;/p&gt;
&lt;h2 id=&#34;如何创建线程池&#34;&gt;如何创建线程池&lt;/h2&gt;
&lt;p&gt;关于如何创建线程池，其实 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;提供了构造方法，主要参数如下，不传的话会使用默认的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心线程数：核心线程数，一般是指常驻的线程，没有任务的时候通常也不会销毁&lt;/li&gt;
&lt;li&gt;最大线程数：线程池允许创建的最大的线程数量&lt;/li&gt;
&lt;li&gt;非核心线程的存活时间：指的是没有任务的时候，非核心线程能够存活多久&lt;/li&gt;
&lt;li&gt;时间的单位：存活时间的单位&lt;/li&gt;
&lt;li&gt;存放任务的队列：用来存放任务&lt;/li&gt;
&lt;li&gt;线程工厂&lt;/li&gt;
&lt;li&gt;拒绝处理器:如果添加任务失败，将由该处理器处理&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	// 指定核心线程数，最大线程数，非核心线程没有任务的存活时间，时间单位，任务队列    
	public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
	  // 指定核心线程数，最大线程数，非核心线程没有任务的存活时间，时间单位，任务队列，线程池工厂    
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             threadFactory, defaultHandler);
    }
	  // 指定核心线程数，最大线程数，非核心线程没有任务的存活时间，时间单位，任务队列，拒绝任务处理器
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              RejectedExecutionHandler handler) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), handler);
    }
		// 最后其实都是调用了这个方法
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
      ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实，除了显示的指定上面的参数之外，JDK也封装了一些直接创建线程池的方法给我们，那就是&lt;code&gt;Executors&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;		// 固定线程数量的线程池，无界的队列
		public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());
    }
		// 单个线程的线程池，无界的队列，按照任务提交的顺序，串行执行    
		public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),
                                    threadFactory));
    }
		// 动态调节，没有核心线程，全部都是普通线程，每个线程存活60s，使用容量为1的阻塞队列
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());
    }
	  // 定时任务线程池
    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
        return new DelegatedScheduledExecutorService
            (new ScheduledThreadPoolExecutor(1));
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是一般是不推荐使用上面别人封装的线程池的哈！！！&lt;/p&gt;
&lt;h2 id=&#34;线程池的底层参数以及核心方法&#34;&gt;线程池的底层参数以及核心方法&lt;/h2&gt;
&lt;p&gt;看完上面的创建参数大家可能会有点懵，但是没关系，一一为大家道来：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619215638.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看出，当有任务进来的时候，先判断核心线程池是不是已经满了，如果还没有，将会继续创建线程。注意，如果一个任务进来，创建线程执行，执行完成，线程空闲下来，这时候再来一个任务，是会继续使用之前的线程，还是重新创建一个线程来执行呢？&lt;/p&gt;
&lt;p&gt;答案是重新创建线程，这样线程池可以快速达到核心线程数的规模大小，以便快速响应后面的任务。&lt;/p&gt;
&lt;p&gt;如果线程数量已经到达核心线程数，来了任务，线程池的线程又都不是空闲状态，那么就会判断队列是不是满的，倘若队列还有空间，那么就会把任务放进去队列中，等待线程领取执行。&lt;/p&gt;
&lt;p&gt;如果任务队列已经满了，放不下任务，那么就会判断线程数是不是已经到最大线程数了，要是还没有到达，就会继续创建线程并执行任务，这个时候创建的是非核心部分线程。&lt;/p&gt;
&lt;p&gt;如果已经到达最大线程数，那么就不能继续创建线程了，只能执行拒绝策略，默认的拒绝策略是丢弃任务，我们可以自定义拒绝策略。&lt;/p&gt;
&lt;p&gt;值得注意的是，倘若之前任务比较多，创建出了一些非核心线程，那么任务少了之后，领取不到任务，过了一定时间，非核心线程就会销毁，只剩下核心线程池的数量的线程。这个时间就是前面说的&lt;code&gt;keepAliveTime&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;提交任务&#34;&gt;提交任务&lt;/h3&gt;
&lt;p&gt;提交任务，我们看&lt;code&gt;execute()&lt;/code&gt;，会先获取线程池的状态和个数，要是线程个数还没达到核心线程数，会直接添加线程，否则会放到任务队列，如果任务队列放不下，会继续增加线程，但是不是增加核心线程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        // 获取状态和个数
        int c = ctl.get();
      	// 如果个数小于核心线程数
        if (workerCountOf(c) &amp;lt; corePoolSize) {
          	// 直接添加
            if (addWorker(command, true))
                return;
          	// 添加失败则继续获取
            c = ctl.get();
        }
      	// 判断线程池状态是不是运行中，任务放到队列中
        if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
          	// 再次检查
            int recheck = ctl.get();
          	// 判断线程池是不是还在运行
            if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
              	// 如果不是，那么就拒绝并移除任务
                reject(command);
            else if (workerCountOf(recheck) == 0)
              	// 如果线程数为0，并且还在运行，那么就直接添加
                addWorker(null, false);
        }else if (!addWorker(command, false))
          	// 添加任务队列失败，拒绝
            reject(command);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的源码中，调用了一个重要的方法：&lt;code&gt;addWorker(Runnable firstTask, boolean core)&lt;/code&gt;,该方法主要是为了增加工作的线程，我们来看看它是如何执行的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private boolean addWorker(Runnable firstTask, boolean core) {
      	// 回到当前位置重试
        retry:
        for (;;) {
          	// 获取状态
            int c = ctl.get();
            int rs = runStateOf(c);

            // 大于SHUTDOWN说明线程池已经停止
          	// ! (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null &amp;amp;&amp;amp; ! workQueue.isEmpty()) 表示三个条件至少有一个不满足
          	// 不等于SHUTDOWN说明是大于shutdown
          	// firstTask ！= null 任务不是空的
          	// workQueue.isEmpty() 队列是空的
            if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
                ! (rs == SHUTDOWN &amp;amp;&amp;amp;
                   firstTask == null &amp;amp;&amp;amp;
                   ! workQueue.isEmpty()))
                return false;

            for (;;) {
                // 工作线程数
                int wc = workerCountOf(c);
              	// 是否符合容量
                if (wc &amp;gt;= CAPACITY ||
                    wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;
              	// 添加成功，跳出循环
                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
              	// cas失败，重新尝试
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

      	// 前面线程计数增加成功
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
          	// 创建了一个worker，包装了任务
            w = new Worker(firstTask);
            final Thread t = w.thread;
          	// 线程创建成功
            if (t != null) {
              	// 获取锁
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // 再次确认状态
                    int rs = runStateOf(ctl.get());
                    if (rs &amp;lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                      	// 如果线程已经启动，失败
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                      	// 新增线程到集合
                        workers.add(w);
                      	// 获取大小
                        int s = workers.size();
                      	// 判断最大线程池数量
                        if (s &amp;gt; largestPoolSize)
                            largestPoolSize = s;
                      	// 已经添加工作线程
                        workerAdded = true;
                    }
                } finally {
                  	// 解锁
                    mainLock.unlock();
                }
              	// 如果已经添加
                if (workerAdded) {
                  	// 启动线程
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
          	// 如果没有启动
            if (! workerStarted)
              	// 失败处理
                addWorkerFailed(w);
        }
        return workerStarted;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;处理任务&#34;&gt;处理任务&lt;/h3&gt;
&lt;p&gt;前面在介绍&lt;code&gt;Worker&lt;/code&gt;这个类的时候，我们讲解到其实它的&lt;code&gt;run()&lt;/code&gt;方法调用的是外部的&lt;code&gt;runWorker()&lt;/code&gt;方法，那么我们来看看&lt;code&gt;runWorkder()&lt;/code&gt;方法：&lt;/p&gt;
&lt;p&gt;首先，它会直接处理自己的firstTask,这个任务并没有在任务队列里面，而是它自己持有的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final void runWorker(Worker w) {
  			// 当前线程
        Thread wt = Thread.currentThread();
  			// 第一个任务
        Runnable task = w.firstTask;
  			// 重置为null
        w.firstTask = null;
  			// 允许打断
        w.unlock();
        boolean completedAbruptly = true;
        try {
           // 任务不为空，或者获取的任务不为空
            while (task != null || (task = getTask()) != null) {
              	// 加锁
                w.lock();
								//如果线程池停止，确保线程被中断;
								//如果不是，确保线程没有被中断。这
								//在第二种情况下需要复查处理
								// shutdown - now竞赛同时清除中断
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &amp;amp;&amp;amp;
                      runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                  	// 执行之前回调方法（可以由我们自己实现）
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                      	// 执行任务
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                      	// 执行之后回调方法
                        afterExecute(task, thrown);
                    }
                } finally {
                  	// 置为null
                    task = null;
                  	// 更新完成任务
                    w.completedTasks++;
                    w.unlock();
                }
            }
          	// 完成
            completedAbruptly = false;
        } finally {
          	// 处理线程退出相关工作
            processWorkerExit(w, completedAbruptly);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面可以看到如果当前的任务是null，会去获取一个task，我们看看&lt;code&gt;getTask()&lt;/code&gt;，里面涉及到了两个参数，一个是是不是允许核心线程销毁，另外一个是线程数是不是大于核心线程数，如果满足条件，就从队列中取出任务，如果超时取不到，那就返回空，表示没有取到任务，没有取到任务，就不会执行前面的循环，就会触发线程销毁&lt;code&gt;processWorkerExit()&lt;/code&gt;等工作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private Runnable getTask() {
  	// 是否超时
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // SHUTDOWN状态继续处理队列中的任务，但是不接收新的任务
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }
      	// 线程数
        int wc = workerCountOf(c);

        // 是否允许核心线程超时或者线程数大于核心线程数
        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;

        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
          	// 减少线程成功，就返回null，后面由processWorkerExit()处理
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
          	// 如果允许核心线程关闭，或者超过了核心线程，就可以在超时的时间内获取任务，或者直接取出任务
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
          	// 如果能取到任务，那就肯定可以执行
            if (r != null)
                return r;
          	// 否则就获取不到任务，超时了
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;销毁线程&#34;&gt;销毁线程&lt;/h3&gt;
&lt;p&gt;前面提到，如果线程当前任务为空，又允许核心线程销毁，或者线程超过了核心线程数，等待了一定时间，超时了却没有从任务队列获取到任务的话，就会跳出循环执行到后面的线程销毁（结束）程序。那销毁线程的时候怎么做呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private void processWorkerExit(Worker w, boolean completedAbruptly) {
      	// 如果是突然结束的线程，那么之前的线程数是没有调整的，这里需要调整
        if (completedAbruptly)
            decrementWorkerCount();
      	// 获取锁
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
      
        try {
          	// 完成的任务数
            completedTaskCount += w.completedTasks;
            // 移除线程
          	workers.remove(w);
        } finally {
          	// 解锁
            mainLock.unlock();
        }
      	// 试图停止
        tryTerminate();
      	// 获取状态
        int c = ctl.get();
      	// 比stop小，至少是shutdown
        if (runStateLessThan(c, STOP)) {
          	// 如果不是突然完成
            if (!completedAbruptly) {
              	// 最小值要么是0，要么是核心线程数，要是允许核心线程超时销毁，那么就是0
                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
              	// 如果最小的是0或者队列不是空的，那么保留一个线程
                if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty())
                    min = 1;
              	// 只要大于等于最小的线程数，就结束当前线程
                if (workerCountOf(c) &amp;gt;= min)
                    return; // replacement not needed
            }
          	// 否则的话，可能还需要新增工作线程
            addWorker(null, false);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;如何停止线程池&#34;&gt;如何停止线程池&lt;/h3&gt;
&lt;p&gt;停止线程池可以使用&lt;code&gt;shutdown()&lt;/code&gt;或者&lt;code&gt;shutdownNow()&lt;/code&gt;，&lt;code&gt;shutdown()&lt;/code&gt;可以继续处理队列中的任务，而&lt;code&gt;shutdownNow()&lt;/code&gt;会立即清理任务，并返回未执行的任务。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public void shutdown() {
        // 获取锁
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
          	// 检查停止权限
            checkShutdownAccess();
          	// 更新状态
            advanceRunState(SHUTDOWN);
          	// 中断所有线程
            interruptIdleWorkers();
          	// 回调钩子
            onShutdown(); // hook for ScheduledThreadPoolExecutor
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
    }
		// 立刻停止
   public List&amp;lt;Runnable&amp;gt; shutdownNow() {
        List&amp;lt;Runnable&amp;gt; tasks;
     		// 获取锁
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
          	// 检查停止权限
            checkShutdownAccess();
          	// 更新状态到stop
            advanceRunState(STOP);
          	// 中断所有线程
            interruptWorkers();
            // 清理队列
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
     		// 返回任务列表（未完成）
        return tasks;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;execute和submit方法&#34;&gt;execute()和submit()方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;execute() &lt;/code&gt;方法可以提交不需要返回值的任务，无法判断任务是否被线程池执行是否成功&lt;/li&gt;
&lt;li&gt;&lt;code&gt;submit()&lt;/code&gt;方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个对象，我们调用&lt;code&gt;get()&lt;/code&gt;方法就可以&lt;strong&gt;阻塞&lt;/strong&gt;，直到获取到线程执行完成的结果，同时我们也可以使用有超时时间的等待方法&lt;code&gt;get（long timeout，TimeUnit unit）&lt;/code&gt;,这样不管线程有没有执行完成，如果到时间，也不会阻塞，直接返回null。返回的是&lt;code&gt;RunnableFuture&lt;/code&gt;对象，继承了&lt;code&gt;Runnable, Future&amp;lt;V&amp;gt;&lt;/code&gt;两个接口：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;线程池为什么使用阻塞队列&#34;&gt;线程池为什么使用阻塞队列？&lt;/h2&gt;
&lt;p&gt;阻塞队列，首先是一个队列，肯定具有先进先出的属性。&lt;/p&gt;
&lt;p&gt;而阻塞，则是这个模型的演化，一般队列，可以用在生产消费者模型，也就是数据共享，有人往里面放任务，有人不断的往里面取出任务，这是一个理想的状态。&lt;/p&gt;
&lt;p&gt;但是倘若不理想，产生任务和消费任务的速度不一样，要是任务放在队列里面比较多，消费比较慢，还可以慢慢消费，或者生产者得暂停一下产生任务（阻塞生产者线程）。可以使用 &lt;code&gt;offer(E o, long timeout, TimeUnit unit)&lt;/code&gt;设定等待的时间，如果在指定的时间内，还不能往队列中加入&lt;code&gt;BlockingQueue&lt;/code&gt;，则返回失败,也可以使用&lt;code&gt;put(Object)&lt;/code&gt;,将对象放到阻塞队列里面，如果没有空间，那么这个方法会阻塞到有空间才会放进去。&lt;/p&gt;
&lt;p&gt;如果消费速度快，生产者来不及生产，获取任务的时候，可以使用&lt;code&gt;poll(time)&lt;/code&gt;,有数据则直接取出来，没数据则可以等待&lt;code&gt;time&lt;/code&gt;时间后，返回&lt;code&gt;null&lt;/code&gt;。也可以使用&lt;code&gt;take()&lt;/code&gt;取出第一个任务，没有任务就会一直阻塞到队列有任务为止。&lt;/p&gt;
&lt;p&gt;上面说了阻塞队列的属性，那么为啥要用呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果产生任务，来了就往队列里面放，资源很容易被耗尽。&lt;/li&gt;
&lt;li&gt;创建线程需要获取锁，这个一个线程池的全局锁，如果各个线程不断的获取锁，解锁，线程上下文切换之类的开销也比较大，不如在队列为空的时候，然一个线程阻塞等待。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常见的阻塞队列&#34;&gt;常见的阻塞队列&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210621005042.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;：基于数组实现，内部有一个定长的数组，同时保存着队列头和尾部的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;：基于链表的阻塞对垒，生产者和消费者使用独立的锁，并行能力强，如果不指定容量，默认是无效容量，容易系统内存耗尽。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DelayQueue&lt;/strong&gt;：延迟队列，没有大小限制，生产数据不会被阻塞，消费数据会，只有指定的延迟时间到了，才能从队列中获取到该元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt;：基于优先级的阻塞队列，按照优先级进行消费，内部控制同步的是公平锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SynchronousQueue&lt;/strong&gt;：没有缓冲，生产者直接把任务交给消费者，少了中间的缓存区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程池如何复用线程的执行完成的线程怎么处理&#34;&gt;线程池如何复用线程的？执行完成的线程怎么处理&lt;/h2&gt;
&lt;p&gt;前面的源码分析，其实已经讲解过这个问题了，线程池的线程调用的&lt;code&gt;run()&lt;/code&gt;方法，其实调用的是&lt;code&gt;runWorker()&lt;/code&gt;，里面是死循环，除非获取不到任务，如果没有了任务firstTask并且从任务队列中获取不到任务，超时的时候，会再判断是不是可以销毁核心线程，或者超过了核心线程数，满足条件的时候，才会让当前的线程结束。&lt;/p&gt;
&lt;p&gt;否则，一直都在一个循环中，不会结束。&lt;/p&gt;
&lt;p&gt;我们知道&lt;code&gt;start()&lt;/code&gt;方法只能调用一次,因此调用到&lt;code&gt;run()&lt;/code&gt;方法的时候，调用外面的&lt;code&gt;runWorker()&lt;/code&gt;,让其在&lt;code&gt;runWorker()&lt;/code&gt;的时候，不断的循环，获取任务。获取到任务，调用任务的&lt;code&gt;run()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;执行完成的线程会调用&lt;code&gt;processWorkerExit（）&lt;/code&gt;,前面有分析，里面会获取锁，把线程数减少，从工作线程从集合中移除，移除掉之后，会判断线程是不是太少了，如果是，会再加回来，个人以为是一种补救。&lt;/p&gt;
&lt;h2 id=&#34;如何配置线程池参数&#34;&gt;如何配置线程池参数？&lt;/h2&gt;
&lt;p&gt;一般而言，有个公式，如果是计算（CPU）密集型的任务，那么核心线程数设置为&lt;code&gt;处理器核数-1&lt;/code&gt;，如果是io密集型（很多网络请求），那么就可以设置为&lt;code&gt;2*处理器核数&lt;/code&gt;。但是这并不是一个银弹，一切要从实际出发，最好就是在测试环境进行压测，实践出真知，并且很多时候一台机器不止一个线程池或者还会有其他的线程，因此参数不可设置得太过饱满。&lt;/p&gt;
&lt;p&gt;一般 8 核的机器，设置 10-12 个核心线程就差不多了，这一切必须按照业务具体值进行计算。设置过多的线程数，上下文切换，竞争激烈，设置过少，没有办法充分利用计算机的资源。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计算（CPU）密集型消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。&lt;/p&gt;
&lt;p&gt;io密集型系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;为什么不推荐默认的线程池创建方式&#34;&gt;为什么不推荐默认的线程池创建方式？&lt;/h2&gt;
&lt;p&gt;阿里的编程规范里面，不建议使用默认的方式来创建线程，是因为这样创建出来的线程很多时候参数都是默认的，可能创建者不太了解，很容易出问题，最好通过&lt;code&gt;new ThreadPoolExecutor()&lt;/code&gt;来创建，方便控制参数。默认的方式创建的问题如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Executors.newFixedThreadPool()：无界队列，内存可能被打爆&lt;/li&gt;
&lt;li&gt;Executors.newSingleThreadExecutor()：单个线程，效率低，串行。&lt;/li&gt;
&lt;li&gt;Executors.newCachedThreadPool()：没有核心线程，最大线程数可能为无限大，内存可能还会爆掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用具体的参数创建线程池，开发者必须了解每个参数的作用，不会胡乱设置参数，减少内存溢出等问题。&lt;/p&gt;
&lt;p&gt;一般体现在几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务队列怎么设置？&lt;/li&gt;
&lt;li&gt;核心线程多少个？&lt;/li&gt;
&lt;li&gt;最大线程数多少？&lt;/li&gt;
&lt;li&gt;怎么拒绝任务？&lt;/li&gt;
&lt;li&gt;创建线程的时候没有名称，追溯问题不好找。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程池的拒绝策略&#34;&gt;线程池的拒绝策略&lt;/h2&gt;
&lt;p&gt;线程池一般有以下四种拒绝策略，其实我们可以从它的内部类看出来：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210620025945.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;AbortPolicy: 不执行新的任务，直接抛出异常，提示线程池已满&lt;/li&gt;
&lt;li&gt;DisCardPolicy：不执行新的任务，但是也不会抛出异常，默默的&lt;/li&gt;
&lt;li&gt;DisCardOldSetPolicy：丢弃消息队列中最老的任务，变成新进来的任务&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：直接调用当前的execute来执行任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般而言，上面的拒绝策略都不会特别理想，一般要是任务满了，首先需要做的就是看任务是不是必要的，如果非必要，非核心，可以考虑拒绝掉，并报错提醒，如果是必须的，必须把它保存起来，不管是使用mq消息，还是其他手段，不能丢任务。在这些过程中，日志是非常必要的。既要保护线程池，也要对业务负责。&lt;/p&gt;
&lt;h2 id=&#34;线程池监控与动态调整&#34;&gt;线程池监控与动态调整&lt;/h2&gt;
&lt;p&gt;线程池提供了一些API，可以动态获取线程池的状态，并且还可以设置线程池的参数，以及状态：&lt;/p&gt;
&lt;p&gt;查看线程池的状态：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210621013706.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;修改线程池的状态：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210621013450.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;关于这一点，美团的线程池文章讲得很清楚，甚至做了一个实时调整线程池参数的平台，可以进行跟踪监控，线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等。这里我就不展开了，原文：https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html ，这是我们可以参考的思路。&lt;/p&gt;
&lt;h2 id=&#34;线程池隔离&#34;&gt;线程池隔离&lt;/h2&gt;
&lt;p&gt;线程隔离，很多同学可能知道，就是不同的任务放在不同的线程里面运行，而线程池隔离，一般是按照业务类型来隔离，比如订单的处理线程放在一个线程池，会员相关的处理放在一个线程池。&lt;/p&gt;
&lt;p&gt;也可以通过核心和非核心来隔离，核心处理流程放在一起，非核心放在一起，两个使用不一样的参数，不一样的拒绝策略，尽量保证多个线程池之间不影响，并且最大可能保住核心线程的运行，非核心线程可以忍受失败。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Hystrix&lt;/code&gt;里面运用到这个技术，&lt;code&gt;Hystrix&lt;/code&gt;的线程隔离技术，来防止不同的网络请求之间的雪崩，即使依赖的一个服务的线程池满了，也不会影响到应用程序的其他部分。&lt;/p&gt;
">线程池那些事下篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/xian-cheng-chi-na-xie-shi-shang-pian/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;p&gt;&lt;strong&gt;本文关键字：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;线程&lt;/code&gt;，&lt;code&gt;线程池&lt;/code&gt;，&lt;code&gt;单线程&lt;/code&gt;，&lt;code&gt;多线程&lt;/code&gt;，&lt;code&gt;线程池的好处&lt;/code&gt;，&lt;code&gt;线程回收&lt;/code&gt;，&lt;code&gt;创建方式&lt;/code&gt;，&lt;code&gt;核心参数&lt;/code&gt;，&lt;code&gt;底层机制&lt;/code&gt;，&lt;code&gt;拒绝策略&lt;/code&gt;,&lt;code&gt;参数设置&lt;/code&gt;,&lt;code&gt;动态监控&lt;/code&gt;，&lt;code&gt;线程隔离&lt;/code&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;线程和线程池相关的知识，是Java学习或者面试中一定会遇到的知识点，本篇我们会从线程和进程，并行与并发，单线程和多线程等，一直讲解到线程池，线程池的好处，创建方式，重要的核心参数，几个重要的方法，底层实现，拒绝策略，参数设置，动态调整，线程隔离等等。主要的大纲如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.svg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;进程和线程&#34;&gt;进程和线程&lt;/h1&gt;
&lt;h2 id=&#34;从线程到进程&#34;&gt;从线程到进程&lt;/h2&gt;
&lt;p&gt;要说线程池，就不得不先讲讲线程，什么是线程？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;（英语：thread）是&lt;a href=&#34;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&#34;&gt;操作系统&lt;/a&gt;能够进行运算&lt;a href=&#34;https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6&#34;&gt;调度&lt;/a&gt;的最小单位。它被包含在&lt;a href=&#34;https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B&#34;&gt;进程&lt;/a&gt;之中，是&lt;a href=&#34;https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B&#34;&gt;进程&lt;/a&gt;中的实际运作单位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么问题来了，进程又是什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程是操作系统中进行保护和资源分配的基本单位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是不是有点懵，进程摸得着看得见么？具体怎么表现？打开&lt;code&gt;Windows&lt;/code&gt;的任务管理器或者&lt;code&gt;Mac&lt;/code&gt;的活动监视器，就可以看到，基本每一个打开的&lt;code&gt;App&lt;/code&gt;就是一个进程，但是并不是一定的，&lt;strong&gt;一个应用程序可能存在多个进程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如下面的&lt;code&gt;Typora&lt;/code&gt;就显示了两个进程，每个进程后面有一个&lt;code&gt;PID&lt;/code&gt;是唯一的标识，也是由系统分配的。除此之外，每个进程都可以看到有多少个线程在执行，比如微信有&lt;code&gt;32&lt;/code&gt;个线程在执行。**重要的一句话：**一个程序运行之后至少有一个进程，一个进程可以包含多个线程。&lt;/p&gt;
&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210508225417275.png&#34; alt=&#34;image-20210508225417275&#34; style=&#34;zoom:50%;&#34; /&gt;
&lt;h2 id=&#34;为什么需要进程&#34;&gt;为什么需要进程？&lt;/h2&gt;
&lt;p&gt;程序，就是指令的集合，指令的集合说白了就是文件，让程序跑起来，在执行的程序，才是进程。程序是静态的描述文本，而进程是程序的一次执行活动，是动态的。进程是拥有计算机分配的资源的运行程序。&lt;/p&gt;
&lt;p&gt;我们不可能一个计算机只有一个进程，就跟我们全国不可能只有一个市或者一个部门，计算机是一个庞然大物，里面的运转需要有条理，就需要按照功能划分出比较独立的单位，分开管理。每个进程有自己的职责，也有自己的独立内存空间，不可能混着使用，要是所有的程序共用一个进程就会乱套。&lt;/p&gt;
&lt;p&gt;**每个进程，都有各自独立的内存，进程之间内存地址隔离，进程的资源，比如：代码段，数据集，堆等等，还可能包括一些打开的文件或者信号量，这都是每个进程自己的数据。**同时，由于进程的隔离性，即使有一个程序的进程出现问题了，一般不会影响到其他的进程的使用。&lt;/p&gt;
&lt;p&gt;进程在Linux系统中，进程有一个比较重要的东西，叫进程控制块（&lt;code&gt;PCB&lt;/code&gt;），仅做了解：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PCB&lt;/code&gt;是进程的唯一标识，由链表实现，是为了动态的插入以及删除，创建进程的时候，生成一个&lt;code&gt;PCB&lt;/code&gt;，进程结束的时候，回收这个&lt;code&gt;PCB&lt;/code&gt;。&lt;code&gt;PCB&lt;/code&gt;主要包括以下的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程状态&lt;/li&gt;
&lt;li&gt;进程标识信息&lt;/li&gt;
&lt;li&gt;定时器&lt;/li&gt;
&lt;li&gt;用户可见的寄存器，控制状态寄存区，栈指针等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程怎么切换的呢&#34;&gt;进程怎么切换的呢？&lt;/h4&gt;
&lt;p&gt;先明白计算机里面的一个事实：&lt;strong&gt;CPU运转得超级无敌快&lt;/strong&gt;，快到其他的只有寄存器差不多能匹配它的速度，但是很多时候我们需要从磁盘或者内存读或者写数据，这些设备的速度太慢了，与之相差太远。（&lt;strong&gt;如果不特殊说明，默认是单核的CPU&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;假设一个程序/进程的任务执行一段时间，要写磁盘，写磁盘不需要&lt;code&gt;CUP&lt;/code&gt;进行计算，那&lt;code&gt;CPU&lt;/code&gt;就空出来了，但是其他的程序也不能用，&lt;code&gt;CPU&lt;/code&gt;就干等着，等到写完磁盘再接着执行。这多浪费，&lt;code&gt;CPU&lt;/code&gt;又不是这个程序一家的，其他的应用也要使用。&lt;code&gt;CPU&lt;/code&gt;你不用的时候，总有别人需要用。&lt;/p&gt;
&lt;p&gt;所以&lt;code&gt;CPU&lt;/code&gt;资源需要调度，程序&lt;code&gt;A&lt;/code&gt;不用的时候，可以切出来，让程序&lt;code&gt;B&lt;/code&gt;去使用，但是程序&lt;code&gt;A&lt;/code&gt;切回来的时候怎么保证它能够接着之前的位置继续执行呢？这时候不得不提&lt;strong&gt;上下文&lt;/strong&gt;的事。&lt;/p&gt;
&lt;p&gt;当程序&lt;code&gt;A&lt;/code&gt;（假设为单进程）放弃&lt;code&gt;CPU&lt;/code&gt;的时候，需要保存当前的上下文，**何为上下文？**也就是除了&lt;code&gt;CPU&lt;/code&gt;之外，寄存器或者其他的状态，就跟犯罪现场一样，需要拍个照，要不到时候别的程序执行完之后，怎么知道接下来怎么执行程序&lt;code&gt;A&lt;/code&gt;，之前执行到哪一步了。&lt;strong&gt;总结一句话：保存当前程序的执行状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上下文切换一般还涉及缓存的开销，也就是缓存会失效，一般执行的时候，CPU会缓存一些数据方便下次更快的执行，一旦进行上下文切换，原来的缓存就失效了，需要重新缓存。&lt;/p&gt;
&lt;p&gt;调度一般有两种（一般是按照线程维度来调度）,&lt;code&gt;CPU&lt;/code&gt;的时间被分为特别小的时间片：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分时调度：每个线程或者进程轮流的使用&lt;code&gt;CPU&lt;/code&gt;，平均时间分配到每个线程或者进程。&lt;/li&gt;
&lt;li&gt;抢占式调度：优先级高的线程/进程立即抢占下一个时间片，如果优先级相同，那么随机选择一个进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;时间片超级短，CPU超级快，给我们无比丝滑的感觉，就像是多个任务在同时进行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们现在操作系统或者其他的系统，基本都是抢占式调度，为什么？&lt;/p&gt;
&lt;p&gt;因为如果使用分时调度，很难做到实时响应，当后台的聊天程序在进行网络传输的时候，分配予它的时间片还没有使用完，那我点击浏览器，是没有办法实时响应的。除此之外，如果前面的进程挂了，但是一直占有&lt;code&gt;CPU&lt;/code&gt;，那么后面的任务将永远得不到执行。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;CPU&lt;/code&gt;的处理能力超级快，就算是单核的&lt;code&gt;CPU&lt;/code&gt;，运行着多个程序，多个进程，经过抢占式的调度，每一个程序使用的时候都像是独享了&lt;code&gt;CPU&lt;/code&gt;一样顺滑。进程有效的提高了&lt;code&gt;CPU&lt;/code&gt;的使用率，但是进程在上下文切换的时候是存在着一定的成本的。&lt;/p&gt;
&lt;h2 id=&#34;线程和进程什么关系&#34;&gt;线程和进程什么关系？&lt;/h2&gt;
&lt;p&gt;前面说了进程，那有了进程，为啥还要线程，多个应用程序，假设我们每个应用程序要做&lt;code&gt;n&lt;/code&gt;件事，就用&lt;code&gt;n&lt;/code&gt;个进程不行么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以，但是没必要。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程一般由程序，数据集合和进程控制块组成，同一个应用程序一般是需要使用同一个数据空间的，要是一个应用程序搞很多个进程，就算有能力做到数据空间共享，进程的上下文切换都会消耗很多资源。（一般一个应用程序不会有很多进程，大多数一个，少数有几个）&lt;/p&gt;
&lt;p&gt;进程的颗粒度比较大，每次执行都需要上下文切换，如果同一个程序里面的代码段&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，做不一样的东西，如果分给多个进程去处理，那么每次执行都有切换进程上下文。这太惨了。&lt;strong&gt;一个应用程序的任务是一家人，住在同一个屋子下（同一个内存空间），有必要每个房间都当成每一户，去派出所登记成一个户口么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;信息共享难，空间独立&lt;/li&gt;
&lt;li&gt;切换需要&lt;code&gt;fork()&lt;/code&gt;，切换上下文，开销大&lt;/li&gt;
&lt;li&gt;只能在一个时间点做一件事&lt;/li&gt;
&lt;li&gt;如果进程阻塞了，要等待网络传过来数据，那么其他不依赖这个数据的任务也做不了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是有人会说，那我一个应用程序有很多事情要做，总不能只用一个进程，所有事情都等着它来处理啊？那不是会阻塞住么？&lt;/p&gt;
&lt;p&gt;确实啊，单独一个进程处理不了问题，那么我们&lt;strong&gt;把进程分得更小&lt;/strong&gt;，里面分成很多线程，一家人，每个人都有自己的事情做，那我们每个人就是一个线程，一家人就是一个进程，这样岂不是更好么？&lt;/p&gt;
&lt;p&gt;进程是描述CPU时间片调度的时间片段，但是线程是更细小的时间片段，两者的颗粒度不一样。&lt;strong&gt;线程可以称为轻量级的进程&lt;/strong&gt;。其实，线程也不是一开始就有的概念，而是随着计算机发展，对多个任务上下文切换要求越来越高，随之抽象出来的概念。&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;进&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;间&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;段&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;加&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;载&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;下&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;间&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;间&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;保&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;存&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;下&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;间&lt;/mi&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;线&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;间&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;段&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;加&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;载&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;线&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;下&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;间&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;间&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;保&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;存&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;线&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;下&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;间&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;进程时间段 = CPU加载程序上下文的时间 + CPU执行时间 + CPU保存程序上下文的时间\\
线程时间段 = CPU加载线程上下文的时间 + CPU执行时间 + CPU保存线程上下文的时间
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;进&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;程&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;间&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;段&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.76666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;加&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;载&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;程&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;序&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;下&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;间&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.76666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;执&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;间&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;保&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;存&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;程&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;序&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;下&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;间&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;线&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;程&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;间&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;段&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.76666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;加&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;载&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;线&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;程&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;下&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;间&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.76666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;执&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;间&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;保&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;存&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;线&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;程&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;上&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;下&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;文&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最重要的是，进程切换上下文的时间远比线程切换上下文的时间成本要高&lt;/strong&gt;，如果是同一个进程的不同线程之间抢占到&lt;code&gt;CPU&lt;/code&gt;，切换成本会比较低，因为他们&lt;strong&gt;共享了进程的地址空间&lt;/strong&gt;，线程间的通信容易很多，通过共享进程级全局变量即可实现。&lt;/p&gt;
&lt;p&gt;况且，现在多核的处理器，让不同进程在不同核上跑，进程内的线程在同个核上做切换，尽量减少（不可以避免）进程的上下文切换，或者让不同线程跑在不同的处理器上，进一步提高效率。&lt;/p&gt;
&lt;p&gt;进程和线程的模型如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210509163642149.png&#34; alt=&#34;image-20210509163642149&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;线程和进程的区别或者优点&#34;&gt;线程和进程的区别或者优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;线程是程序执行的最小单位，进程是操作系统分配资源的最小单位。&lt;/li&gt;
&lt;li&gt;一个应用可能多个进程，一个进程由一个或者多个线程组成&lt;/li&gt;
&lt;li&gt;进程相互独立，通信或者沟通成本高，在同一个进程下的线程共享进程的内存等，相互之间沟通或者协作成本低。&lt;/li&gt;
&lt;li&gt;线程切换上下文比进程切换上下文要快得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程有哪些状态&#34;&gt;线程有哪些状态&lt;/h2&gt;
&lt;p&gt;现在我们所说的是&lt;code&gt;Java&lt;/code&gt;中的线程&lt;code&gt;Thread&lt;/code&gt;,一个线程在一个给定的时间点，只能处于一种状态，这些状态都是虚拟机的状态，不能反映任何操作系统的线程状态，一共有六种/七种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NEW&lt;/code&gt;：创建了线程对象，但是还没有调用&lt;code&gt;Start()&lt;/code&gt;方法，还没有启动的线程处于这种状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Running&lt;/code&gt;：运行状态，其实包含了两种状态，但是&lt;code&gt;Java&lt;/code&gt;线程将就绪和运行中统称为可运行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Runnable&lt;/code&gt;：就绪状态：创建对象后，调用了&lt;code&gt;start()&lt;/code&gt;方法，该状态的线程还位于可运行线程池中，等待调度，获取&lt;code&gt;CPU&lt;/code&gt;的使用权
&lt;ul&gt;
&lt;li&gt;只是有资格执行，不一定会执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start()&lt;/code&gt;之后进入就绪状态，&lt;code&gt;sleep()&lt;/code&gt;结束或者&lt;code&gt;join()&lt;/code&gt;结束，线程获得对象锁等都会进入该状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt;时间片结束或者主动调用&lt;code&gt;yield()&lt;/code&gt;方法，也会进入该状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Running&lt;/code&gt; ：获取到&lt;code&gt;CPU&lt;/code&gt;的使用权（获得CPU时间片），变成运行中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BLOCKED&lt;/code&gt; ：阻塞，线程阻塞于锁，等待监视器锁，一般是&lt;code&gt;Synchronize&lt;/code&gt;关键字修饰的方法或者代码块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;WAITING&lt;/code&gt; ：进入该状态，需要等待其他线程通知（&lt;code&gt;notify&lt;/code&gt;）或者中断，一个线程无限期地等待另一个线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt; ：超时等待，在指定时间后自动唤醒，返回，不会一直等待&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TERMINATED&lt;/code&gt; ：线程执行完毕，已经退出。如果已终止再调用start()，将会抛出&lt;code&gt;java.lang.IllegalThreadStateException&lt;/code&gt;异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210509224848865.png&#34; alt=&#34;image-20210509224848865&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到&lt;code&gt;Thread.java&lt;/code&gt;里面有一个&lt;code&gt;State&lt;/code&gt;枚举类，枚举了线程的各种状态(&lt;code&gt;Java&lt;/code&gt;线程将&lt;strong&gt;就绪&lt;/strong&gt;和&lt;strong&gt;运行中&lt;/strong&gt;统称为&lt;strong&gt;可运行&lt;/strong&gt;)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public enum State {
    /**
     * 尚未启动的线程的线程状态。
     */
    NEW,

    /**
     * 可运行线程的线程状态，一个处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待来自操作系统(如处理器)的其他资源。
     */
    RUNNABLE,

    /**
     * 等待监视器锁而阻塞的线程的线程状态。
     * 处于阻塞状态的线程正在等待一个监视器锁进入一个同步的块/方法，或者在调用Oject.wait()方法之后重新进入一个同步代码块
     */
    BLOCKED,

    /**
     * 等待线程的线程状态，线程由于调用其中一个线程而处于等待状态
     */
    WAITING,

    /**
     * 具有指定等待时间的等待线程的线程状态，线程由于调用其中一个线程而处于定时等待状态。
     */
    TIMED_WAITING,

    /**
     * 终止线程的线程状态，线程已经完成执行。
     */
    TERMINATED;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除此之外，Thread类还有一些属性是和线程对象有关的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;long tid：线程序号&lt;/li&gt;
&lt;li&gt;char name[]：线程名称&lt;/li&gt;
&lt;li&gt;int priority：线程优先级&lt;/li&gt;
&lt;li&gt;boolean daemon：是否守护线程&lt;/li&gt;
&lt;li&gt;Runnable target：线程需要执行的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;介绍一下上面图中讲解到线程的几个重要方法，它们都会导致线程的状态发生一些变化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Thread.sleep(long)&lt;/code&gt;:调用之后，线程进入&lt;code&gt;TIMED_WAITING&lt;/code&gt;状态，但是不会释放对象锁，到时间苏醒后进入&lt;code&gt;Runnable&lt;/code&gt;就绪状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Thread.yield()&lt;/code&gt;:线程调用该方法，表示放弃获取的&lt;code&gt;CPU&lt;/code&gt;时间片，但是不会释放锁资源，同样变成就绪状态，等待重新调度，不会阻塞，但是也不能保证一定会让出&lt;code&gt;CPU&lt;/code&gt;，很可能又被重新选中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;thread.join(long)&lt;/code&gt;:当前线程调用其他线程&lt;code&gt;thread&lt;/code&gt;的&lt;code&gt;join()&lt;/code&gt;方法，当前线程不会释放锁，会进入&lt;code&gt;WAITING&lt;/code&gt;或者&lt;code&gt;TIMED_WAITING&lt;/code&gt;状态，等待thread执行完毕或者时间到，当前线程进入就绪状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object.wait(long)&lt;/code&gt;:当前线程调用对象的&lt;code&gt;wait()&lt;/code&gt;方法，当前线程会释放获得的对象锁，进入等待队列，&lt;code&gt;WAITING&lt;/code&gt;，等到时间到或者被唤醒。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object.notify()&lt;/code&gt;：唤醒在该对象监视器上等待的线程，随机挑一个&lt;/li&gt;
&lt;li&gt;&lt;code&gt;object.notifyAll()&lt;/code&gt;：唤醒在该对象监视器上等待的所有线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;单线程和多线程&#34;&gt;单线程和多线程&lt;/h2&gt;
&lt;p&gt;单线程，就是只有一条线程在执行任务，串行的执行，而多线程，则是多条线程同时执行任务，所谓同时，并不是一定真的同时，如果在单核的机器上，就是假同时，只是看起来同时，实际上是轮流占据CPU时间片。&lt;/p&gt;
&lt;p&gt;下面的每一个格子是一个时间片（每一个时间片实际上超级无敌短），不同的线程其实可以抢占不同的时间片，获得执行权。&lt;strong&gt;时间片分配的单位是线程，而不是进程，进程只是容器&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210511002923132.png&#34; alt=&#34;image-20210511002923132&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;如何启动一个线程&#34;&gt;如何启动一个线程&lt;/h3&gt;
&lt;p&gt;其实&lt;code&gt;Java&lt;/code&gt;的&lt;code&gt;main()&lt;/code&gt;方法本质上就启动了一个线程，但是&lt;strong&gt;本质上不是只有一个线程&lt;/strong&gt;，看结果的 5 就大致知道，其实一共有 5 个线程，主线程是第 5 个,大多是&lt;strong&gt;后台线程&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Thread[main,5,main]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出上面的线程是&lt;code&gt;main&lt;/code&gt;线程，但是要想创建出有别于&lt;code&gt;main&lt;/code&gt;线程的方式，有四种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义类去实现&lt;code&gt;Runnable&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;继承&lt;code&gt;Thread&lt;/code&gt;类，重写&lt;code&gt;run()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;Callable&lt;/code&gt;和&lt;code&gt;FutureTask&lt;/code&gt;创建线程&lt;/li&gt;
&lt;li&gt;线程池直接启动（本质上不算是）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;实现runnable接口&#34;&gt;实现Runnable接口&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyThread implements Runnable{
    @Override
    public void run(){
        System.out.println(&amp;quot;Hello world&amp;quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyThread());
        thread.start();
        System.out.println(&amp;quot;Main Thread&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Main Thread
Hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果看底层就可以看到，构造函数的时候，我们将&lt;code&gt;Runnable&lt;/code&gt;的实现类对象传递进入,会将&lt;code&gt;Runnable&lt;/code&gt;实现类对象保存下来：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public Thread(Runnable target) {
        this(null, target, &amp;quot;Thread-&amp;quot; + nextThreadNum(), 0);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后再调用&lt;code&gt;start()&lt;/code&gt;方法的时候,会调用原生的&lt;code&gt;start0()&lt;/code&gt;方法，原生方法是由&lt;code&gt;c&lt;/code&gt;或者&lt;code&gt;c++&lt;/code&gt;写的,这里看不到具体的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    public synchronized void start() {
        if (threadStatus != 0)
            throw new IllegalThreadStateException();
        group.add(this);
        boolean started = false;
        try {
          	// 正式的调用native原生方法
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Start0()&lt;/code&gt;在底层确实调用了&lt;code&gt;run()&lt;/code&gt;方法，并且不是直接调用的，而是启用了另外一个线程进行调用的，这一点在代码注释里面写得比较清楚，在这里我们就不展开讲，我们将关注点放到&lt;code&gt;run()&lt;/code&gt;方法上，调用的就是刚刚那个&lt;code&gt;Runnable&lt;/code&gt;实现类的对象的&lt;code&gt;run()&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    @Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;继承thread类&#34;&gt;继承Thread类&lt;/h4&gt;
&lt;p&gt;由于&lt;code&gt;Thread&lt;/code&gt;类本身就实现了&lt;code&gt;Runnable&lt;/code&gt;接口，所以我们只要继承它就可以了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Thread implements Runnable {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;继承之后重写run()方法即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyThread extends Thread{
    @Override
    public void run(){
        System.out.println(&amp;quot;Hello world&amp;quot;);
    }
}
public class Test {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyThread());
        thread.start();
        System.out.println(&amp;quot;Main Thread&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果和上面的一样，其实两种方式本质上都是一样的，一个是实现了&lt;code&gt;Runnable&lt;/code&gt;接口，另外一个是继承了实现了&lt;code&gt;Runnable&lt;/code&gt;接口的&lt;code&gt;Thread&lt;/code&gt;类。两种都没有返回值，因为&lt;code&gt;run()&lt;/code&gt;方法的返回值是&lt;code&gt;void&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;callable和futuretask创建线程&#34;&gt;Callable和FutureTask创建线程&lt;/h4&gt;
&lt;p&gt;要使用该方式，按照以下步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;Callable&lt;/code&gt;接口的实现类，实现&lt;code&gt;call()&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;Callable&lt;/code&gt;实现类的对象实例，用&lt;code&gt;FutureTask&lt;/code&gt;包装Callable的实现类实例，包装成&lt;code&gt;FutureTask&lt;/code&gt;的实例，&lt;code&gt;FutureTask&lt;/code&gt;的实例封装了&lt;code&gt;Callable&lt;/code&gt;对象的&lt;code&gt;Call()&lt;/code&gt;方法的返回值&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;FutureTask&lt;/code&gt;对象作为&lt;code&gt;Thread&lt;/code&gt;对象的&lt;code&gt;target&lt;/code&gt;创建并启动线程，&lt;code&gt;FutureTask&lt;/code&gt;实现了&lt;code&gt;RunnableFuture&lt;/code&gt;，&lt;code&gt;RunnableFuture&lt;/code&gt;继承了&lt;code&gt;Runnable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;FutureTask&lt;/code&gt;对象的&lt;code&gt;get()&lt;/code&gt;来获取子线程执行结束的返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class CallableTest {
    public static void main(String[] args) throws Exception{

        Callable&amp;lt;String&amp;gt; callable = new MyCallable&amp;lt;String&amp;gt;();
        FutureTask&amp;lt;String&amp;gt; task = new FutureTask&amp;lt;String&amp;gt;(callable);

        Thread thread = new Thread(task);
        thread.start();

        System.out.println(Thread.currentThread().getName());
        System.out.println(task.get());

    }
}

class MyCallable&amp;lt;String&amp;gt; implements Callable&amp;lt;String&amp;gt; {
    @Override
    public String call() throws Exception {
        System.out.println(
                Thread.currentThread().getName() +
                        &amp;quot; Callable Thread&amp;quot;);
        return (String) &amp;quot;Hello&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;main
Thread-0 Callable Thread
Hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实这种方式本质上也是&lt;code&gt;Runnable&lt;/code&gt;接口来实现的，只不过做了一系列的封装，但是不同的是，它可以实现返回值，如果我们期待一件事情可以通过另外一个线程来获取结果，但是可能需要消耗一些时间，比如异步网络请求，其实可以考虑这种方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Callable&lt;/code&gt;和&lt;code&gt;FutureTask&lt;/code&gt;是后面才加入的功能，是为了适应多种并发场景，&lt;code&gt;Callable&lt;/code&gt;和&lt;code&gt;Runnable&lt;/code&gt;的区别如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt; 定义方法是&lt;code&gt;call()&lt;/code&gt;，&lt;code&gt;Runnable&lt;/code&gt;定义的方法是&lt;code&gt;run()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt;的&lt;code&gt;call()&lt;/code&gt;方法有返回值，&lt;code&gt;Runnable&lt;/code&gt;的&lt;code&gt;run()&lt;/code&gt;方法没有返回值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt;的&lt;code&gt;call()&lt;/code&gt;方法可以抛出异常，&lt;code&gt;Runnable&lt;/code&gt;的&lt;code&gt;run()&lt;/code&gt;方法不能抛出异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;线程池启动线程&#34;&gt;线程池启动线程&lt;/h4&gt;
&lt;p&gt;本质上也是通过实现&lt;code&gt;Runnable&lt;/code&gt;接口，然后放到线程池中进行执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &amp;quot; : hello world&amp;quot;);
    }
}

public class Test {
    public static void main(String[] args) throws InterruptedException {
        ExecutorService executorService = Executors.newFixedThreadPool(5);
        for (int i = 0; i &amp;lt; 10; i++) {
            MyThread thread = new MyThread();
            executorService.execute(thread);
        }
        executorService.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果如下，可以看到五个核心线程一直在执行，没有规律，循环十次，但是并没有创建出十个线程，这和线程池的设计以及参数有关，后面会讲解：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;pool-1-thread-5 : hello world
pool-1-thread-4 : hello world
pool-1-thread-5 : hello world
pool-1-thread-3 : hello world
pool-1-thread-2 : hello world
pool-1-thread-1 : hello world
pool-1-thread-2 : hello world
pool-1-thread-3 : hello world
pool-1-thread-5 : hello world
pool-1-thread-4 : hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结一下，启动一个线程，其实本质上都离不开&lt;code&gt;Runnable&lt;/code&gt;接口，不管是继承还是实现接口。&lt;/p&gt;
&lt;h3 id=&#34;多线程可能带来的问题&#34;&gt;多线程可能带来的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;消耗资源：上下文切换，或者创建以及销毁线程，都是比较消耗资源的。&lt;/li&gt;
&lt;li&gt;竞态条件：多线程访问或者修改同一个对象，假设自增操作&lt;code&gt;num++&lt;/code&gt;，操作分为三步，读取&lt;code&gt;num&lt;/code&gt;，&lt;code&gt;num&lt;/code&gt;加1，写回&lt;code&gt;num&lt;/code&gt;，并非原子操作，那么多个线程之间交叉运行，就会产生不如预期的结果。&lt;/li&gt;
&lt;li&gt;内存的可见性：每个线程都有自己的内存（缓存），一般修改的值都放在自己线程的缓存上，到刷新至主内存有一定的时间，所以可能一个线程更新了，但是另外一个线程获取到的还是久的值，这就是不可见的问题。&lt;/li&gt;
&lt;li&gt;执行顺序难预知：线程先&lt;code&gt;start()&lt;/code&gt;不一定先执行，是由系统决定的，会导致共享的变量或者执行结果错乱&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;并发与并行&#34;&gt;并发与并行&lt;/h2&gt;
&lt;p&gt;并发是指两个或多个事件在同一时间间隔发生，比如在同&lt;code&gt;1s&lt;/code&gt;中内计算机不仅计算&lt;code&gt;数据1&lt;/code&gt;，同时也计算了&lt;code&gt;数据2&lt;/code&gt;。但是两件事情可能在某一个时刻，不是真的同时进行，很可能是抢占时间片就执行，抢不到就别人执行，但是由于时间片很短，所以在1s中内，看似是同时执行完成了。当然前面说的是单核的机器，并发不是真的同时执行，但是多核的机器上，并发也可能是真的在同时执行，只是有可能，这个时候的并发也叫做并行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210511012516227.png&#34; alt=&#34;image-20210511012516227&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;并行是指在同一时刻，有多条指令在多个处理器上同时执行，真正的在同时执行。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210511012723433.png&#34; alt=&#34;image-20210511012723433&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;如果是单核的机器，最多只能并发，不可能并行处理，只能把CPU运行时间分片，分配给各个线程执行，执行不同的线程任务的时候需要上下文切换。而多核机器，可以做到真的并行，同时在多个核上计算，运行。&lt;strong&gt;并行操作一定是并发的，但是并发的操作不一定是并行的。&lt;/strong&gt;&lt;/p&gt;
">线程池那些事上篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/ru-he-she-ji-yi-ge-xian-cheng-chi/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;blockquote&gt;
&lt;p&gt;前一段时间在写一门算法课，总算是上线了，以及面试，所以没什么时间写，接下来的时间，应该会讲讲面试准备，刷题的一些东西，面了很多，通过面试的有平安，涂鸦智能，阿里，腾讯微保，虾皮，华为荣耀，微众，当然也有其他不少挂的，挂也正常，面试是一个双向选择，当然，我也还是个菜鸟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;blockquote&gt;
&lt;p&gt;以前，我总觉得的买一件东西，做一件事，或者从某一个时间节点开始，我的生命就会发生转折，一切就会无比顺利，立马变厉害。但是，事实上并不是如此。我不可能马上变厉害，也不可能一口吃成一个胖子。看一篇文章也不能让你从此走上人生巅峰，越来越相信，这是一个长期的过程，只有量变引起质变，纵使缓慢，驰而不息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;如何设计一个线程池&#34;&gt;如何设计一个线程池？&lt;/h1&gt;
&lt;h2 id=&#34;三个步骤&#34;&gt;三个步骤&lt;/h2&gt;
&lt;p&gt;这是一个常见的问题，如果在比较熟悉线程池运作原理的情况下，这个问题并不难。设计实现一个东西，三步走：是什么？为什么？怎么做？&lt;/p&gt;
&lt;h3 id=&#34;线程池是什么&#34;&gt;线程池是什么？&lt;/h3&gt;
&lt;p&gt;线程池使用了池化技术，将线程存储起来放在一个 &amp;quot;池子&amp;quot;（容器）里面，来了任务可以用已有的空闲的线程进行处理， 处理完成之后，归还到容器，可以复用。如果线程不够，还可以根据规则动态增加，线程多余的时候，亦可以让多余的线程死亡。&lt;/p&gt;
&lt;h3 id=&#34;为什么要用线程池&#34;&gt;为什么要用线程池？&lt;/h3&gt;
&lt;p&gt;实现线程池有什么好处呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低资源消耗：池化技术可以重复利用已经创建的线程，降低线程创建和销毁的损耗。&lt;/li&gt;
&lt;li&gt;提高响应速度：利用已经存在的线程进行处理，少去了创建线程的时间&lt;/li&gt;
&lt;li&gt;管理线程可控：线程是稀缺资源，不能无限创建，线程池可以做到统一分配和监控&lt;/li&gt;
&lt;li&gt;拓展其他功能：比如定时线程池，可以定时执行任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;需要考虑的点&#34;&gt;需要考虑的点&lt;/h3&gt;
&lt;p&gt;那线程池设计需要考虑的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程池状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有哪些状态？如何维护状态？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程怎么封装？线程放在哪个池子里？&lt;/li&gt;
&lt;li&gt;线程怎么取得任务？&lt;/li&gt;
&lt;li&gt;线程有哪些状态？&lt;/li&gt;
&lt;li&gt;线程的数量怎么限制？动态变化？自动伸缩？&lt;/li&gt;
&lt;li&gt;线程怎么消亡？如何重复利用？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务少可以直接处理，多的时候，放在哪里？&lt;/li&gt;
&lt;li&gt;任务队列满了，怎么办？&lt;/li&gt;
&lt;li&gt;用什么队列？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果从任务的阶段来看，分为以下几个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何存任务？&lt;/li&gt;
&lt;li&gt;如何取任务？&lt;/li&gt;
&lt;li&gt;如何执行任务？&lt;/li&gt;
&lt;li&gt;如何拒绝任务？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程池状态&#34;&gt;线程池状态&lt;/h2&gt;
&lt;h3 id=&#34;状态有哪些如何维护状态&#34;&gt;状态有哪些？如何维护状态？&lt;/h3&gt;
&lt;p&gt;状态可以设置为以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RUNNING：运行状态，可以接受任务，也可以处理任务&lt;/li&gt;
&lt;li&gt;SHUTDOWN：不可以接受任务，但是可以处理任务&lt;/li&gt;
&lt;li&gt;STOP：不可以接受任务，也不可以处理任务，中断当前任务&lt;/li&gt;
&lt;li&gt;TIDYING：所有线程停止&lt;/li&gt;
&lt;li&gt;TERMINATED：线程池的最后状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各种状态之间是不一样的，他们的状态之间变化如下：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619211431.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;而维护状态的话，可以用一个变量单独存储，并且需要保证修改时的&lt;strong&gt;原子性&lt;/strong&gt;，在底层操作系统中，对int的修改是原子的，而在32位的操作系统里面，对&lt;code&gt;double&lt;/code&gt;,&lt;code&gt;long&lt;/code&gt;这种64位数值的操作不是原子的。&lt;strong&gt;除此之外，实际上JDK里面实现的状态和线程池的线程数是同一个变量，高3位表示线程池的状态，而低29位则表示线程的数量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样设计的好处是节省空间，并且同时更新的时候有优势。&lt;/p&gt;
&lt;h2 id=&#34;线程相关&#34;&gt;线程相关&lt;/h2&gt;
&lt;h3 id=&#34;线程怎么封装线程放在哪个池子里&#34;&gt;线程怎么封装？线程放在哪个池子里？&lt;/h3&gt;
&lt;p&gt;线程，即是实现了&lt;code&gt;Runnable&lt;/code&gt;接口，执行的时候，调用的是&lt;code&gt;start()&lt;/code&gt;方法，但是&lt;code&gt;start()&lt;/code&gt;方法内部编译后调用的是 &lt;code&gt;run()&lt;/code&gt; 方法，这个方法只能调用一次，调用多次会报错。因此线程池里面的线程跑起来之后，不可能终止再启动，只能一直运行着。&lt;strong&gt;既然不可以停止，那么执行完任务之后，没有任务过来，只能是轮询取出任务的过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程可以运行任务，因此封装线程的时候，假设封装成为 &lt;code&gt;Worker&lt;/code&gt;, &lt;code&gt;Worker&lt;/code&gt;里面必定是包含一个 &lt;code&gt;Thread&lt;/code&gt;,表示当前线程，除了当前线程之外，封装的线程类还应该持有任务，初始化可能直接给予任务，当前的任务是null的时候才需要去获取任务。&lt;/p&gt;
&lt;p&gt;可以考虑使用 &lt;code&gt;HashSet&lt;/code&gt; 来存储线程，也就是充当线程池的角色，当然，&lt;code&gt;HashSet&lt;/code&gt; 会有线程安全的问题需要考虑，那么我们可以考虑使用一个可重入锁比如 &lt;code&gt;ReentrantLock&lt;/code&gt;，凡是增删线程池的线程，都需要锁住。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private final ReentrantLock mainLock = new ReentrantLock();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;线程怎么取得任务&#34;&gt;线程怎么取得任务？&lt;/h3&gt;
&lt;p&gt;（1）初始化线程的时候可以直接指定任务，譬如&lt;code&gt;Runnable firstTask&lt;/code&gt;，将任务封装到 &lt;code&gt;worker&lt;/code&gt; 中，然后获取 &lt;code&gt;worker&lt;/code&gt; 里面的 &lt;code&gt;thread&lt;/code&gt;，&lt;code&gt;thread.run()&lt;/code&gt;的时候，其实就是 跑的是 &lt;code&gt;worker&lt;/code&gt; 本身的 &lt;code&gt;run()&lt;/code&gt; 方法，因为 &lt;code&gt;worker&lt;/code&gt; 本身就是实现了 &lt;code&gt;Runnable&lt;/code&gt; 接口，里面的线程其实就是其本身。因此也可以实现对 &lt;code&gt;ThreadFactory&lt;/code&gt; 线程工厂的定制化。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;    private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {
        final Thread thread;
        Runnable firstTask;

        ...

        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            // 从线程池创建线程，传入的是其本身
            this.thread = getThreadFactory().newThread(this);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;（2）运行完任务的线程，应该继续取任务，取任务肯定需要从任务队列里面取，要是任务队列里面没有任务，由于是阻塞队列，那么可以等待，如果等待若干时间后，仍没有任务，倘若该线程池的线程数已经超过核心线程数，并且允许线程消亡的话，应该将该线程从线程池中移除，并结束掉该线程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;取任务和执行任务，对于线程池里面的线程而言，就是一个周而复始的工作，除非它会消亡。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;线程有哪些状态&#34;&gt;线程有哪些状态？&lt;/h3&gt;
&lt;p&gt;现在我们所说的是&lt;code&gt;Java&lt;/code&gt;中的线程&lt;code&gt;Thread&lt;/code&gt;,一个线程在一个给定的时间点，只能处于一种状态，这些状态都是虚拟机的状态，不能反映任何操作系统的线程状态，一共有六种/七种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;NEW&lt;/code&gt;：创建了线程对象，但是还没有调用&lt;code&gt;Start()&lt;/code&gt;方法，还没有启动的线程处于这种状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Running&lt;/code&gt;：运行状态，其实包含了两种状态，但是&lt;code&gt;Java&lt;/code&gt;线程将就绪和运行中统称为可运行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Runnable&lt;/code&gt;：就绪状态：创建对象后，调用了&lt;code&gt;start()&lt;/code&gt;方法，该状态的线程还位于可运行线程池中，等待调度，获取&lt;code&gt;CPU&lt;/code&gt;的使用权
&lt;ul&gt;
&lt;li&gt;只是有资格执行，不一定会执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start()&lt;/code&gt;之后进入就绪状态，&lt;code&gt;sleep()&lt;/code&gt;结束或者&lt;code&gt;join()&lt;/code&gt;结束，线程获得对象锁等都会进入该状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt;时间片结束或者主动调用&lt;code&gt;yield()&lt;/code&gt;方法，也会进入该状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Running&lt;/code&gt; ：获取到&lt;code&gt;CPU&lt;/code&gt;的使用权（获得CPU时间片），变成运行中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BLOCKED&lt;/code&gt; ：阻塞，线程阻塞于锁，等待监视器锁，一般是&lt;code&gt;Synchronize&lt;/code&gt;关键字修饰的方法或者代码块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;WAITING&lt;/code&gt; ：进入该状态，需要等待其他线程通知（&lt;code&gt;notify&lt;/code&gt;）或者中断，一个线程无限期地等待另一个线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt; ：超时等待，在指定时间后自动唤醒，返回，不会一直等待&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;TERMINATED&lt;/code&gt; ：线程执行完毕，已经退出。如果已终止再调用start()，将会抛出&lt;code&gt;java.lang.IllegalThreadStateException&lt;/code&gt;异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210509224848865.png&#34; alt=&#34;image-20210509224848865&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;线程的数量怎么限制动态变化自动伸缩&#34;&gt;线程的数量怎么限制？动态变化？自动伸缩？&lt;/h3&gt;
&lt;p&gt;线程池本身，就是为了限制和充分使用线程资的，因此有了两个概念：核心线程数，最大线程数。&lt;/p&gt;
&lt;p&gt;要想让线程数根据任务数量动态变化，那么我们可以考虑以下设计（假设不断有任务）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来一个任务创建一个线程处理，直到线程数达到核心线程数。&lt;/li&gt;
&lt;li&gt;达到核心线程数之后且没有空闲线程，来了任务直接放到任务队列。&lt;/li&gt;
&lt;li&gt;任务队列如果是无界的，会被撑爆。&lt;/li&gt;
&lt;li&gt;任务队列如果是有界的，任务队列满了之后，还有任务过来，会继续创建线程处理，此时线程数大于核心线程数，直到线程数等于最大线程数。&lt;/li&gt;
&lt;li&gt;达到最大线程数之后，还有任务不断过来，会触发拒绝策略，根据不同策略进行处理。&lt;/li&gt;
&lt;li&gt;如果任务不断处理完成，任务队列空了，线程空闲没任务，会在一定时间内，销毁，让线程数保持在核心线程数即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由上面可以看出，主要控制伸缩的参数是&lt;code&gt;核心线程数&lt;/code&gt;，&lt;code&gt;最大线程数&lt;/code&gt;,&lt;code&gt;任务队列&lt;/code&gt;,&lt;code&gt;拒绝策略&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;线程怎么消亡如何重复利用&#34;&gt;线程怎么消亡？如何重复利用？&lt;/h3&gt;
&lt;p&gt;线程不能被重新调用多次&lt;code&gt;start()&lt;/code&gt;，因此只能调用一次，也就是线程不可能停下来，再启动。那么就说明线程复用只是在不断的循环罢了。&lt;/p&gt;
&lt;p&gt;消亡只是结束了它的&lt;code&gt;run()&lt;/code&gt;方法，当线程池数量需要自动缩容的，就会让一部分空闲的线程结束。&lt;/p&gt;
&lt;p&gt;而重复利用，其实是执行完任务之后，再去去任务队列取任务，取不到任务会等待，任务队列是一个阻塞队列，这是一个&lt;code&gt;不断循环&lt;/code&gt;的过程。&lt;/p&gt;
&lt;h2 id=&#34;任务相关&#34;&gt;任务相关&lt;/h2&gt;
&lt;h3 id=&#34;任务少可以直接处理多的时候放在哪里&#34;&gt;任务少可以直接处理，多的时候，放在哪里？&lt;/h3&gt;
&lt;p&gt;任务少的时候，来了直接创建，赋予线程初始化任务，就可开始执行，任务多的时候，把它放进队列里面，先进先出。&lt;/p&gt;
&lt;h3 id=&#34;任务队列满了怎么办&#34;&gt;任务队列满了，怎么办？&lt;/h3&gt;
&lt;p&gt;任务队列满了，会继续增加线程，直到达到最大的线程数。&lt;/p&gt;
&lt;h3 id=&#34;用什么队列&#34;&gt;用什么队列？&lt;/h3&gt;
&lt;p&gt;一般的队列，只是一个有限长度的缓冲区，要是满了，就不能保存当前的任务，阻塞队列可以通过阻塞，保留出当前需要入队的任务，只是会阻塞等待。同样的，阻塞队列也可以保证任务队列没有任务的时候，阻塞当前获取任务的线程，让它进入&lt;code&gt;wait&lt;/code&gt;状态，释放&lt;code&gt;cpu&lt;/code&gt;的资源。因此在线程池的场景下，阻塞队列其实是比较有必要的。&lt;/p&gt;
">如何设计一个线程池？</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/wu-liao-yong-java-xie-liao-ge-sao-lei/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;p&gt;周末无聊，用&lt;code&gt;Java&lt;/code&gt;写了一个扫雷程序，说起来，这个应该是在学校的时候，写会比较好玩，毕竟自己实现一个小游戏，还是比较好玩的。说实话，扫雷程序里面核心的东西，只有点击的时候，去触发更新数据这一步。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;Swing 是过时了，但是好玩不会过时，不喜勿喷&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211229084104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;源码的地址：https://github.com/Damaer/Game/tree/main/SweepMine&lt;/p&gt;
&lt;p&gt;下面讲讲里面的设计：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构设计&lt;/li&gt;
&lt;li&gt;视图和数据尽可能分开&lt;/li&gt;
&lt;li&gt;点击时候使用&lt;code&gt;BFS&lt;/code&gt;扫描&lt;/li&gt;
&lt;li&gt;判断成功失败&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据结构设计&#34;&gt;数据结构设计&lt;/h1&gt;
&lt;p&gt;在这个程序里面，为了方便，使用了全局的数据类&lt;code&gt;Data&lt;/code&gt;类来维护整个游戏的数据，直接设置为静态变量，也就是一次只能有一个游戏窗口运行，否则会有数据安全问题。（仅仅是为了方便）&lt;/p&gt;
&lt;p&gt;有以下的数据(部分代码)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Data {
    // 游戏状态
    public static Status status = Status.LOADING;
    // 雷区大小
    public static int size = 16;
    // 雷的数量
    public static int numOfMine = 0;
    // 表示是否有雷，1：有，0没有
    public static int[][] maps = null;
    // 是否被访问
    public static boolean[][] visited = null;
    // 周边雷的数量
    public static int[][] nums = null;
    // 是否被标记
    public static boolean[][] flags = null;
    // 上次被访问的块坐标
    public static Point lastVisitedPoint = null;
    // 困难模式
    private static DifficultModeEnum mode;
  	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要维护的数据如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏状态：是否开始，结束，成功，失败等等&lt;/li&gt;
&lt;li&gt;模式：简单，中等或者困难，这个会影响自动生成的雷的数量&lt;/li&gt;
&lt;li&gt;雷区的大小：16*16的小方块&lt;/li&gt;
&lt;li&gt;雷的数量：与模式选择有关，是个随机数&lt;/li&gt;
&lt;li&gt;标识每个方块是否有雷：最基础的数据，生成之后需要同步更新这个数据&lt;/li&gt;
&lt;li&gt;标识每个方块是否被扫过：默认没有扫过&lt;/li&gt;
&lt;li&gt;每个方块周边类雷的数量：生成的时候同步计算该结果，不想每次点击后再计算，毕竟是个不会更新的数据，一劳永逸&lt;/li&gt;
&lt;li&gt;标识方块是否被标记：扫雷的时候我们使用小旗子标记方块，表示这里是雷，标识完所有的雷的时候，成功&lt;/li&gt;
&lt;li&gt;上次访问的方块坐标：这个其实可以不记录，但是为了表示爆炸效果，与其他的雷展示不一样，故而记录下来&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;视图与数据分开&#34;&gt;视图与数据分开&lt;/h1&gt;
&lt;p&gt;尽量遵循一个原则，视图与数据或者数据变更分开，方便维护。我们知道&lt;code&gt;Java&lt;/code&gt;里面是用&lt;code&gt;Swing&lt;/code&gt;来画图形界面，这个东西确实难画，视图写得比较复杂但是画不出什么东西。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211229090112.gif&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;视图与数据分开，也是几乎所有框架的优秀特点，主要是方便维护，如果视图和数据糅合在一起，更新数据，还要操作视图，那就会比较乱。（当然我写的是粗糙版本，只是简单区分了一下）&lt;/p&gt;
&lt;p&gt;在这个扫雷程序里面基本都是点击事件，触发了数据变更，数据变更后，调用视图刷新，视图渲染的逻辑与数据变更的逻辑分开维护。&lt;/p&gt;
&lt;p&gt;每个小方块都添加了点击事件,&lt;code&gt;Data.visit(x, y)&lt;/code&gt;是数据刷新，&lt;code&gt;repaintBlocks()&lt;/code&gt;是刷新视图，具体的代码就不放了，有兴趣可以&lt;code&gt;Github&lt;/code&gt;看看源代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;new MouseListener() {
                    @Override
                    public void mouseClicked(MouseEvent e) {
                        if (Data.status == Status.GOING) {
                            int c = e.getButton(); // 得到按下的鼠标键
                            Block block = (Block) e.getComponent();
                            int x = block.getPoint_x();
                            int y = block.getPoint_y();
                            if (c == MouseEvent.BUTTON1) {
                                Data.visit(x, y);
                            } else if (c == MouseEvent.BUTTON3) {// 推断是鼠标右键按下
                                if (!Data.visited[x][y]) {
                                    Data.flags[x][y] = !Data.flags[x][y];
                                }
                            }
                        }
                        repaintBlocks();
                    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里很遗憾的一点是每个方块里面还有一个背景的``url`没有抽取出来，这个是变化的数据，不应该放在视图里面：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;public class Block extends JPanel {
    private int point_x;
    private int point_y;

    private String backgroundPath = ImgPath.DEFAULT;

    public Block(int x, int y) {
        this.point_x = x;
        this.point_y = y;
        setBorder(BorderFactory.createEtchedBorder());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新设置方块背景，需要居中处理，重新绘制，重写&lt;code&gt;void paintComponent(Graphics g)&lt;/code&gt;方法即可：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;    @Override
    protected void paintComponent(Graphics g) {
        refreshBackground();
        URL url = getClass().getClassLoader().getResource(backgroundPath);
        ImageIcon icon = new ImageIcon(url);
        if (backgroundPath.equals(ImgPath.DEFAULT) || backgroundPath.equals(ImgPath.FLAG)
                || backgroundPath.equals(String.format(ImgPath.NUM, 0))) {
            g.drawImage(icon.getImage(), 0, 0, getWidth(), getHeight(), this);
        } else {
            int x = (int) (getWidth() * 0.1);
            int y = (int) (getHeight() * 0.15);
            g.drawImage(icon.getImage(), x, y, getWidth() - 2 * x, getHeight() - 2 * y, this);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;bfs扫描&#34;&gt;BFS扫描&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;BFS&lt;/code&gt;，也称为广度优先搜索，这算是扫雷里面的核心知识点，也就是点击的时候，如果当前方块是空的，那么就会触发扫描周边的方块，同时周边方块如果也是空的，会继续递归下去，我用了广度优先搜索，也就是先将它们放到队列里面，取出来，再判断是否为空，再将周边符合的方块添加进去，进行一一处理。&lt;/p&gt;
&lt;p&gt;广度优先搜索在这里不展开，其本质是优先搜索与其直接关联的数据，也就是方块周围的点，这也是为什么需要队列的原因，我们需要队列来保存遍历的顺序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;    public static void visit(int x, int y) {
        lastVisitedPoint.x = x;
        lastVisitedPoint.y = y;
        if (maps[x][y] == 1) {
            status = Status.FAILED;
            // 游戏结束，暴露所有的雷
        } else {
            // 点击的不是雷
            Queue&amp;lt;Point&amp;gt; points = new LinkedList&amp;lt;&amp;gt;();
            points.add(new Point(x, y));
            while (!points.isEmpty()) {
                Point point = points.poll();
                visited[point.x][point.y] = true;
                if (nums[point.x][point.y] == 0) {
                    addToVisited(points, point.x, point.y);
                }
            }
        }
    }

    public static void addToVisited(Queue&amp;lt;Point&amp;gt; points, int i, int j) {
        int x = i - 1;
        while (x &amp;lt;= i + 1) {
            if (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; size) {
                int y = j - 1;
                while (y &amp;lt;= j + 1) {
                    if (y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; size) {
                        if (!(x == i &amp;amp;&amp;amp; j == y)) {
                            // 没访问过且不是雷
                            if (!visited[x][y] &amp;amp;&amp;amp; maps[x][y] == 0) {
                                points.add(new Point(x, y));
                            }
                        }
                    }
                    y++;
                }
            }
            x++;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的是，周边的点，如果它的周边没有雷，那么会继续拓展，但是只要周边有雷，就会停止拓展，只会显示数字。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211229091520.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;判断成功失败&#34;&gt;判断成功失败&lt;/h1&gt;
&lt;p&gt;当挖到雷的时候，就失败了，同时会将所有的雷暴露出来，为了展示我们当前挖到的点，有爆炸效果，我们记录了上一步操作的点，在刷新视图后，弹窗提示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20211229091811385.png&#34; alt=&#34;image-20211229091811385&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;判断成功则需要将所有的雷遍历一次，判断是否被标记出来，这是我简单想的规则，忘记了扫雷是不是这样了，或者可以实现将其他所有非雷区都挖空的时候，成功，也是可以的。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;扫雷，一个简单的游戏，无聊的时候可以尝试一下，但是&lt;code&gt;Java&lt;/code&gt; 的&lt;code&gt;Swing&lt;/code&gt;真的难用，想找一个数据驱动视图修改的框架，但是貌似没有，那就简单实现一下。其实大部分时间都在找图标，测试&lt;code&gt;UI&lt;/code&gt;，核心的代码并没有多少。&lt;/p&gt;
&lt;p&gt;在这里推荐一下&lt;code&gt;icon&lt;/code&gt;网站：&lt;code&gt;https://www.iconfont.cn/&lt;/code&gt;,即使是没有什么技术含量的扫雷，写一下还是挺有趣的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【作者简介】&lt;/strong&gt;：&lt;br&gt;
秦怀，公众号【&lt;strong&gt;秦怀杂货店&lt;/strong&gt;】作者，个人网站：http://aphysia.cn，技术之路不在一时，山高水长，纵使缓慢，驰而不息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://aphysia.cn/archives/jianzhiofferpdf&#34;&gt;剑指Offer全部题解PDF&lt;/a&gt;&lt;/p&gt;
">无聊用Java写了个扫雷</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/about/"" data-c="
          &lt;h1 id=&#34;作者简介&#34;&gt;作者简介&lt;/h1&gt;
&lt;p&gt;秦怀，公众号【&lt;strong&gt;秦怀杂货店&lt;/strong&gt;】作者，个人网站：http://aphysia.cn，技术之路不在一时，山高水长，纵使缓慢，驰而不息。&lt;/p&gt;
&lt;p&gt;会一点 Java 和 Go，目前就职国内一家头部互联网公司，主要是支付方向。&lt;/p&gt;
&lt;h1 id=&#34;数据结构与算法&#34;&gt;数据结构与算法&lt;/h1&gt;
&lt;p&gt;快速解数据结构，可以看看： &lt;a href=&#34;https://aphysia.cn/post/man-you-shu-ju-jie-gou-shi-jie/&#34;&gt;万字长文解说数据结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/column/6963836588627329060&#34;&gt;剑指Offer系列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Damaer/CodeSolution&#34;&gt;刷题仓库&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211208224819.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">关于作者</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://aphysia.cn/post/go-zhong-de-bi-bao-dao-di-shi-sha/"" data-c="
          &lt;meta name=&#34;referrer&#34; content=&#34;no-referrer&#34; /&gt;
&lt;p&gt;以前写 Java 的时候，听到前端同学谈论闭包，觉得甚是新奇，后面自己写了一小段时间 JS，虽只学到皮毛，也大概了解到闭包的概念，现在工作常用语言是 Go，很多优雅的代码中总是有闭包的身影，看来不了解个透是不可能的了，本文让我来科普(按照自己水平随便瞎扯)一下：&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;1-什么是闭包&#34;&gt;1、什么是闭包？&lt;/h1&gt;
&lt;p&gt;在真正讲述闭包之前，我们先铺垫一点知识点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数式编程&lt;/li&gt;
&lt;li&gt;函数作用域&lt;/li&gt;
&lt;li&gt;作用域的继承关系&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-前提知识铺垫&#34;&gt;1.1 前提知识铺垫&lt;/h2&gt;
&lt;h3 id=&#34;121-函数式编程&#34;&gt;1.2.1 函数式编程&lt;/h3&gt;
&lt;p&gt;函数式编程是一种编程范式，看待问题的一种方式，每一个函数都是为了用小函数组织成为更大的函数，函数的参数也是函数，函数返回的也是函数。我们常见的编程范式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令式编程：
&lt;ul&gt;
&lt;li&gt;主要思想为：关注计算机执行的步骤，也就是一步一步告诉计算机先做什么再做什么。&lt;/li&gt;
&lt;li&gt;先把解决问题步骤规范化，抽象为某种算法，然后编写具体的算法去实现，一般只要支持过程化编程范式的语言，我们都可以称为过程化编程语言，比如 BASIC，C 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;声明式编程：
&lt;ul&gt;
&lt;li&gt;主要思想为：告诉计算机应该做什么，但是不指定具体要怎么做，比如 SQL，网页编程的 HTML，CSS。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数式编程：
&lt;ul&gt;
&lt;li&gt;只关注做什么而不关注怎么做，有一丝丝声明式编程的影子，但是更加侧重于”函数是第一位“的原则，也就是函数可以出现在任何地方，参数、变量、返回值等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数式编程可以认为是面向对象编程的对立面，一般只有一些编程语言会强调一种特定的编程方式，大多数的语言都是多范式语言，可以支持多种不同的编程方式，比如 JavaScript ，Go 等。&lt;/p&gt;
&lt;p&gt;函数式编程是一种思维方式，将电脑运算视为函数的计算，是一种写代码的方法论，&lt;strong&gt;其实我应该聊函数式编程，然后再聊到闭包，因为闭包本身就是函数式编程里面的一个特点之一。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在函数式编程中，函数是&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%AF%B9%E8%B1%A1&#34;&gt;头等对象&lt;/a&gt;，意思是说一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值，被修改或者被分配给一个变量。(维基百科)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般纯函数编程语言是不允许直接使用程序状态以及可变对象的，函数式编程本身就是要避免使用 &lt;strong&gt;共享状态&lt;/strong&gt;，&lt;strong&gt;可变状态&lt;/strong&gt;，尽可能避免产生 &lt;strong&gt;副作用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;函数式编程一般具有以下特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;函数是第一等公民：函数的地位放在第一位，可以作为参数，可以赋值，可以传递，可以当做返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有副作用：函数要保持纯粹独立，不能修改外部变量的值，不修改外部状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用透明：函数运行不依赖外部变量或者状态，相同的输入参数，任何情况，所得到的返回值都应该是一样的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;122-函数作用域&#34;&gt;1.2.2 函数作用域&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用域&lt;/strong&gt;（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的&lt;em&gt;作用域&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;通俗易懂的说，函数作用域是指函数可以起作用的范围。函数有点像盒子，一层套一层，作用域我们可以理解为是个封闭的盒子，也就是函数的局部变量，只能在盒子内部使用，成为独立作用域。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://gitee.com/Damaer/pic/raw/master/image-20221112163921104.png&#34; alt=&#34;image-20221112163921104&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;函数内的局部变量，出了函数就跳出了作用域，找不到该变量。（里层函数可以使用外层函数的局部变量，因为外层函数的作用域包括了里层函数），比如下面的 &lt;code&gt;innerTmep&lt;/code&gt; 出了函数作用域就找不到该变量，但是 &lt;code&gt;outerTemp&lt;/code&gt; 在内层函数里面还是可以使用。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://gitee.com/Damaer/pic/raw/master/image-20221112164640101.png&#34; alt=&#34;image-20221112164640101&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;不管是任何语言，基本存在一定的内存回收机制，也就是回收用不到的内存空间，回收的机制一般和上面说的函数的作用域是相关的，局部变量出了其作用域，就有可能被回收，如果还被引用着，那么就不会被回收。&lt;/p&gt;
&lt;h3 id=&#34;123-作用域的继承关系&#34;&gt;1.2.3 作用域的继承关系&lt;/h3&gt;
&lt;p&gt;所谓作用域继承，就是前面说的小盒子可以继承外层大盒子的作用域，在小盒子可以直接取出大盒子的东西，但是大盒子不能取出小盒子的东西，除非发生了逃逸（逃逸可以理解为小盒子的东西给出了引用，大盒子拿到就可以使用）。一般而言，变量的作用域有以下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局作用域：作用于任何地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部作用域：一般是代码块，函数、包内，&lt;strong&gt;函数内部&lt;/strong&gt;声明/定义的变量叫&lt;strong&gt;局部变量&lt;/strong&gt;，&lt;strong&gt;作用域仅限于函数内部&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-闭包的定义&#34;&gt;1.2 闭包的定义&lt;/h2&gt;
&lt;p&gt;“多数情况下我们并不是先理解后定义，而是先定义后理解“，先下定义，&lt;strong&gt;读不懂没关系&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包（closure）是&lt;strong&gt;一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合&lt;/strong&gt;。 换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。 闭包会随着函数的创建而被同时创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一句话表述：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;闭&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;包&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;函&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;引&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;用&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;环&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;境&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;闭包 = 函数 + 引用环境
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;闭&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;包&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;函&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;引&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;用&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;环&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;境&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以上定义找不到 Go语言 这几个字眼，聪明的同学肯定知道，闭包是和语言无关的，不是 JavaScript 特有的，也不是 Go 特有的，而是&lt;strong&gt;函数式编程语言&lt;/strong&gt;的特有的，是的，你没有看错，&lt;strong&gt;任何支持函数式编程的语言都支持闭包，Go 和 JavaScript 就是其中之二， 目前 Java 目前版本也是支持闭包的&lt;/strong&gt;，但是有些人可能认为不是完美的闭包，详细情况文中讨论。&lt;/p&gt;
&lt;h2 id=&#34;13-闭包的写法&#34;&gt;1.3 闭包的写法&lt;/h2&gt;
&lt;h3 id=&#34;131-初看闭包&#34;&gt;1.3.1 初看闭包&lt;/h3&gt;
&lt;p&gt;下面是一段闭包的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func main() {
	sumFunc := lazySum([]int{1, 2, 3, 4, 5})
	fmt.Println(&amp;quot;等待一会&amp;quot;)
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())
}
func lazySum(arr []int) func() int {
	fmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)
	var sum = func() int {
		fmt.Println(&amp;quot;求结果...&amp;quot;)
		result := 0
		for _, v := range arr {
			result = result + v
		}
		return result
	}
	return sum
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出的结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;先获取函数，不求结果
等待一会
求结果...
结果： 15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，里面的 &lt;code&gt;sum()&lt;/code&gt; 方法可以引用外部函数 &lt;code&gt;lazySum()&lt;/code&gt; 的参数以及局部变量，在&lt;code&gt;lazySum()&lt;/code&gt;返回函数 &lt;code&gt;sum()&lt;/code&gt; 的时候，相关的参数和变量都保存在返回的函数中，可以之后再进行调用。&lt;/p&gt;
&lt;p&gt;上面的函数或许还可以更进一步，体现出捆绑函数和其周围的状态，我们加上一个次数 &lt;code&gt;count&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func main() {
	sumFunc := lazySum([]int{1, 2, 3, 4, 5})
	fmt.Println(&amp;quot;等待一会&amp;quot;)
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())
}

func lazySum(arr []int) func() int {
	fmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)
	count := 0
	var sum = func() int {
		count++
		fmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求结果...&amp;quot;)
		result := 0
		for _, v := range arr {
			result = result + v
		}
		return result
	}
	return sum
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面代码输出什么呢？次数 &lt;code&gt;count&lt;/code&gt; 会不会发生变化，&lt;code&gt;count&lt;/code&gt;明显是外层函数的局部变量，但是在内存函数引用（捆绑），内层函数被暴露出去了，执行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;先获取函数，不求结果
等待一会
第 1 次求结果...
结果： 15
第 2 次求结果...
结果： 15
第 3 次求结果...
结果： 15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果是 &lt;code&gt;count&lt;/code&gt; 其实每次都会变化，这种情况总结一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数体内嵌套了另外一个函数，并且返回值是一个函数。&lt;/li&gt;
&lt;li&gt;内层函数被暴露出去，被&lt;strong&gt;外层函数以外&lt;/strong&gt;的地方引用着，形成了闭包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时有人可能有疑问了，前面是&lt;code&gt;lazySum（）&lt;/code&gt;被创建了 1 次，执行了 3 次，但是如果是 3 次执行都是不同的创建，会是怎么样呢？实验一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func main() {
	sumFunc := lazySum([]int{1, 2, 3, 4, 5})
	fmt.Println(&amp;quot;等待一会&amp;quot;)
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())

	sumFunc1 := lazySum([]int{1, 2, 3, 4, 5})
	fmt.Println(&amp;quot;等待一会&amp;quot;)
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc1())

	sumFunc2 := lazySum([]int{1, 2, 3, 4, 5})
	fmt.Println(&amp;quot;等待一会&amp;quot;)
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc2())
}

func lazySum(arr []int) func() int {
	fmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)
	count := 0
	var sum = func() int {
		count++
		fmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求结果...&amp;quot;)
		result := 0
		for _, v := range arr {
			result = result + v
		}
		return result
	}
	return sum
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行的结果如下，每次执行都是第 1 次：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;先获取函数，不求结果
等待一会
第 1 次求结果...
结果： 15
先获取函数，不求结果
等待一会
第 1 次求结果...
结果： 15
先获取函数，不求结果
等待一会
第 1 次求结果...
结果： 15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从以上的执行结果可以看出：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包被创建的时候，引用的外部变量&lt;code&gt;count&lt;/code&gt;就已经被创建了 1 份，也就是各自调用是没有关系的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;继续抛出一个问题，**如果一个函数返回了两个函数，这是一个闭包还是两个闭包呢？**下面我们实践一下：&lt;/p&gt;
&lt;p&gt;一次返回两个函数，一个用于计算加和的结果，一个计算乘积：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func main() {
	sumFunc, productSFunc := lazyCalculate([]int{1, 2, 3, 4, 5})
	fmt.Println(&amp;quot;等待一会&amp;quot;)
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())
	fmt.Println(&amp;quot;结果：&amp;quot;, productSFunc())
}

func lazyCalculate(arr []int) (func() int, func() int) {
	fmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)
	count := 0
	var sum = func() int {
		count++
		fmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求加和...&amp;quot;)
		result := 0
		for _, v := range arr {
			result = result + v
		}
		return result
	}

	var product = func() int {
		count++
		fmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求乘积...&amp;quot;)
		result := 0
		for _, v := range arr {
			result = result * v
		}
		return result
	}
	return sum, product
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;先获取函数，不求结果
等待一会
第 1 次求加和...
结果： 15
第 2 次求乘积...
结果： 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面结果可以看出，闭包是函数返回函数的时候，不管多少个返回值(函数)，都是一次闭包，如果返回的函数有使用外部函数变量，则会绑定到一起，相互影响：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://gitee.com/Damaer/pic/raw/master/image-20221119001944927.png&#34; alt=&#34;image-20221119001944927&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;闭包绑定了周围的状态，我理解此时的函数就拥有了状态，让函数具有了对象所有的能力，函数具有了状态。&lt;/p&gt;
&lt;h3 id=&#34;132-闭包中的指针和值&#34;&gt;1.3.2 闭包中的指针和值&lt;/h3&gt;
&lt;p&gt;上面的例子，我们闭包中用到的都是数值，如果我们传递指针，会是怎么样的呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;
func main() {
	i := 0
	testFunc := test(&amp;amp;i)
	testFunc()
	fmt.Printf(&amp;quot;outer i = %d\n&amp;quot;, i)
}
func test(i *int) func() {
	*i = *i + 1
	fmt.Printf(&amp;quot;test inner i = %d\n&amp;quot;, *i)
	return func() {
		*i = *i + 1
		fmt.Printf(&amp;quot;func inner i = %d\n&amp;quot;, *i)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;test inner i = 1
func inner i = 2
outer i = 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出如果是指针的话，闭包里面修改了指针对应的地址的值，也会影响闭包外面的值。这个其实很容易理解，Go 里面没有引用传递，只有值传递，那我们传递指针的时候，也是值传递，这里的值是指针的数值（可以理解为地址值）。&lt;/p&gt;
&lt;p&gt;当我们函数的参数是指针的时候，参数会拷贝一份这个指针地址，当做参数进行传递，因为本质还是地址，所以内部修改的时候，仍然可以对外部产生影响。&lt;/p&gt;
&lt;p&gt;闭包里面的数据其实地址也是一样的，下面的实验可以证明：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	i := 0
	testFunc := test(&amp;amp;i)
	testFunc()
	fmt.Printf(&amp;quot;outer i address %v\n&amp;quot;, &amp;amp;i)
}
func test(i *int) func() {
	*i = *i + 1
	fmt.Printf(&amp;quot;test inner i address %v\n&amp;quot;, i)
	return func() {
		*i = *i + 1
		fmt.Printf(&amp;quot;func inner i address %v\n&amp;quot;, i)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出如下, 因此可以推断出，闭包如果引用外部环境的指针数据，只是会拷贝一份指针地址数据，而不是拷贝一份真正的数据(&lt;mark&gt;先留个问题：拷贝的时机是什么时候呢&lt;/mark&gt;)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;test inner i address 0xc0003fab98
func inner i address 0xc0003fab98
outer i address 0xc0003fab98
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;132-闭包延迟化&#34;&gt;1.3.2 闭包延迟化&lt;/h3&gt;
&lt;p&gt;上面的例子仿佛都在告诉我们，闭包创建的时候，数据就已经拷贝了，但是真的是这样么？&lt;/p&gt;
&lt;p&gt;下面是继续前面的实验：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	i := 0
	testFunc := test(&amp;amp;i)
	i = i + 100
	fmt.Printf(&amp;quot;outer i before testFunc  %d\n&amp;quot;, i)
	testFunc()
	fmt.Printf(&amp;quot;outer i after testFunc %d\n&amp;quot;, i)
}
func test(i *int) func() {
	*i = *i + 1
	fmt.Printf(&amp;quot;test inner i = %d\n&amp;quot;, *i)
	return func() {
		*i = *i + 1
		fmt.Printf(&amp;quot;func inner i = %d\n&amp;quot;, *i)
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们在创建闭包之后，把数据改了，之后执行闭包，答案肯定是真实影响闭包的执行，因为它们都是指针，都是指向同一份数据：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;test inner i = 1
outer i before testFunc  101
func inner i = 102
outer i after testFunc 102
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设我们换个写法，让闭包外部环境中的变量在声明闭包函数的之后，进行修改：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func main() {
	sumFunc := lazySum([]int{1, 2, 3, 4, 5})
	fmt.Println(&amp;quot;等待一会&amp;quot;)
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())
}
func lazySum(arr []int) func() int {
	fmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)
	count := 0
	var sum = func() int {
		fmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求结果...&amp;quot;)
		result := 0
		for _, v := range arr {
			result = result + v
		}
		return result
	}
	count = count + 100
	return sum
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际执行结果，&lt;code&gt;count&lt;/code&gt; 会是修改后的值：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;等待一会
第 100 次求结果...
结果： 15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这也证明了，实际上闭包并不会在声明&lt;code&gt;var sum = func() int {...}&lt;/code&gt;这句话之后，就将外部环境的 &lt;code&gt;count&lt;/code&gt;绑定到闭包中，而是在函数返回闭包函数的时候，才绑定的，这就是&lt;strong&gt;延迟绑定&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果还没看明白没关系，我们再来一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	funcs := testFunc(100)
	for _, v := range funcs {
		v()
	}
}
func testFunc(x int) []func() {
	var funcs []func()
	values := []int{1, 2, 3}
	for _, val := range values {
		funcs = append(funcs, func() {
			fmt.Printf(&amp;quot;testFunc val = %d\n&amp;quot;, x+val)
		})
	}
	return funcs
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的例子，我们闭包返回的是函数数组，本意我们想入每一个 &lt;code&gt;val&lt;/code&gt; 都不一样，但是实际上 &lt;code&gt;val&lt;/code&gt;都是一个值，&lt;mark&gt;也就是执行到&lt;code&gt;return funcs&lt;/code&gt; 的时候（或者真正执行闭包函数的时候）才绑定的 &lt;code&gt;val&lt;/code&gt;值&lt;/mark&gt;（关于这一点，后面还有个Demo可以证明），此时 &lt;code&gt;val&lt;/code&gt;的值是最后一个 &lt;code&gt;3&lt;/code&gt;,最终输出结果都是 &lt;code&gt;103&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;testFunc val = 103
testFunc val = 103
testFunc val = 103
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上两个例子，都是闭包延迟绑定的问题导致，这也可以说是 feature，到这里可能不少同学还是对闭包绑定外部变量的时机有疑惑，到底是返回闭包函数的时候绑定的呢？还是真正执行闭包函数的时候才绑定的呢？&lt;/p&gt;
&lt;p&gt;下面的例子可以有效的解答：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	sumFunc := lazySum([]int{1, 2, 3, 4, 5})
	fmt.Println(&amp;quot;等待一会&amp;quot;)
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())
	time.Sleep(time.Duration(3) * time.Second)
	fmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())
}
func lazySum(arr []int) func() int {
	fmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)
	count := 0
	var sum = func() int {
		count++
		fmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求结果...&amp;quot;)
		result := 0
		for _, v := range arr {
			result = result + v
		}
		return result
	}
	go func() {
		time.Sleep(time.Duration(1) * time.Second)
		count = count + 100
		fmt.Println(&amp;quot;go func 修改后的变量 count：&amp;quot;, count)
	}()
	return sum
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;先获取函数，不求结果
等待一会
第 1 次求结果...
结果： 15
go func 修改后的变量 count： 101
第 102 次求结果...
结果： 15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二次执行闭包函数的时候，明显 &lt;code&gt;count&lt;/code&gt;被里面的 &lt;code&gt;go func()&lt;/code&gt;修改了，也就是调用的时候，才真正的获取最新的外部环境，但是在声明的时候，就会把环境预留保存下来。&lt;/p&gt;
&lt;p&gt;其实本质上，&lt;strong&gt;Go Routine的匿名函数的延迟绑定就是闭包的延迟绑定&lt;/strong&gt;，上面的例子中，&lt;code&gt;go func(){}&lt;/code&gt;获取到的就是最新的值，而不是原始值&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;总结一下上面的验证点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;闭包每次返回都是一个新的实例，每个实例都有一份自己的环境。&lt;/li&gt;
&lt;li&gt;同一个实例多次执行，会使用相同的环境。&lt;/li&gt;
&lt;li&gt;闭包如果逃逸的是指针，会相互影响，因为绑定的是指针，相同指针的内容修改会相互影响。&lt;/li&gt;
&lt;li&gt;闭包并不是在声明时绑定的值，声明后只是预留了外部环境（逃逸分析），真正执行闭包函数时，会获取最新的外部环境的值（也称为延迟绑定）。&lt;/li&gt;
&lt;li&gt;Go Routine的匿名函数的延迟绑定本质上就是闭包的延迟绑定。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-闭包的好处与坏处&#34;&gt;2、闭包的好处与坏处？&lt;/h1&gt;
&lt;h2 id=&#34;21-好处&#34;&gt;2.1 好处&lt;/h2&gt;
&lt;p&gt;纯函数没有状态，而闭包则是让函数轻松拥有了状态。但是凡事都有两面性，一旦拥有状态，多次调用，可能会出现不一样的结果，就像是前面测试的 case 中一样。那么问题来了：&lt;/p&gt;
&lt;p&gt;Q：&lt;strong&gt;如果不支持闭包的话，我们想要函数拥有状态，需要怎么做呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A： 需要使用全局变量，让所有函数共享同一份变量。&lt;/p&gt;
&lt;p&gt;但是我们都知道全局变量有以下的一些特点（在不同的场景，优点会变成缺点）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常驻于内存之中，只要程序不停会一直在内存中。&lt;/li&gt;
&lt;li&gt;污染全局，大家都可以访问，共享的同时不知道谁会改这个变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;闭包可以一定程度优化这个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不需要使用全局变量，外部函数局部变量在闭包的时候会创建一份，生命周期与函数生命周期一致，闭包函数不再被引用的时候，就可以回收了。&lt;/li&gt;
&lt;li&gt;闭包暴露的局部变量，外界无法直接访问，只能通过函数操作，可以避免滥用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了以上的好处，像在 JavaScript 中，没有原生支持私有方法，可以靠闭包来模拟私有方法，因为闭包都有自己的词法环境。&lt;/p&gt;
&lt;h2 id=&#34;22-坏处&#34;&gt;2.2 坏处&lt;/h2&gt;
&lt;p&gt;函数拥有状态，如果处理不当，会导致闭包中的变量被误改，但这是编码者应该考虑的问题，是预期中的场景。&lt;/p&gt;
&lt;p&gt;闭包中如果随意创建，引用被持有，则无法销毁，同时闭包内的局部变量也无法销毁，过度使用闭包会占有更多的内存，导致性能下降。一般而言，能共享一份闭包（共享闭包局部变量数据），不需要多次创建闭包函数，是比较优雅的方式。&lt;/p&gt;
&lt;h1 id=&#34;3-闭包怎么实现的&#34;&gt;3、闭包怎么实现的？&lt;/h1&gt;
&lt;p&gt;从上面的实验中，我们可以知道，闭包实际上就是外部环境的逃逸，跟随着闭包函数一起暴露出去。&lt;/p&gt;
&lt;p&gt;我们用以下的程序进行分析：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;fmt&amp;quot;

func testFunc(i int) func() int {
	i = i * 2
	testFunc := func() int {
		i++
		return i
	}
	i = i * 2
	return testFunc
}
func main() {
	test := testFunc(1)
	fmt.Println(test())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先看看逃逸分析，用下面的命令行可以查看：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; go build --gcflags=-m main.go
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://gitee.com/Damaer/pic/raw/master/image-20221120223253318.png&#34; alt=&#34;image-20221120223253318&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看到 变量 &lt;code&gt;i&lt;/code&gt;被移到堆中，也就是本来是局部变量，但是发生逃逸之后，从栈里面放到堆里面，同样的 &lt;code&gt;test()&lt;/code&gt;函数由于是闭包函数，也逃逸到堆上。&lt;/p&gt;
&lt;p&gt;下面我们用命令行来看看汇编代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;go tool compile -N -l -S main.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生成代码比较长，我截取一部分：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;quot;&amp;quot;.testFunc STEXT size=218 args=0x8 locals=0x38 funcid=0x0 align=0x0
        0x0000 00000 (main.go:5)        TEXT    &amp;quot;&amp;quot;.testFunc(SB), ABIInternal, $56-8
        0x0000 00000 (main.go:5)        CMPQ    SP, 16(R14)
        0x0004 00004 (main.go:5)        PCDATA  $0, $-2
        0x0004 00004 (main.go:5)        JLS     198
        0x000a 00010 (main.go:5)        PCDATA  $0, $-1
        0x000a 00010 (main.go:5)        SUBQ    $56, SP
        0x000e 00014 (main.go:5)        MOVQ    BP, 48(SP)
        0x0013 00019 (main.go:5)        LEAQ    48(SP), BP
        0x0018 00024 (main.go:5)        FUNCDATA        $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)
        0x0018 00024 (main.go:5)        FUNCDATA        $1, gclocals·d571c0f6cf0af59df28f76498f639cf2(SB)
        0x0018 00024 (main.go:5)        FUNCDATA        $5, &amp;quot;&amp;quot;.testFunc.arginfo1(SB)
        0x0018 00024 (main.go:5)        MOVQ    AX, &amp;quot;&amp;quot;.i+64(SP)
        0x001d 00029 (main.go:5)        MOVQ    $0, &amp;quot;&amp;quot;.~r0+16(SP)
        0x0026 00038 (main.go:5)        LEAQ    type.int(SB), AX
        0x002d 00045 (main.go:5)        PCDATA  $1, $0
        0x002d 00045 (main.go:5)        CALL    runtime.newobject(SB)
        0x0032 00050 (main.go:5)        MOVQ    AX, &amp;quot;&amp;quot;.&amp;amp;i+40(SP)
        0x0037 00055 (main.go:5)        MOVQ    &amp;quot;&amp;quot;.i+64(SP), CX
        0x003c 00060 (main.go:5)        MOVQ    CX, (AX)
        0x003f 00063 (main.go:6)        MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), CX
        0x0044 00068 (main.go:6)        MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), DX
        0x0049 00073 (main.go:6)        MOVQ    (DX), DX
        0x004c 00076 (main.go:6)        SHLQ    $1, DX
        0x004f 00079 (main.go:6)        MOVQ    DX, (CX)
        0x0052 00082 (main.go:7)        LEAQ    type.noalg.struct { F uintptr; &amp;quot;&amp;quot;.i *int }(SB), AX
        0x0059 00089 (main.go:7)        PCDATA  $1, $1
        0x0059 00089 (main.go:7)        CALL    runtime.newobject(SB)
        0x005e 00094 (main.go:7)        MOVQ    AX, &amp;quot;&amp;quot;..autotmp_3+32(SP)
        0x0063 00099 (main.go:7)        LEAQ    &amp;quot;&amp;quot;.testFunc.func1(SB), CX
        0x006a 00106 (main.go:7)        MOVQ    CX, (AX)
        0x006d 00109 (main.go:7)        MOVQ    &amp;quot;&amp;quot;..autotmp_3+32(SP), CX
        0x0072 00114 (main.go:7)        TESTB   AL, (CX)
        0x0074 00116 (main.go:7)        MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), DX
        0x0079 00121 (main.go:7)        LEAQ    8(CX), DI
        0x007d 00125 (main.go:7)        PCDATA  $0, $-2
        0x007d 00125 (main.go:7)        CMPL    runtime.writeBarrier(SB), $0
        0x0084 00132 (main.go:7)        JEQ     136
        0x0086 00134 (main.go:7)        JMP     142
        0x0088 00136 (main.go:7)        MOVQ    DX, 8(CX)
        0x008c 00140 (main.go:7)        JMP     149
        0x008e 00142 (main.go:7)        CALL    runtime.gcWriteBarrierDX(SB)
        0x0093 00147 (main.go:7)        JMP     149
        0x0095 00149 (main.go:7)        PCDATA  $0, $-1
        0x0095 00149 (main.go:7)        MOVQ    &amp;quot;&amp;quot;..autotmp_3+32(SP), CX
        0x009a 00154 (main.go:7)        MOVQ    CX, &amp;quot;&amp;quot;.testFunc+24(SP)
        0x009f 00159 (main.go:11)       MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), CX
        0x00a4 00164 (main.go:11)       MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), DX
        0x00a9 00169 (main.go:11)       MOVQ    (DX), DX
        0x00ac 00172 (main.go:11)       SHLQ    $1, DX
        0x00af 00175 (main.go:11)       MOVQ    DX, (CX)
        0x00b2 00178 (main.go:12)       MOVQ    &amp;quot;&amp;quot;.testFunc+24(SP), AX
        0x00b7 00183 (main.go:12)       MOVQ    AX, &amp;quot;&amp;quot;.~r0+16(SP)
        0x00bc 00188 (main.go:12)       MOVQ    48(SP), BP
        0x00c1 00193 (main.go:12)       ADDQ    $56, SP
        0x00c5 00197 (main.go:12)       RET
        0x00c6 00198 (main.go:12)       NOP
        0x00c6 00198 (main.go:5)        PCDATA  $1, $-1
        0x00c6 00198 (main.go:5)        PCDATA  $0, $-2
        0x00c6 00198 (main.go:5)        MOVQ    AX, 8(SP)
        0x00cb 00203 (main.go:5)        CALL    runtime.morestack_noctxt(SB)
        0x00d0 00208 (main.go:5)        MOVQ    8(SP), AX
        0x00d5 00213 (main.go:5)        PCDATA  $0, $-1
        0x00d5 00213 (main.go:5)        JMP     0

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到闭包函数实际上底层也是用结构体&lt;code&gt;new&lt;/code&gt;创建出来的：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://gitee.com/Damaer/pic/raw/master/image-20221120224413412.png&#34; alt=&#34;image-20221120224413412&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;使用的就是堆上面的&lt;code&gt; i&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://gitee.com/Damaer/pic/raw/master/image-20221120225532865.png&#34; alt=&#34;image-20221120225532865&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;也就是返回函数的时候，实际上返回结构体，结构体里面记录了函数的引用环境。&lt;/p&gt;
&lt;h1 id=&#34;4-浅聊一下&#34;&gt;4、浅聊一下&lt;/h1&gt;
&lt;h2 id=&#34;41-java-支不支持闭包&#34;&gt;4.1 Java 支不支持闭包？&lt;/h2&gt;
&lt;p&gt;网上有很多种看法，实际上 Java 虽然暂时不支持返回函数作为返参，但是Java 本质上还是实现了闭包的概念的，所使用的的方式是内部类的形式，因为是内部类，所以相当于自带了一个引用环境，算是一种不完整的闭包。&lt;/p&gt;
&lt;p&gt;目前有一定限制，比如是 &lt;code&gt;final &lt;/code&gt;声明的，或者是明确定义的值，才可以进行传递：&lt;/p&gt;
&lt;p&gt;Stack Overflow上有相关答案：https://stackoverflow.com/questions/5443510/closure-in-java-7&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://gitee.com/Damaer/pic/raw/master/image-20221120233223203.png&#34; alt=&#34;image-20221120233223203&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;42-函数式编程的前景怎么样&#34;&gt;4.2 函数式编程的前景怎么样？&lt;/h2&gt;
&lt;p&gt;下面是Wiki的内容：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;函数式编程长期以来在学术界流行，但几乎没有工业应用。造成这种局面的主因是函数式编程常被认为严重耗费CPU和存储器资源[&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-18&#34;&gt;18]&lt;/a&gt; ，这是由于在早期实现函数式编程语言时并没有考虑过效率问题，而且面向函数式编程特性，如保证&lt;a href=&#34;https://zh.wikipedia.org/w/index.php?title=%E5%8F%82%E7%85%A7%E9%80%8F%E6%98%8E%E6%80%A7&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;参照透明性&lt;/a&gt;等，要求独特的数据结构和算法。[&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-programmingScala-19&#34;&gt;19]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然而，最近几种函数式编程语言已经在商业或工业系统中使用[&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-20&#34;&gt;20]&lt;/a&gt;，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Erlang&#34;&gt;Erlang&lt;/a&gt;，它由瑞典公司&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E7%88%B1%E7%AB%8B%E4%BF%A1&#34;&gt;爱立信&lt;/a&gt;在20世纪80年代后期开发，最初用于实现容错电信系统。此后，它已在&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%8C%97%E7%94%B5%E7%BD%91%E7%BB%9C&#34;&gt;Nortel&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/Facebook&#34;&gt;Facebook&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E6%B3%95%E5%9B%BD%E7%94%B5%E5%8A%9B%E5%85%AC%E5%8F%B8&#34;&gt;Électricité de France&lt;/a&gt;和&lt;a href=&#34;https://zh.wikipedia.org/wiki/WhatsApp&#34;&gt;WhatsApp&lt;/a&gt;等公司作为流行语言创建一系列应用程序。[&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-21&#34;&gt;21]&lt;/a&gt;[&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-whatsapp.blog.2012-22&#34;&gt;22]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Scheme&#34;&gt;Scheme&lt;/a&gt;，它被用作早期&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%8B%B9%E6%9E%9C%E5%85%AC%E5%8F%B8&#34;&gt;Apple&lt;/a&gt; &lt;a href=&#34;https://zh.wikipedia.org/wiki/Macintosh&#34;&gt;Macintosh&lt;/a&gt;计算机上的几个应用程序的基础，并且最近已应用于诸如训练模拟软件和望远镜控制等方向。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/OCaml&#34;&gt;OCaml&lt;/a&gt;，它于20世纪90年代中期推出，已经在金融分析，驱动程序验证，工业机器人编程和嵌入式软件静态分析等领域得到了商业应用。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/Haskell&#34;&gt;Haskell&lt;/a&gt;，它虽然最初是作为一种研究语言，也已被一系列公司应用于航空航天系统，硬件设计和网络编程等领域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他在工业中使用的函数式编程语言包括多范型的&lt;a href=&#34;https://zh.wikipedia.org/wiki/Scala&#34;&gt;Scala&lt;/a&gt;[&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-23&#34;&gt;23]&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/F%EF%BC%83&#34;&gt;F#&lt;/a&gt;，还有&lt;a href=&#34;https://zh.wikipedia.org/wiki/Wolfram%E8%AF%AD%E8%A8%80&#34;&gt;Wolfram语言&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/Common_Lisp&#34;&gt;Common Lisp&lt;/a&gt;、&lt;a href=&#34;https://zh.wikipedia.org/wiki/Standard_ML&#34;&gt;Standard ML&lt;/a&gt;和&lt;a href=&#34;https://zh.wikipedia.org/wiki/Clojure&#34;&gt;Clojure&lt;/a&gt;等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从我个人的看法，不看好纯函数编程，但是函数式编程的思想，我相信以后几乎每门高级编程需要都会具备，特别期待 Java 拥抱函数式编程。从我自己了解的语言看，像 Go，JavaScript 中的函数式编程的特性，都让开发者深爱不已（当然，如果写出了bug，就是深恶痛疾）。&lt;/p&gt;
&lt;p&gt;最近突然火了一波的原因，也是因为世界不停的发展，内存也越来越大，这个因素的限制几乎要解放了。&lt;/p&gt;
&lt;p&gt;我相信，世界就是绚丽多彩的，要是一种事物统治世界，绝无可能，更多的是百家争鸣，编程语言或者编程范式也一样，后续可能有集大成者，最终最终历史会筛选出最终符合人类社会发展的。&lt;/p&gt;
">Go 中的闭包到底是啥？</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;很多时候我们会遇到别人问一个问题：你给我讲一下反射，到底是什么东西？怎么实现的？我们能用反射来做什么？它有什么优缺点？下面我们会围绕着这几个问题展开：&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201115212257.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;一-反射机制是什么\&#34;&gt;一、反射机制是什么？&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;反射是什么？什么是反？什么是正射？&lt;/strong&gt;&lt;br&gt;\n有反就有正，我们知道正常情况， 如果我们希望创建一个对象，会使用以下的语句：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Person person = new Person();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其实我们第一次执行上面的语句的时候，JVM会先加载&lt;code&gt;Person.class&lt;/code&gt;，加载到内存完之后，在方法区/堆中会创建了一个&lt;code&gt;Class&lt;/code&gt;对象,对应这个&lt;code&gt;Person&lt;/code&gt;类。这里有争议，有人说是在方法区，有些人说是在堆。个人感觉应该JVM规范说是在方法区，但是不是强制要求，而且不同版本的JVM实现也不一样。具体参考以下链接，这里不做解释：&lt;br&gt;\nhttps://www.cnblogs.com/xy-nb/p/6773051.html&lt;br&gt;\n而上面正常的初始化对象的方法，也可以说是“正射”,就是使用&lt;code&gt;Class&lt;/code&gt;对象创建出一个&lt;code&gt;Person&lt;/code&gt;对象。&lt;/p&gt;\n&lt;p&gt;而反射则相反，是根据&lt;code&gt;Person&lt;/code&gt;对象，获取到&lt;code&gt;Class&lt;/code&gt;对象，然后可以获取到&lt;code&gt;Person&lt;/code&gt;类的相关信息，进行初始化或者调用等一系列操作。&lt;/p&gt;\n&lt;p&gt;在&lt;strong&gt;运行状态时&lt;/strong&gt;，可以构造任何一个类的对象，获取到任意一个对象所属的类信息，以及这个类的成员变量或者方法，可以调用任意一个对象的属性或者方法。可以理解为具备了 &lt;strong&gt;动态加载对象&lt;/strong&gt; 以及 &lt;strong&gt;对对象的基本信息进行剖析和使用&lt;/strong&gt; 的能力。&lt;/p&gt;\n&lt;p&gt;提供的功能包括：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1.在运行时判断一个对象所属的类&lt;/li&gt;\n&lt;li&gt;2.在运行时构造任意一个类的对象&lt;/li&gt;\n&lt;li&gt;3.在运行时获取一个类定义的成员变量以及方法&lt;/li&gt;\n&lt;li&gt;4.在运行时调用任意一个对象的方法&lt;/li&gt;\n&lt;li&gt;5.生成动态代理&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;灵活，强大，可以在运行时装配，无需在组件之间进行源代码链接，但是使用不当效率会有影响。所有类的对象都是Class的实例。&lt;br&gt;\n既然我们可以对类的全限定名，方法以及参数等进行配置，完成对象的初始化，那就是相当于增加了java的可配置性。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;这里特别需要明确的一点：类本身也是一个对象，方法也是一个对象，在Java里面万物皆可对象，除了基础数据类型...&lt;/strong&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;二-反射的具体使用\&#34;&gt;二、反射的具体使用&lt;/h2&gt;\n&lt;h3 id=\&#34;21-获取对象的包名以及类名\&#34;&gt;2.1 获取对象的包名以及类名&lt;/h3&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;package invocation;\npublic class MyInvocation {\n    public static void main(String[] args) {\n        getClassNameTest();\n    }\n    \n    public static void getClassNameTest(){\n        MyInvocation myInvocation = new MyInvocation();\n        System.out.println(&amp;quot;class: &amp;quot; + myInvocation.getClass());\n        System.out.println(&amp;quot;simpleName: &amp;quot; + myInvocation.getClass().getSimpleName());\n        System.out.println(&amp;quot;name: &amp;quot; + myInvocation.getClass().getName());\n        System.out.println(&amp;quot;package: &amp;quot; +\n                &amp;quot;&amp;quot; + myInvocation.getClass().getPackage());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class: class invocation.MyInvocation\nsimpleName: MyInvocation\nname: invocation.MyInvocation\npackage: package invocation\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;由上面结果我们可以看到：&lt;br&gt;\n1.&lt;code&gt;getClass()&lt;/code&gt;:打印会带着class+全类名&lt;br&gt;\n2.&lt;code&gt;getClass().getSimpleName()&lt;/code&gt;：只会打印出类名&lt;br&gt;\n3.&lt;code&gt;getName()&lt;/code&gt;：会打印全类名&lt;br&gt;\n4.&lt;code&gt;getClass().getPackage()&lt;/code&gt;:打印出package+包名&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;getClass()&lt;/code&gt;获取到的是一个对象，&lt;code&gt;getPackage()&lt;/code&gt;也是。&lt;/p&gt;\n&lt;h3 id=\&#34;22-获取class对象\&#34;&gt;2.2 获取Class对象&lt;/h3&gt;\n&lt;p&gt;在java中，一切皆对象。java中可以分为两种对象，实例对象和Class对象。这里我们说的获取Class对象，其实就是第二种，Class对象代表的是每个类在运行时的类型信息，指和类相关的信息。比如有一个&lt;code&gt;Student&lt;/code&gt;类，我们用&lt;code&gt;Student student = new Student()&lt;/code&gt;new一个对象出来，这个时候&lt;code&gt;Student&lt;/code&gt;这个类的信息其实就是存放在一个对象中，这个对象就是&lt;strong&gt;Class类的对象&lt;/strong&gt;，而student这个实例对象也会和&lt;strong&gt;Class对象&lt;/strong&gt;关联起来。&lt;br&gt;\n我们有三种方式可以获取一个类在运行时的Class对象，分别是&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Class.forName(&amp;quot;com.Student&amp;quot;)&lt;/li&gt;\n&lt;li&gt;student.getClass()&lt;/li&gt;\n&lt;li&gt;Student.class&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;实例代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;package invocation;\n\npublic class MyInvocation {\n    public static void main(String[] args) {\n        getClassTest();\n    }\n    public static void getClassTest(){\n        Class&amp;lt;?&amp;gt; invocation1 = null;\n        Class&amp;lt;?&amp;gt; invocation2 = null;\n        Class&amp;lt;?&amp;gt; invocation3 = null;\n        try {\n            // 最常用的方法\n            invocation1 = Class.forName(&amp;quot;invocation.MyInvocation&amp;quot;);\n        }catch (Exception ex){\n            ex.printStackTrace();\n        }\n        invocation2 = new MyInvocation().getClass();\n        invocation3 = MyInvocation.class;\n        System.out.println(invocation1);\n        System.out.println(invocation2);\n        System.out.println(invocation3);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行的结果如下,三个结果一样：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;class invocation.MyInvocation\nclass invocation.MyInvocation\nclass invocation.MyInvocation\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;23-getinstance获取指定类型的实例化对象\&#34;&gt;2.3 getInstance()获取指定类型的实例化对象&lt;/h3&gt;\n&lt;p&gt;首先我们有一个Student类，后面都会沿用这个类，将不再重复。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class Student{\n    private int age;\n\n    private String name;\n\n    public Student() {\n    }\n    public Student(int age) {\n        this.age = age;\n    }\n\n    public Student(String name) {\n        this.name = name;\n    }\n    \n    public Student(int age, String name) {\n        this.age = age;\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return &amp;quot;Student{&amp;quot; +\n                &amp;quot;age=&amp;quot; + age +\n                &amp;quot;, name=&#39;&amp;quot; + name + &#39;\\&#39;&#39; +\n                &#39;}&#39;;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们可以使用&lt;code&gt;getInstance()&lt;/code&gt;方法构造出一个Student的对象：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public static void getInstanceTest() {\n        try {\n            Class&amp;lt;?&amp;gt; stduentInvocation = Class.forName(&amp;quot;invocation.Student&amp;quot;);\n            Student student = (Student) stduentInvocation.newInstance();\n            student.setAge(9);\n            student.setName(&amp;quot;Hahs&amp;quot;);\n            System.out.println(student);\n\n        }catch (Exception ex){\n            ex.printStackTrace();\n        }\n    }\n    \n    \n输出结果如下：\nStudent{age=9, name=&#39;Hahs&#39;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是如果我们取消不写Student的无参构造方法呢？就会出现下面的报错：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;java.lang.InstantiationException: invocation.Student\n\tat java.lang.Class.newInstance(Class.java:427)\n\tat invocation.MyInvocation.getInstanceTest(MyInvocation.java:40)\n\tat invocation.MyInvocation.main(MyInvocation.java:8)\nCaused by: java.lang.NoSuchMethodException: invocation.Student.&amp;lt;init&amp;gt;()\n\tat java.lang.Class.getConstructor0(Class.java:3082)\n\tat java.lang.Class.newInstance(Class.java:412)\n\t... 2 more\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这是因为我们重写了构造方法，而且是有参构造方法，如果不写构造方法，那么每个类都会默认有无参构造方法，重写了就不会有无参构造方法了，所以我们调用&lt;code&gt;newInstance()&lt;/code&gt;的时候，会报没有这个方法的错误。值得注意的是,&lt;code&gt;newInstance()&lt;/code&gt;是一个无参构造方法。&lt;/p&gt;\n&lt;h3 id=\&#34;24-通过构造函数对象实例化对象\&#34;&gt;2.4 通过构造函数对象实例化对象&lt;/h3&gt;\n&lt;p&gt;除了&lt;code&gt;newInstance()&lt;/code&gt;方法之外，其实我们还可以通过构造函数对象获取实例化对象，怎么理解？这里只构造函数对象，而不是构造函数，也就是构造函数其实就是一个对象，我们先获取构造函数对象，当然也可以使用来实例化对象。&lt;/p&gt;\n&lt;p&gt;可以先获取一个类的所有的构造方法，然后遍历输出：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public static void testConstruct(){\n        try {\n            Class&amp;lt;?&amp;gt; stduentInvocation = Class.forName(&amp;quot;invocation.Student&amp;quot;);\n            Constructor&amp;lt;?&amp;gt; cons[] = stduentInvocation.getConstructors();\n            for(int i=0;i&amp;lt;cons.length;i++){\n                System.out.println(cons[i]);\n            }\n\n        }catch (Exception ex){\n            ex.printStackTrace();\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public invocation.Student(int,java.lang.String)\npublic invocation.Student(java.lang.String)\npublic invocation.Student(int)\npublic invocation.Student()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;取出一个构造函数我们可以获取到它的各种信息，包括参数，参数个数，类型等等：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public static void constructGetInstance() {\n        try {\n            Class&amp;lt;?&amp;gt; stduentInvocation = Class.forName(&amp;quot;invocation.Student&amp;quot;);\n            Constructor&amp;lt;?&amp;gt; cons[] = stduentInvocation.getConstructors();\n            Constructor constructors = cons[0];\n            System.out.println(&amp;quot;name: &amp;quot; + constructors.getName());\n            System.out.println(&amp;quot;modifier: &amp;quot; + constructors.getModifiers());\n            System.out.println(&amp;quot;parameterCount: &amp;quot; + constructors.getParameterCount());\n            System.out.println(&amp;quot;构造参数类型如下：&amp;quot;);\n            for (int i = 0; i &amp;lt; constructors.getParameterTypes().length; i++) {\n                System.out.println(constructors.getParameterTypes()[i].getName());\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出结果,&lt;code&gt;modifier&lt;/code&gt;是权限修饰符，1表示为&lt;code&gt;public&lt;/code&gt;，我们可以知道获取到的构造函数是两个参数的，第一个是int，第二个是String类型，看来获取出来的顺序并不一定是我们书写代码的顺序。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;name: invocation.Student\nmodifier: 1\nparameterCount: 2\n构造参数类型如下：\nint\njava.lang.String\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;既然我们可以获取到构造方法这个对象了，那么我们可不可以通过它去构造一个对象呢？&lt;strong&gt;答案肯定是可以！！！&lt;/strong&gt;&lt;br&gt;\n下面我们用不同的构造函数来创建对象：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public static void constructGetInstanceTest() {\n        try {\n            Class&amp;lt;?&amp;gt; stduentInvocation = Class.forName(&amp;quot;invocation.Student&amp;quot;);\n            Constructor&amp;lt;?&amp;gt; cons[] = stduentInvocation.getConstructors();\n            // 一共定义了4个构造器\n            Student student1 = (Student) cons[0].newInstance(9,&amp;quot;Sam&amp;quot;);\n            Student student2 = (Student) cons[1].newInstance(&amp;quot;Sam&amp;quot;);\n            Student student3 = (Student) cons[2].newInstance(9);\n            Student student4 = (Student) cons[3].newInstance();\n            System.out.println(student1);\n            System.out.println(student2);\n            System.out.println(student3);\n            System.out.println(student4);\n\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Student{age=9, name=&#39;Sam&#39;}\nStudent{age=0, name=&#39;Sam&#39;}\nStudent{age=9, name=&#39;null&#39;}\nStudent{age=0, name=&#39;null&#39;}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;构造器的顺序我们是必须一一针对的，要不会报一下的参数不匹配的错误：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;java.lang.IllegalArgumentException: argument type mismatch\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)\n\tat sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.lang.reflect.Constructor.newInstance(Constructor.java:423)\n\tat invocation.MyInvocation.constructGetInstanceTest(MyInvocation.java:85)\n\tat invocation.MyInvocation.main(MyInvocation.java:8)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;25-获取类继承的接口\&#34;&gt;2.5 获取类继承的接口&lt;/h3&gt;\n&lt;p&gt;通过反射我们可以获取接口的方法，如果我们知道某个类实现了接口的方法，同样可以做到通过类名创建对象调用到接口的方法。&lt;/p&gt;\n&lt;p&gt;首先我们定义两个接口，一个&lt;code&gt;InSchool&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public interface InSchool {\n    public void attendClasses();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;一个&lt;code&gt;AtHome&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public interface AtHome {\n    public void doHomeWork();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;创建一个实现两个接口的类&lt;code&gt;Student.java&lt;/code&gt;&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Student implements AtHome, InSchool {\n    public void doHomeWork() {\n        System.out.println(&amp;quot;I am a student,I am doing homework at home&amp;quot;);\n    }\n\n    public void attendClasses() {\n        System.out.println(&amp;quot;I am a student,I am attend class in school&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Test {\n    public static void main(String[] args) throws Exception {\n        Class&amp;lt;?&amp;gt; studentClass = Class.forName(&amp;quot;invocation.Student&amp;quot;);\n        Class&amp;lt;?&amp;gt;[] interfaces = studentClass.getInterfaces();\n        for (Class c : interfaces) {\n            // 获取接口\n            System.out.println(c);\n            // 获取接口里面的方法\n            Method[] methods = c.getMethods();\n            // 遍历接口的方法\n            for (Method method : methods) {\n                // 通过反射创建对象\n                Student student = (Student) studentClass.newInstance();\n                // 通过反射调用方法\n                method.invoke(student, null);\n            }\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果如下：&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201114003042.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;可以看出其实我们可以获取到接口的数组，并且里面的顺序是我们继承的顺序，通过接口的&lt;strong&gt;Class对象&lt;/strong&gt;，我们可以获取到接口的方法，然后通过方法反射调用实现类的方法，因为这是一个无参数的方法，所以只需要传null即可。&lt;/p&gt;\n&lt;h3 id=\&#34;26-获取父类相关信息\&#34;&gt;2.6 获取父类相关信息&lt;/h3&gt;\n&lt;p&gt;主要是使用&lt;code&gt;getSuperclass()&lt;/code&gt;方法获取父类，当然也可以获取父类的方法，执行父类的方法,首先创建一个&lt;code&gt;Animal.java&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Animal {\n    public void doSomething(){\n        System.out.println(&amp;quot;animal do something&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;Dog.java&lt;/code&gt;继承于&lt;code&gt;Animal.java&lt;/code&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Dog extends Animal{\n    public void doSomething(){\n        System.out.println(&amp;quot;Dog do something&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们可以通过反射创建&lt;code&gt;Dog&lt;/code&gt;对象，获取其父类&lt;code&gt;Animal&lt;/code&gt;以及创建对象，当然也可以获取&lt;code&gt;Animal&lt;/code&gt;的默认父类&lt;code&gt;Object&lt;/code&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Test {\n    public static void main(String[] args) throws Exception {\n        Class&amp;lt;?&amp;gt; dogClass = Class.forName(&amp;quot;invocation02.Dog&amp;quot;);\n        System.out.println(dogClass);\n        invoke(dogClass);\n\n        Class&amp;lt;?&amp;gt; animalClass = dogClass.getSuperclass();\n        System.out.println(animalClass);\n        invoke(animalClass);\n\n        Class&amp;lt;?&amp;gt; objectClass = animalClass.getSuperclass();\n        System.out.println(objectClass);\n        invoke(objectClass);\n    }\n\n    public static void invoke(Class&amp;lt;?&amp;gt; myClass) throws Exception {\n        Method[] methods = myClass.getMethods();\n        // 遍历接口的方法\n        for (Method method : methods) {\n            if (method.getName().equalsIgnoreCase(&amp;quot;doSomething&amp;quot;)) {\n                // 通过反射调用方法\n                method.invoke(myClass.newInstance(), null);\n            }\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输入如下：&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201114144931.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;27-获取当前类的公有属性和私有属性以及更新\&#34;&gt;2.7 获取当前类的公有属性和私有属性以及更新&lt;/h3&gt;\n&lt;p&gt;创建一个&lt;code&gt;Person.java&lt;/code&gt;,里面有静态变量，非静态变量，以及&lt;code&gt;public&lt;/code&gt;，&lt;code&gt;protected&lt;/code&gt;,&lt;code&gt;private&lt;/code&gt;不同修饰的属性。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Person {\n\n    public static String type ;\n\n    private static String subType ;\n\n    // 名字（公开）\n    public String name;\n\n    protected String gender;\n\n    private String address;\n\n    @Override\n    public String toString() {\n        return &amp;quot;Person{&amp;quot; +\n                &amp;quot;name=&#39;&amp;quot; + name + &#39;\\&#39;&#39; +\n                &amp;quot;, address=&#39;&amp;quot; + address + &#39;\\&#39;&#39; +\n                &#39;}&#39;;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用&lt;code&gt;getFields()&lt;/code&gt;可以获取到public的属性，包括static属性，使用&lt;code&gt;getDeclaredFields()&lt;/code&gt;可以获取所有声明的属性，不管是&lt;code&gt;public&lt;/code&gt;，&lt;code&gt;protected&lt;/code&gt;,&lt;code&gt;private&lt;/code&gt;不同修饰的属性。&lt;/p&gt;\n&lt;p&gt;修改&lt;code&gt;public&lt;/code&gt;属性,只需要&lt;code&gt;field.set(object，value)&lt;/code&gt;即可，但是&lt;code&gt;private&lt;/code&gt;属性不能直接set，否则会报以下的错误。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.IllegalAccessException: Class invocation03.Tests can not access a member of class invocation03.Person with modifiers &amp;quot;private&amp;quot;\n\tat sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102)\n\tat java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296)\n\tat java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288)\n\tat java.lang.reflect.Field.set(Field.java:761)\n\tat invocation03.Tests.main(Tests.java:21)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;那么需要怎么做呢？private默认是不允许外界操作其值的，这里我们可以使用&lt;code&gt;field.setAccessible(true);&lt;/code&gt;，相当于打开了操作的权限。&lt;/p&gt;\n&lt;p&gt;那static的属性修改和非static的一样，但是我们怎么获取呢？&lt;br&gt;\n如果是&lt;code&gt;public&lt;/code&gt;修饰的，可以直接用类名获取到，如果是&lt;code&gt;private&lt;/code&gt;修饰的，那么需要使用&lt;code&gt;filed.get(object)&lt;/code&gt;,这个方法其实对上面说的所有的属性都可以的。&lt;br&gt;\n测试代码如下&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Tests {\n    public static void main(String[] args) throws Exception{\n        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);\n        Field[] fields = personClass.getFields();\n        // 获取公开的属性\n        for(Field field:fields){\n            System.out.println(field);\n        }\n        System.out.println(&amp;quot;=================&amp;quot;);\n        // 获取所有声明的属性\n        Field[] declaredFields = personClass.getDeclaredFields();\n        for(Field field:declaredFields){\n            System.out.println(field);\n        }\n        System.out.println(&amp;quot;=================&amp;quot;);\n        Person person = (Person) personClass.newInstance();\n        person.name = &amp;quot;Sam&amp;quot;;\n        System.out.println(person);\n\n        // 修改public属性\n        Field fieldName = personClass.getDeclaredField(&amp;quot;name&amp;quot;);\n        fieldName.set(person,&amp;quot;Jone&amp;quot;);\n\n        // 修改private属性\n        Field addressName = personClass.getDeclaredField(&amp;quot;address&amp;quot;);\n        // 需要修改权限\n        addressName.setAccessible(true);\n        addressName.set(person,&amp;quot;东风路47号&amp;quot;);\n        System.out.println(person);\n\n        // 修改static 静态public属性\n        Field typeName = personClass.getDeclaredField(&amp;quot;type&amp;quot;);\n        typeName.set(person,&amp;quot;人类&amp;quot;);\n        System.out.println(Person.type);\n\n        // 修改静态 private属性\n        Field subType = personClass.getDeclaredField(&amp;quot;subType&amp;quot;);\n        subType.setAccessible(true);\n        subType.set(person,&amp;quot;黄种人&amp;quot;);\n        System.out.println(subType.get(person));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果：&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201114162617.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;从结果可以看出，不管是&lt;code&gt;public&lt;/code&gt;，还是&lt;code&gt;protected&lt;/code&gt;，&lt;code&gt;private&lt;/code&gt;修饰的，我们都可以通过反射对其进行查询和修改，不管是静态变量还是非静态变量。&lt;br&gt;\n&lt;code&gt;getDeclaredField()&lt;/code&gt;可以获取到所有声明的属性，而&lt;code&gt;getFields()&lt;/code&gt;则只能获取到&lt;code&gt;public&lt;/code&gt;的属性。对于非public的属性，我们需要修改其权限才能访问和修改：&lt;code&gt;field.setAccessible(true)&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;获取属性值需要使用&lt;code&gt;field.get(object)&lt;/code&gt;，值得注意的是：&lt;strong&gt;每个属性，其本身就是对象&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;28-获取以及调用类的公有私有方法\&#34;&gt;2.8 获取以及调用类的公有/私有方法&lt;/h3&gt;\n&lt;p&gt;既然可以获取到公有属性和私有属性，那么我想，执行公有方法和私有方法应该都不是什么问题？&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201115211213.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;那下面我们一起来学习一下...&lt;/p&gt;\n&lt;p&gt;先定义一个类，包含各种修饰符，以及是否包含参数，是否为静态方法，&lt;code&gt;Person.java&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Person {\n    // 非静态公有无参数\n    public void read(){\n        System.out.println(&amp;quot;reading...&amp;quot;);\n    }\n\n    // 非静态公有无参数有返回\n    public String getName(){\n        return &amp;quot;Sam&amp;quot;;\n    }\n\n    // 非静态公有带参数   \n    public int readABookPercent(String name){\n        System.out.println(&amp;quot;read &amp;quot;+name);\n        return 80;\n    }\n\n    // 私有有返回值\n    private String getAddress(){\n        return &amp;quot;东方路&amp;quot;;\n    }\n\n    // 公有静态无参数无返回值\n    public static void staticMethod(){\n        System.out.println(&amp;quot;static public method&amp;quot;);\n    }\n\n    // 公有静态有参数\n    public static void staticMethodWithArgs(String args){\n        System.out.println(&amp;quot;static public method:&amp;quot;+args);\n    }\n\n    // 私有静态方法\n    private static void staticPrivateMethod(){\n        System.out.println(&amp;quot;static private method&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;首先我们来看看获取里面所有的方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Tests {\n    public static void main(String[] args) throws Exception {\n        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);\n        Method[] methods = personClass.getMethods();\n        for (Method method : methods) {\n            System.out.println(method);\n        }\n\n        System.out.println(&amp;quot;=============================================&amp;quot;);\n        Method[] declaredMethods = personClass.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            System.out.println(method);\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果如下：&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116000934.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n咦，我们发现&lt;code&gt;getMethods()&lt;/code&gt;确实可以获取所有的公有的方法，但是有一个问题，就是他会把父类的也获取到，也就是上面图片绿色框里面的，我们知道所有的类默认都继承了&lt;code&gt;Object&lt;/code&gt;类，所以它把&lt;code&gt;Object&lt;/code&gt;的那些方法都获取到了。&lt;br&gt;\n而&lt;code&gt;getDeclaredMethods&lt;/code&gt;确实可以获取到公有和私有的方法，不管是静态还是非静态，但是它是获取不到父类的方法的。&lt;/p&gt;\n&lt;p&gt;那如果我们想调用方法呢？先试试调用非静态方法：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Tests {\n    public static void main(String[] args) throws Exception {\n        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);\n        Person person = (Person) personClass.newInstance();\n        Method[] declaredMethods = personClass.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if(method.getName().equalsIgnoreCase(&amp;quot;read&amp;quot;)){\n                method.invoke(person,null);\n                System.out.println(&amp;quot;===================&amp;quot;);\n            }else if(method.getName().equalsIgnoreCase(&amp;quot;getName&amp;quot;)){\n                System.out.println(method.invoke(person,null));\n                System.out.println(&amp;quot;===================&amp;quot;);\n            }else if(method.getName().equalsIgnoreCase(&amp;quot;readABookPercent&amp;quot;)){\n                System.out.println(method.invoke(person,&amp;quot;Sam&amp;quot;));\n                System.out.println(&amp;quot;===================&amp;quot;);\n            }\n        }\n\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果如下，可以看出&lt;code&gt;method.invoke(person,null);&lt;/code&gt;是调用无参数的方法，而&lt;code&gt;method.invoke(person,&amp;quot;Sam&amp;quot;)&lt;/code&gt;则是调用有参数的方法，要是有更多参数，也只需要在里面多加一个参数即可，返回值也同样可以获取到。&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116001756.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;那么&lt;code&gt;private&lt;/code&gt;方法呢？我们照着来试试，试试就试试，who 怕 who？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Tests {\n    public static void main(String[] args) throws Exception {\n        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);\n        Person person = (Person) personClass.newInstance();\n        Method[] declaredMethods = personClass.getDeclaredMethods();\n        for (Method method : declaredMethods) {\n            if(method.getName().equalsIgnoreCase(&amp;quot;getAddress&amp;quot;)){\n                method.invoke(person,null);\n            }\n        }\n\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果报错了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.IllegalAccessException: Class invocation03.Tests can not access a member of class invocation03.Person with modifiers &amp;quot;private&amp;quot;\n\tat sun.reflect.Reflection.ensureMemberAccess(Reflection.java:102)\n\tat java.lang.reflect.AccessibleObject.slowCheckMemberAccess(AccessibleObject.java:296)\n\tat java.lang.reflect.AccessibleObject.checkAccess(AccessibleObject.java:288)\n\tat java.lang.reflect.Method.invoke(Method.java:491)\n\tat invocation03.Tests.main(Tests.java:13)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116002147.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;一看就是没有权限，小场面，不要慌，我来操作一波,只要加上&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;method.setAccessible(true);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;哦豁，完美解决了...&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116002514.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;那么问题来了，上面说的都是非静态的，我就想要调用静态的方法。&lt;br&gt;\n当然用上面的方法，对象也可以直接调用到类的方法的：&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201116002936.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;一点问题都没有，为什么输出结果有几个null,那是因为这函数是无返回值的呀，笨蛋...&lt;/p&gt;\n&lt;p&gt;如果我不想用遍历方法的方式，再去判断怎么办？能不能直接获取到我想要的方法啊？那答案肯定是可以啊。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Tests {\n    public static void main(String[] args) throws Exception {\n        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);\n        Person person = (Person) personClass.newInstance();\n        Method method = personClass.getMethod(&amp;quot;readABookPercent&amp;quot;, String.class);\n        method.invoke(person, &amp;quot;唐诗三百首&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果和上面调用的完全一样，图我就不放了，就一行字。要是这个方法没有参数呢？那就给一个null就可以啦。或者不给也可以。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Tests {\n    public static void main(String[] args) throws Exception {\n        Class&amp;lt;?&amp;gt; personClass = Class.forName(&amp;quot;invocation03.Person&amp;quot;);\n        Person person = (Person) personClass.newInstance();\n        Method method = personClass.getMethod(&amp;quot;getName&amp;quot;,null);\n        System.out.println(method.invoke(person));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;三-反射的优缺点\&#34;&gt;三、反射的优缺点&lt;/h2&gt;\n&lt;h3 id=\&#34;31-优点\&#34;&gt;3.1 优点&lt;/h3&gt;\n&lt;p&gt;反射可以在不知道会运行哪一个类的情况下，获取到类的信息，创建对象以及操作对象。这其实很方便于拓展，所以反射会是框架设计的灵魂，因为框架在设计的时候，为了降低耦合度，肯定是需要考虑拓展等功能的，不能将类型写死，硬编码。&lt;/p&gt;\n&lt;p&gt;降低耦合度，变得很灵活，在运行时去确定类型，绑定对象，体现了多态功能。&lt;/p&gt;\n&lt;h3 id=\&#34;32-缺点\&#34;&gt;3.2 缺点&lt;/h3&gt;\n&lt;p&gt;这么好用，没有缺点？怎么可能！！！有利就有弊，事物都是有双面性的。&lt;br&gt;\n即使功能很强大，但是反射是需要动态类型的，&lt;code&gt;JVM&lt;/code&gt;没有办法优化这部分代码，执行效率相对直接初始化对象较低。一般业务代码不建议使用。&lt;/p&gt;\n&lt;p&gt;反射可以修改权限，比如上面访问到&lt;code&gt;private&lt;/code&gt;这些方法和属性，这是会破坏封装性的，有安全隐患，有时候，还会破坏单例的设计。&lt;/p&gt;\n&lt;p&gt;反射会使代码变得复杂，不容易维护，毕竟代码还是要先写给人看的嘛，逃~&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;【作者简介】&lt;/strong&gt;：&lt;br&gt;\n秦怀，公众号【&lt;strong&gt;秦怀杂货店&lt;/strong&gt;】作者，技术之路不在一时，山高水长，纵使缓慢，驰而不息。这个世界希望一切都很快，更快，但是我希望自己能走好每一步，写好每一篇文章，期待和你们一起交流。&lt;/p&gt;\n&lt;p&gt;此文章仅代表自己（本菜鸟）学习积累记录，或者学习笔记，如有侵权，请联系作者核实删除。人无完人，文章也一样，文笔稚嫩，在下不才，勿喷，如果有错误之处，还望指出，感激不尽~&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201012000828.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;java-fan-she-shi-yong-shuo-tou-che-yi-dian&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;很多时候我们会遇到别人问一个问题：你给我讲一下反射，到底是什么东西？怎么实现的？我们能用反射来做什么？它有什么优缺点？下面我们会围绕着这几个问题展开：&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Java反射使用说透彻一点&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;0NZgktxRxh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/0NZgktxRxh/&#34;}],&#34;date&#34;:&#34;2023-03-04 01:17:15&#34;,&#34;dateFormat&#34;:&#34;2023-03-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/java-fan-she-shi-yong-shuo-tou-che-yi-dian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;22 min read&#34;,&#34;time&#34;:1264000,&#34;words&#34;:4859,&#34;minutes&#34;:22},&#34;description&#34;:&#34;很多时候我们会遇到别人问一个问题：你给我讲一下反射，到底是什么东西？怎么实现的？我们能用反射来做什么？它有什么优缺点？下面我们会围绕着这几个问题展开：\n\n\n一、反射机制是什么？\n反射是什么？什么是反？什么是正射？\n有反就有正，我们知道正常情...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88\&#34;&gt;一、反射机制是什么？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8C-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8\&#34;&gt;二、反射的具体使用&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#21-%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%85%E5%90%8D%E4%BB%A5%E5%8F%8A%E7%B1%BB%E5%90%8D\&#34;&gt;2.1 获取对象的包名以及类名&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#22-%E8%8E%B7%E5%8F%96class%E5%AF%B9%E8%B1%A1\&#34;&gt;2.2 获取Class对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#23-getinstance%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1\&#34;&gt;2.3 getInstance()获取指定类型的实例化对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#24-%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1\&#34;&gt;2.4 通过构造函数对象实例化对象&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#25-%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%BB%A7%E6%89%BF%E7%9A%84%E6%8E%A5%E5%8F%A3\&#34;&gt;2.5 获取类继承的接口&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#26-%E8%8E%B7%E5%8F%96%E7%88%B6%E7%B1%BB%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF\&#34;&gt;2.6 获取父类相关信息&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#27-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E5%85%AC%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%96%B0\&#34;&gt;2.7 获取当前类的公有属性和私有属性以及更新&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#28-%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%8A%E8%B0%83%E7%94%A8%E7%B1%BB%E7%9A%84%E5%85%AC%E6%9C%89%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95\&#34;&gt;2.8 获取以及调用类的公有/私有方法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\&#34;&gt;三、反射的优缺点&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#31-%E4%BC%98%E7%82%B9\&#34;&gt;3.1 优点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#32-%E7%BC%BA%E7%82%B9\&#34;&gt;3.2 缺点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;今天一不小心跟进Object的源码中，发现一个&lt;code&gt;native&lt;/code&gt;关键字，一脸蒙蔽，怎么我从来没有用过。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;// 这是计算对象的hsahcode的方法，涉及到内存地址\npublic native int hashCode();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201118222529.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;1.汇编生&lt;code&gt;c&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;生万物,其实java要实现对底层的控制，还是需要&lt;code&gt;c/c++&lt;/code&gt;帮忙，老大毕竟是老大。&lt;/p&gt;\n&lt;p&gt;2.&lt;code&gt;native&lt;/code&gt;关键字我们开发应用的时候是用不到的，那什么时候用到呢？那些开发&lt;strong&gt;java语言&lt;/strong&gt;的时候用到，&lt;code&gt;native&lt;/code&gt;关键字是与&lt;code&gt;c++&lt;/code&gt;联合开发的时候使用的，要不java控制不了底层啊，比如内存。所以还是那句：汇编生&lt;code&gt;c&lt;/code&gt;,&lt;code&gt;c&lt;/code&gt;生万物，&lt;code&gt;c++&lt;/code&gt;是&lt;code&gt;c&lt;/code&gt;的升级版。&lt;/p&gt;\n&lt;p&gt;3.这是&lt;code&gt;java&lt;/code&gt;调用其他地方的接口的一个声明关键字，意思是这个方法不是java实现的,有挺多的编程语言都有这样的特性，比如&lt;code&gt;c++&lt;/code&gt;里面使用&lt;code&gt;extern &amp;quot;c&amp;quot;&lt;/code&gt;来表示告诉c++编译器去调用c里面已经实现好的函数，而不是自己去实现。&lt;code&gt;native&lt;/code&gt;方法有点像&lt;code&gt;java&lt;/code&gt; 里面的&lt;code&gt;interface&lt;/code&gt;，都不用去实现，而是有别人去实现，但是&lt;code&gt;interface&lt;/code&gt;是谁实现接口谁实现，&lt;code&gt;native&lt;/code&gt;方法是直接交给&lt;code&gt;c/c++&lt;/code&gt;来实现。&lt;code&gt;java&lt;/code&gt;只能调用，由操作系统实现。&lt;/p&gt;\n&lt;p&gt;4.&lt;code&gt;native&lt;/code&gt;方法不能与&lt;code&gt;abstract&lt;/code&gt;方法一起使用，因为&lt;code&gt;native&lt;/code&gt;表示这些方法是有实现体的，但是&lt;code&gt;abstract&lt;/code&gt;却表示这些方法是没有实现体的，那么两者矛盾，肯定也不能一起使用。&lt;/p&gt;\n&lt;h2 id=\&#34;1怎么调用到native方法的呢\&#34;&gt;1.怎么调用到native方法的呢？&lt;/h2&gt;\n&lt;p&gt;上面说&lt;code&gt;native&lt;/code&gt;表示这个方法不是&lt;code&gt;java&lt;/code&gt;实现的，那么就不是原生态方法，也就不会存在这个文件中，而是存在其他地方，那么java要怎么调用才能调用到呢？&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;ul&gt;\n&lt;li&gt;JNI(Java Native Interface)这是一个本机编程的接口，它也是java jdk（开发工具包）的一部分，JNI可以支持java中使用其他语言，java要调用其他语言的接口，需要经过他处理。java所谓的跨平台，在一定程度上放弃了底层操作，因为不同的硬件或者操作系统底层的操作都是不一样的。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://img-blog.csdnimg.cn/img_convert/31426e38350ffdfdc9bd09b72d13e877.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;那么我们现在来写一个程序：&lt;code&gt;helloWorld.java&lt;/code&gt;(我的所有写的文件都放在桌面，同个文件夹即可)&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class helloworld{\n  static\n  {\n    System.loadLibrary(&amp;quot;cSayHello&amp;quot;);\n  }\n  public static native void hello();\n  @SuppressWarnings(&amp;quot;static-access&amp;quot;)\n  public static void main(String[] args){\n    new helloworld().hello();\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;直接在编译器运行这段代码会出现下面错误：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://img-blog.csdnimg.cn/img_convert/9dee6cd8edb7a01ef8ebbded3d949a3e.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201118223648.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;上面的错误是说找不到&lt;code&gt;cSayHello&lt;/code&gt;:&lt;code&gt;no cSayHello in java.library.path&lt;/code&gt;,所以啊，这个&lt;code&gt;c/c++&lt;/code&gt;的方法我们要自己实现，毕竟我们用的不是操作系统以及定义好的方法。&lt;br&gt;\n所以我们先来，使用cmd &lt;strong&gt;在helloworld.java所在的目录下&lt;/strong&gt; 使用命令行:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;javac helloworld\njavah helloworld\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://img-blog.csdnimg.cn/img_convert/db0557017bfcf65baf30b09cdfe13529.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;然后我们可以看到&lt;strong&gt;在helloworld.java所在的目录下&lt;/strong&gt;多了两个文件，一个是&lt;strong&gt;helloworld.class&lt;/strong&gt;文件,一个是&lt;strong&gt;helloworld.h&lt;/strong&gt;文件。&lt;/p&gt;\n&lt;p&gt;打开&lt;strong&gt;helloworld.h&lt;/strong&gt;,里面引用了&lt;strong&gt;jni.h&lt;/strong&gt;这个文件，这个文件在我们安装的&lt;code&gt;java&lt;/code&gt;目录下面的&lt;code&gt;include&lt;/code&gt;文件下:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;/* DO NOT EDIT THIS FILE - it is machine generated */\n#include &amp;lt;jni.h&amp;gt;\n/* Header for class helloworld */\n\n#ifndef _Included_helloworld\n#define _Included_helloworld\n#ifdef __cplusplus\nextern &amp;quot;C&amp;quot; {\n#endif\n/*\n * Class:     helloworld\n * Method:    hello\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_helloworld_hello\n  (JNIEnv *, jclass);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我的&lt;code&gt;java&lt;/code&gt;是装在&lt;code&gt;D盘&lt;/code&gt;下面：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://img-blog.csdnimg.cn/img_convert/c4244e20fac830111b6b8c9dcc12e6c2.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;我们来写需要引入的&lt;code&gt;c&lt;/code&gt;文件&lt;code&gt;cSayHello&lt;/code&gt;,我也是放在桌面，反正同一个文件夹就可以。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;#include &amp;quot;helloworld.h&amp;quot;\n#include &amp;lt;stdio.h&amp;gt;\n \nJNIEXPORT void JNICALL Java_helloworld_hello(JNIEnv *env, jclass jc)\n{\n    printf(&amp;quot;java helloworld&amp;quot;);    \n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在&lt;code&gt;windows&lt;/code&gt;系统上，需要下载安装&lt;code&gt;WinGW Gcc&lt;/code&gt;，安装教程参考https://www.jianshu.com/p/535a3131ccd8, 安装成功&lt;code&gt;cmd&lt;/code&gt;输入：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;gcc -m64  -Wl,--add-stdcall-alias -I&amp;quot;D:\\Java\\jdk1.8.0_111\\include&amp;quot; -I&amp;quot;D:\\Java\\jdk1.8.0_111\\include\\win32&amp;quot; -shared -o cSayHello.dll helloworld.c\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后直接运行,就可以看到输出了&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;java helloworld\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;2-java调用自定义native方法步骤\&#34;&gt;2. java调用自定义native方法步骤&lt;/h2&gt;\n&lt;p&gt;在java中使用native的步骤：&lt;br&gt;\n1.在java代码中声明native方法&lt;br&gt;\n2.执行javah来生成一个.h文件&lt;br&gt;\n3.写.cpp文件来实现native导出的方法，需要包含上面第二步产生的.h文件，同时也包含了jdk自带的jni.h&lt;br&gt;\n4.将第三步的.cpp文件通过gcc 编译成动态链接库文件&lt;br&gt;\n5.在java中使用的用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问&lt;br&gt;\n一般情况下，我们jdk中声明的native方法，在编译的时候都会自动去加载动态链接库文件，而不需要我们自己去操作了。&lt;/p&gt;\n&lt;h2 id=\&#34;3使用native的缺点\&#34;&gt;3.使用native的缺点&lt;/h2&gt;\n&lt;p&gt;使用native的缺点：可移植性差，把对底层的控制权交给其他语言，那么也会出现不稳定性，庆幸的是现在操作系统的底层实现基本不会改变。上面hsahcode()的计算真是通过内存所在的内存块来计算的，java是无法直接操作内存的。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;【作者简介】&lt;/strong&gt;：&lt;br&gt;\n秦怀，公众号【&lt;strong&gt;秦怀杂货店&lt;/strong&gt;】作者，技术之路不在一时，山高水长，纵使缓慢，驰而不息。这个世界希望一切都很快，更快，但是我希望自己能走好每一步，写好每一篇文章，期待和你们一起交流。&lt;/p&gt;\n&lt;p&gt;此文章仅代表自己（本菜鸟）学习积累记录，或者学习笔记，如有侵权，请联系作者核实删除。人无完人，文章也一样，文笔稚嫩，在下不才，勿喷，如果有错误之处，还望指出，感激不尽~&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201012000828.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;java-native-guan-jian-zi&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;今天一不小心跟进Object的源码中，发现一个&lt;code&gt;native&lt;/code&gt;关键字，一脸蒙蔽，怎么我从来没有用过。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;java native关键字&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Java&#34;,&#34;slug&#34;:&#34;0NZgktxRxh&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/0NZgktxRxh/&#34;}],&#34;date&#34;:&#34;2023-03-04 01:16:18&#34;,&#34;dateFormat&#34;:&#34;2023-03-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/java-native-guan-jian-zi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:326000,&#34;words&#34;:1415,&#34;minutes&#34;:6},&#34;description&#34;:&#34;\n今天一不小心跟进Object的源码中，发现一个native关键字，一脸蒙蔽，怎么我从来没有用过。\n\n// 这是计算对象的hsahcode的方法，涉及到内存地址\npublic native int hashCode();\n\n\n1.汇编生c,...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1%E6%80%8E%E4%B9%88%E8%B0%83%E7%94%A8%E5%88%B0native%E6%96%B9%E6%B3%95%E7%9A%84%E5%91%A2\&#34;&gt;1.怎么调用到native方法的呢？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-java%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89native%E6%96%B9%E6%B3%95%E6%AD%A5%E9%AA%A4\&#34;&gt;2. java调用自定义native方法步骤&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3%E4%BD%BF%E7%94%A8native%E7%9A%84%E7%BC%BA%E7%82%B9\&#34;&gt;3.使用native的缺点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数据，可以直接返回空。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;关于缓存，一般会有以下几个常见的问题&lt;/p&gt;\n&lt;h2 id=\&#34;缓存穿透\&#34;&gt;缓存穿透&lt;/h2&gt;\n&lt;p&gt;缓存穿透是指，&lt;strong&gt;缓存和数据库都没有的数据&lt;/strong&gt;，被大量请求，比如订单号不可能为&lt;code&gt;-1&lt;/code&gt;，但是用户请求了大量订单号为&lt;code&gt;-1&lt;/code&gt;的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。&lt;br&gt;\n如果被恶意用户利用，疯狂请求不存在的数据，就会导致数据库压力过大，甚至垮掉。&lt;/p&gt;\n&lt;p&gt;注意：穿透的意思是，都没有，直接一路打到数据库。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;那对于这种情况，我们该如何解决呢？&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;接口增加业务层级的&lt;code&gt;Filter&lt;/code&gt;，进行合法校验，这可以有效拦截大部分不合法的请求。&lt;/li&gt;\n&lt;li&gt;作为第一点的补充，最常见的是使用布隆过滤器，针对一个或者多个维度，把可能存在的数据值hash到bitmap中，bitmap证明该数据不存在则该数据一定不存在，但是bitmap证明该数据存在也只能是可能存在，因为不同的数值hash到的bit位很有可能是一样的，hash冲突会导致误判，多个hash方法也只能是降低冲突的概率，无法做到避免。&lt;/li&gt;\n&lt;li&gt;另外一个常见的方法，则是针对数据库与缓存都没有的数据，对空的结果进行缓存，但是过期时间设置得较短，一般五分钟内。而这种数据，如果数据库有写入，或者更新，必须同时刷新缓存，否则会导致不一致的问题存在。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;缓存击穿\&#34;&gt;缓存击穿&lt;/h2&gt;\n&lt;p&gt;缓存击穿是指数据库原本有得数据，但是缓存中没有，一般是缓存突然失效了，这时候如果有大量用户请求该数据，缓存没有则会去数据库请求，会引发数据库压力增大，可能会瞬间打垮。&lt;/p&gt;\n&lt;p&gt;针对这类问题，一般有以下做法：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;如果是热点数据，那么可以考虑设置永远不过期。&lt;/li&gt;\n&lt;li&gt;如果数据一定会过期，那么就需要在数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，要不其他线程会一直拿不到锁。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;下面是缓存击穿的时候互斥锁的写法，注意：获取锁之后操作，不管成功或者失败，都应该释放锁，而其他的请求，如果没有获取到锁，应该等待，再重试。当然，如果是需要更加全面一点，应该加上一个等待次数，比如1s中，那么也就是睡眠五次，达到这个阈值，则直接返回空，不应该过度消耗机器，以免当个不可用的场景把整个应用的服务器带挂了。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public static String getProductDescById(String id) {\n        String desc = redis.get(id);\n        // 缓存为空，过期了\n        if (desc == null) {\n            // 互斥锁，只有一个请求可以成功\n            if (redis.setnx(lock_id, 1, 60) == 1) {\n                try {\n                    // 从数据库取出数据\n                    desc = getFromDB(id);\n                    redis.set(id, desc, 60 * 60 * 24);\n                } catch (Exception ex) {\n                    LogHelper.error(ex);\n                } finally {\n                    // 确保最后删除，释放锁\n                    redis.del(lock_id);\n                    return desc;\n                }\n            } else {\n                // 否则睡眠200ms，接着获取锁\n                Thread.sleep(200);\n                return getProductDescById(id);\n            }\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;缓存雪崩\&#34;&gt;缓存雪崩&lt;/h2&gt;\n&lt;p&gt;缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。&lt;/p&gt;\n&lt;p&gt;针对这种情况，一般我们都是使用以下方案：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;如果是热点数据，那么可以考虑设置永远不过期。&lt;/li&gt;\n&lt;li&gt;缓存的过期时间除非比较严格，要不考虑设置一个波动随机值，比如理论十分钟，那这类key的缓存时间都加上一个1&lt;sub&gt;3分钟，过期时间在7&lt;/sub&gt;13分钟内波动，有效防止都在同一个时间点上大量过期。&lt;/li&gt;\n&lt;li&gt;方法1避免了有效过期的情况，但是要是所有的热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此将热点数据打散分不到不同的机房中，也可以有效减少这种情况。&lt;/li&gt;\n&lt;li&gt;也可以考虑双缓存的方式，数据库数据同步到缓存A和B，A设置过期时间，B不设置过期时间，如果A为空的时候去读B，同时异步去更新缓存，但是更新的时候需要同时更新两个缓存。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;比如设置产品的缓存时间：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;redis.set(id,value,60*60 + Math.random()*1000);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;小结\&#34;&gt;小结&lt;/h2&gt;\n&lt;p&gt;缓存穿透是指数据库原本就没有的数据，请求如入无人之境，直奔数据库，而缓存击穿，则是指数据库有数据，缓存也本应该有数据，但是突然缓存过期了，这层保护屏障被击穿了，请求直奔数据库，缓存雪崩则是指很多缓存同一个时间失效了，流量全部涌入数据库，造成数据库极大的压力。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;huan-cun-chuan-tou-huan-cun-ji-chuan-huan-cun-xue-beng-de-qu-bie-yi-ji-jie-jue-fang-an&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数据，可以直接返回空。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;缓存穿透，缓存击穿，缓存雪崩的区别以及解决方案&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;缓存&#34;,&#34;slug&#34;:&#34;tDPQ3ooZG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/tDPQ3ooZG/&#34;}],&#34;date&#34;:&#34;2023-03-04 01:14:20&#34;,&#34;dateFormat&#34;:&#34;2023-03-04&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/huan-cun-chuan-tou-huan-cun-ji-chuan-huan-cun-xue-beng-de-qu-bie-yi-ji-jie-jue-fang-an/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:310000,&#34;words&#34;:1484,&#34;minutes&#34;:6},&#34;description&#34;:&#34;\n平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F\&#34;&gt;缓存穿透&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF\&#34;&gt;缓存击穿&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9\&#34;&gt;缓存雪崩&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B0%8F%E7%BB%93\&#34;&gt;小结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;前面我们已经讲过布隆过滤器的原理，都理解是这么运行的，那么一般我们使用布隆过滤器，是怎么去使用呢？如果自己去实现，又是怎么实现呢？&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;[TOC]&lt;/p&gt;\n&lt;h2 id=\&#34;布隆过滤器\&#34;&gt;布隆过滤器&lt;/h2&gt;\n&lt;p&gt;&lt;strong&gt;再念一次定义：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;布隆过滤器（&lt;code&gt;Bloom Filter&lt;/code&gt;）是由布隆（&lt;code&gt;Burton Howard Bloom&lt;/code&gt;）在 1970 年提出的，它实际上是由一个很长的二进制向量和一系列随机&lt;code&gt;hash&lt;/code&gt;映射函数组成（说白了，就是用二进制数组存储数据的特征）。&lt;/p&gt;\n&lt;p&gt;譬如下面例子：有三个&lt;code&gt;hash&lt;/code&gt;函数，那么“陈六”就会被三个&lt;code&gt;hash&lt;/code&gt;函数分别&lt;code&gt;hash&lt;/code&gt;，并且对位数组的长度，进行取余，分别hash到三个位置。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233900.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;如果对原理还有不理解的地方，可以查看我的上一篇文章。&lt;/p&gt;\n&lt;h2 id=\&#34;手写布隆过滤器\&#34;&gt;手写布隆过滤器&lt;/h2&gt;\n&lt;p&gt;那么我们手写布隆过滤器的时候，首先需要一个位数组，在&lt;code&gt;Java&lt;/code&gt;里面有一个封装好的位数组，&lt;code&gt;BitSet&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;简单介绍一下&lt;code&gt;BitSet&lt;/code&gt;，也就是位图，里面实现了使用紧凑的存储空间来表示大空间的位数据。使用的时候，我们可以直接指定大小，也就是相当于创建出指定大小的位数组。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;BitSet bits = new BitSet(size);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;同时，&lt;code&gt;BitSet&lt;/code&gt;提供了大量的&lt;code&gt;API&lt;/code&gt;，基本的操作主要包括：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;清空位数组的数据&lt;/li&gt;\n&lt;li&gt;翻转某一位的数据&lt;/li&gt;\n&lt;li&gt;设置某一位的数据&lt;/li&gt;\n&lt;li&gt;获取某一位的数据&lt;/li&gt;\n&lt;li&gt;获取当前的&lt;code&gt;bitSet&lt;/code&gt;的位数&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;下面就讲一下，写一个简单的布隆过滤器需要考虑的点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;位数组的大小空间，需要指定，其他相同的时候，位数组的大小越大，&lt;code&gt;hash&lt;/code&gt;冲突的可能性越小。&lt;/li&gt;\n&lt;li&gt;多个&lt;code&gt;hash&lt;/code&gt;函数，我们需要使用&lt;code&gt;hash&lt;/code&gt;数组来存，&lt;code&gt;hash&lt;/code&gt;函数需要如何设置呢？为了避免冲突，我们应该使用多个不同的质数来当种子。&lt;/li&gt;\n&lt;li&gt;方法：主要实现两个方法，一个往布隆过滤器里面添加元素，另一个是判断布隆过滤器是否包含某个元素。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;下面是具体的实现,只是简单的模拟，不可用于生产环境，&lt;code&gt;hash&lt;/code&gt;函数较为简单，主要是使用 &lt;code&gt;hash&lt;/code&gt; 值得高低位进行异或，然后乘以种子，再对位数组大小进行取余数：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.util.BitSet;\n\npublic class MyBloomFilter {\n\n    // 默认大小\n    private static final int DEFAULT_SIZE = Integer.MAX_VALUE;\n\n    // 最小的大小\n    private static final int MIN_SIZE = 1000;\n\n    // 大小为默认大小\n    private int SIZE = DEFAULT_SIZE;\n\n    // hash函数的种子因子\n    private static final int[] HASH_SEEDS = new int[]{3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\n\n    // 位数组，0/1,表示特征\n    private BitSet bitSet = null;\n\n    // hash函数\n    private HashFunction[] hashFunctions = new HashFunction[HASH_SEEDS.length];\n\n    // 无参数初始化\n    public MyBloomFilter() {\n        // 按照默认大小\n        init();\n    }\n\n    // 带参数初始化\n    public MyBloomFilter(int size) {\n        // 大小初始化小于最小的大小\n        if (size &amp;gt;= MIN_SIZE) {\n            SIZE = size;\n        }\n        init();\n    }\n\n    private void init() {\n        // 初始化位大小\n        bitSet = new BitSet(SIZE);\n        // 初始化hash函数\n        for (int i = 0; i &amp;lt; HASH_SEEDS.length; i++) {\n            hashFunctions[i] = new HashFunction(SIZE, HASH_SEEDS[i]);\n        }\n    }\n\n    // 添加元素，相当于把元素的特征添加到位数组\n    public void add(Object value) {\n        for (HashFunction f : hashFunctions) {\n            // 将hash计算出来的位置为true\n            bitSet.set(f.hash(value), true);\n        }\n    }\n\n    // 判断元素的特征是否存在于位数组\n    public boolean contains(Object value) {\n        boolean result = true;\n        for (HashFunction f : hashFunctions) {\n            result = result &amp;amp;&amp;amp; bitSet.get(f.hash(value));\n            // hash函数只要有一个计算出为false，则直接返回\n            if (!result) {\n                return result;\n            }\n        }\n        return result;\n    }\n\n    // hash函数\n    public static class HashFunction {\n        // 位数组大小\n        private int size;\n        // hash种子\n        private int seed;\n\n        public HashFunction(int size, int seed) {\n            this.size = size;\n            this.seed = seed;\n        }\n\n        // hash函数\n        public int hash(Object value) {\n            if (value == null) {\n                return 0;\n            } else {\n                // hash值\n                int hash1 = value.hashCode();\n                // 高位的hash值\n                int hash2 = hash1 &amp;gt;&amp;gt;&amp;gt; 16;\n                // 合并hash值(相当于把高低位的特征结合)\n                int combine = hash1 ^ hash1;\n                // 相乘再取余\n                return Math.abs(combine * seed) % size;\n            }\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Integer num1 = new Integer(12321);\n        Integer num2 = new Integer(12345);\n        MyBloomFilter myBloomFilter =new MyBloomFilter();\n        System.out.println(myBloomFilter.contains(num1));\n        System.out.println(myBloomFilter.contains(num2));\n\n        myBloomFilter.add(num1);\n        myBloomFilter.add(num2);\n\n        System.out.println(myBloomFilter.contains(num1));\n        System.out.println(myBloomFilter.contains(num2));\n\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果,符合预期：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;false\nfalse\ntrue\ntrue\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是上面的这种做法是不支持预期的误判率的，只是可以指定位数组的大小。&lt;/p&gt;\n&lt;p&gt;当然我们也可以提供数据量，以及期待的大致的误判率来初始化，大致的初始化代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    // 带参数初始化\n    public BloomFilter(int num,double rate) {\n        // 计算位数组的大小\n        this.size = (int) (-num * Math.log(rate) / Math.pow(Math.log(2), 2));\n        // hsah 函数个数\n        this.hashSize = (int) (this.size * Math.log(2) / num);\n        // 初始化位数组\n        this.bitSet = new BitSet(size);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;redis实现\&#34;&gt;Redis实现&lt;/h2&gt;\n&lt;p&gt;平时我们可以选择使用&lt;code&gt;Redis&lt;/code&gt;的特性于布隆过滤器，为什么呢？因为&lt;code&gt;Redis&lt;/code&gt;里面有类似于&lt;code&gt;BitSet&lt;/code&gt;的指令，比如设置位数组的值：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;setbit key offset value\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的&lt;code&gt;key&lt;/code&gt;是键，&lt;code&gt;offset&lt;/code&gt;是偏移量，&lt;code&gt;value&lt;/code&gt;就是&lt;code&gt;1&lt;/code&gt;或者&lt;code&gt;0&lt;/code&gt;。比如下面的就是将key1 的第7位置为1。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210314110134.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;而获取某一位的数值可以使用下面这个命令：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;gitbit key offset\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;借助&lt;code&gt;redis&lt;/code&gt;这个功能我们可以实现优秀的布隆过滤器，但是实际上我们不需要自己去写了，&lt;code&gt;Redisson&lt;/code&gt;这个客户端已经有较好的实现。&lt;br&gt;\n下面就是用法：&lt;br&gt;\n使用&lt;code&gt;maven&lt;/code&gt;构建项目，首先需要导包到&lt;code&gt;pom.xml&lt;/code&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-xml\&#34;&gt;    &amp;lt;dependencies&amp;gt;\n        &amp;lt;dependency&amp;gt;\n            &amp;lt;groupId&amp;gt;org.redisson&amp;lt;/groupId&amp;gt;\n            &amp;lt;artifactId&amp;gt;redisson&amp;lt;/artifactId&amp;gt;\n            &amp;lt;version&amp;gt;3.11.2&amp;lt;/version&amp;gt;\n        &amp;lt;/dependency&amp;gt;\n    &amp;lt;/dependencies&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;代码如下，我使用的&lt;code&gt;docker&lt;/code&gt;，启动的时候记得设置密码，运行的时候修改密码不起效果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;docker run -d --name redis -p 6379:6379 redis --requirepass &amp;quot;password&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;实现的代码如下，首先需要连接上&lt;code&gt;redis&lt;/code&gt;，然后创建&lt;code&gt;redission&lt;/code&gt;，使用&lt;code&gt;redission&lt;/code&gt;创建布隆过滤器，直接使用即可。（&lt;strong&gt;可以指定预计的数量以及期待的误判率&lt;/strong&gt;）&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import org.redisson.Redisson;\nimport org.redisson.api.RBloomFilter;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\n\npublic class BloomFilterTest {\n    public static void main(String[] args) {\n        Config config = new Config();\n        config.useSingleServer().setAddress(&amp;quot;redis://localhost:6379&amp;quot;);\n        config.useSingleServer().setPassword(&amp;quot;password&amp;quot;);\n        // 相当于创建了redis的连接\n        RedissonClient redisson = Redisson.create(config);\n\n        RBloomFilter&amp;lt;String&amp;gt; bloomFilter = redisson.getBloomFilter(&amp;quot;myBloomFilter&amp;quot;);\n        //初始化,预计元素数量为100000000,期待的误差率为4%\n        bloomFilter.tryInit(100000000,0.04);\n        //将号码10086插入到布隆过滤器中\n        bloomFilter.add(&amp;quot;12345&amp;quot;);\n\n        System.out.println(bloomFilter.contains(&amp;quot;123456&amp;quot;));//false\n        System.out.println(bloomFilter.contains(&amp;quot;12345&amp;quot;));//true\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果如下：值得注意的是，这是单台&lt;code&gt;redis&lt;/code&gt;的情况，如果是&lt;code&gt;redis&lt;/code&gt;集群的做法略有不同。&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210314233301.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h2 id=\&#34;google-guava实现\&#34;&gt;Google GUAVA实现&lt;/h2&gt;\n&lt;p&gt;&lt;code&gt;Google&lt;/code&gt;提供的&lt;code&gt;guava&lt;/code&gt;包里面也提供了布隆过滤器,引入&lt;code&gt;pom&lt;/code&gt;文件：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-xml\&#34;&gt;        &amp;lt;dependency&amp;gt;\n            &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;\n            &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;\n            &amp;lt;version&amp;gt;18.0&amp;lt;/version&amp;gt;\n        &amp;lt;/dependency&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;具体的实现调用的代码如下,同样可以指定具体的存储数量以及预计的误判率：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import com.google.common.base.Charsets;\nimport com.google.common.hash.BloomFilter;\nimport com.google.common.hash.Funnels;\n\npublic class GuavaBloomFilter {\n    public static void main(String[] args) {\n        BloomFilter&amp;lt;String&amp;gt; bloomFilter = BloomFilter.create(\n                Funnels.stringFunnel(Charsets.UTF_8),1000000,0.04);\n\n        bloomFilter.put(&amp;quot;Sam&amp;quot;);\n\n        System.out.println(bloomFilter.mightContain(&amp;quot;Jane&amp;quot;));\n        System.out.println(bloomFilter.mightContain(&amp;quot;Sam&amp;quot;));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行的结果如下,符合预期&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210314234457.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;上面三种分别是手写，&lt;code&gt;redis&lt;/code&gt;，&lt;code&gt;guava&lt;/code&gt;实践了布隆过滤器，只是简单的用法，其实&lt;code&gt;redis&lt;/code&gt;和&lt;code&gt;guava&lt;/code&gt;里面的实现也可以看看，有兴趣可以了解一下，我先立一个&lt;code&gt;Flag&lt;/code&gt;。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;bu-long-guo-lu-qi-de-san-chong-shi-jian&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;前面我们已经讲过布隆过滤器的原理，都理解是这么运行的，那么一般我们使用布隆过滤器，是怎么去使用呢？如果自己去实现，又是怎么实现呢？&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;布隆过滤器的三种实践&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;布隆过滤器&#34;,&#34;slug&#34;:&#34;oNYr9Gm6H&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/oNYr9Gm6H/&#34;}],&#34;date&#34;:&#34;2023-03-02 23:09:02&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/bu-long-guo-lu-qi-de-san-chong-shi-jian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:471000,&#34;words&#34;:1847,&#34;minutes&#34;:8},&#34;description&#34;:&#34;\n前面我们已经讲过布隆过滤器的原理，都理解是这么运行的，那么一般我们使用布隆过滤器，是怎么去使用呢？如果自己去实现，又是怎么实现呢？\n\n[TOC]\n布隆过滤器\n再念一次定义：\n布隆过滤器（Bloom Filter）是由布隆（Burton H...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8\&#34;&gt;布隆过滤器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%8B%E5%86%99%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8\&#34;&gt;手写布隆过滤器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#redis%E5%AE%9E%E7%8E%B0\&#34;&gt;Redis实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#google-guava%E5%AE%9E%E7%8E%B0\&#34;&gt;Google GUAVA实现&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;前面我们提到，在防止缓存穿透的情况（缓存穿透是指，&lt;strong&gt;缓存和数据库都没有的数据&lt;/strong&gt;，被大量请求，比如订单号不可能为&lt;code&gt;-1&lt;/code&gt;，但是用户请求了大量订单号为&lt;code&gt;-1&lt;/code&gt;的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。）,我们可以考虑使用布隆过滤器，来过滤掉绝对不存于集合中的元素。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;布隆过滤器是什么呢\&#34;&gt;布隆过滤器是什么呢？&lt;/h2&gt;\n&lt;p&gt;布隆过滤器（Bloom Filter）是由布隆（Burton Howard Bloom）在1970年提出的，它实际上是由一个很长的二进制向量和一系列随机hash映射函数组成（说白了，就是用二进制数组存储数据的特征）。可以使用它来判断一个元素是否存在于集合中，它的优点在于查询效率高，空间小，缺点是存在一定的误差，以及我们想要剔除元素的时候，可能会相互影响。&lt;/p&gt;\n&lt;p&gt;也就是当一个元素被加入集合的时候，通过多个hash函数，将元素映射到位数组中的k个点，置为1。&lt;/p&gt;\n&lt;h2 id=\&#34;为什么需要布隆过滤器\&#34;&gt;为什么需要布隆过滤器？&lt;/h2&gt;\n&lt;p&gt;一般情况下，我们想要判断是否存在某个元素，一开始考虑肯定是使用数组，但是使用数组的情况，查找的时候效率比较慢，要判断一个元素不存在于数组中，需要每次遍历完所有的元素。删除完一个元素后，还得把后面的其他元素往前面移动。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308225741.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;其实可以考虑使用&lt;code&gt;hash&lt;/code&gt;表，如果有&lt;code&gt;hash&lt;/code&gt;表来存储，将是以下的结构：&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308230509.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;但是这种结构，虽然满足了大部分的需求，可能存在两点缺陷：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;只有一个hash函数，其实两个元素hash到一块，也就是产生hash冲突的可能性，还是比较高的。虽然可以用拉链法（后面跟着一个链表）的方式解决，但是操作时间复杂度可能有所升高。&lt;/li&gt;\n&lt;li&gt;存储的时候，我们需要把元素引用给存储进去，要是上亿的数据，我们要将上亿的数据存储到一个hash表里面，不太建议这样操作。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;对于上面存在的缺陷，其实我们可以考虑，用多个hash函数来减少冲突（注意：冲突时不可以避免的，只能减少），用位来存储每一个hash值。这样既可以减少hash冲突，还可以减少存储空间。&lt;/p&gt;\n&lt;p&gt;假设有三个hash函数，那么不同的元素，都会使用三个hash函数，hash到三个位置上。&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233116.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;假设后面又来了一个张三，那么在hash的时候，同样会hash到以下位置，所有位都是1，我们就可以说张三已经存在在里面了。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233607.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;那么有没有可能出现误判的情况呢？这是有可能的，比如现在只有张三，李四，王五，蔡八，hash映射值如下：&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233752.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;后面来了陈六，但是不凑巧的是，它hash的三个函数hash出来的位，刚刚好就是被别的元素hash之后，改成1了，判断它已经存在了，但是实际上，陈六之前是不存在的。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233900.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;上面的情况，就是误判，布隆过滤器都会不可避免的出现误判。但是它有一个好处是，&lt;strong&gt;布隆过滤器，判断存在的元素，可能不存在，但是判断不存在的元素，一定不存在。&lt;/strong&gt;，因为判断不存在说明至少有一位hash出来是对不上的。&lt;/p&gt;\n&lt;p&gt;也是由于会出现多个元素可能hash到一起，但有一个数据被踢出了集合，我们想把它映射的位，置为0，相当于删除该数据。这个时候，就会影响到其他的元素，可能会把别的元素映射的位，置为了0。这也就是为什么布隆过滤器不能删除的原因。&lt;/p&gt;\n&lt;h2 id=\&#34;具体步骤\&#34;&gt;具体步骤&lt;/h2&gt;\n&lt;p&gt;添加元素：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ol&gt;\n&lt;li&gt;使用多个hash函数对元素item进行hash运算，得到多个hash值。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;每一个hash值对bit位数组取模，得到位数组中的位置索引index。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;如果index的位置不为1，那么就将该位置为1。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;判断元素是否存在：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;ol&gt;\n&lt;li&gt;使用多个hash函数对元素item进行hash运算，得到多个hash值。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;每一个hash值对bit位数组取模，得到位数组中的位置索引index。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;ol start=\&#34;3\&#34;&gt;\n&lt;li&gt;如果index所处的位置都为1，说明元素可能已经存在了。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;误判率推导\&#34;&gt;误判率推导&lt;/h2&gt;\n&lt;p&gt;庆幸的是，布隆过滤器的误判率是可以预测的，由上面的分析，也可以得知，其实是与位数组的大小，以及hash函数的个数等，这些都是息息相关的。&lt;/p&gt;\n&lt;p&gt;假设位数组的大小是m，我们一共有k个hash函数，那么每一个hash函数，进行hash的时候，只能hash到m位中的一个位置，所以没有被hash到的概率是：&lt;/p&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;1-\\frac{1}{m}\n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.72777em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:2.00744em;vertical-align:-0.686em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mopen nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mfrac\&#34;&gt;&lt;span class=\&#34;vlist-t vlist-t2\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:1.32144em;\&#34;&gt;&lt;span style=\&#34;top:-2.314em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.23em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;frac-line\&#34; style=\&#34;border-bottom-width:0.04em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.677em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-s\&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.686em;\&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;k个hash函数都hash之后，该位还是没有被hash到1的概率是：&lt;/p&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(1-\\frac{1}{m})^k\n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:2.00744em;vertical-align:-0.686em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mopen nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mfrac\&#34;&gt;&lt;span class=\&#34;vlist-t vlist-t2\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:1.32144em;\&#34;&gt;&lt;span style=\&#34;top:-2.314em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.23em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;frac-line\&#34; style=\&#34;border-bottom-width:0.04em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.677em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-s\&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.686em;\&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.8991079999999999em;\&#34;&gt;&lt;span style=\&#34;top:-3.113em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34; style=\&#34;margin-right:0.03148em;\&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;如果我们插入了n个元素，也就是hash了n*k次，该位还是没有被hash成1的概率是：&lt;/p&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(1-\\frac{1}{m})^{kn}\n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:2.00744em;vertical-align:-0.686em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mopen nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mfrac\&#34;&gt;&lt;span class=\&#34;vlist-t vlist-t2\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:1.32144em;\&#34;&gt;&lt;span style=\&#34;top:-2.314em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.23em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;frac-line\&#34; style=\&#34;border-bottom-width:0.04em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.677em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-s\&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.686em;\&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.8991079999999999em;\&#34;&gt;&lt;span style=\&#34;top:-3.113em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34; style=\&#34;margin-right:0.03148em;\&#34;&gt;k&lt;/span&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;那该位为1的概率就是：&lt;/p&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;1-(1-\\frac{1}{m})^{kn}\n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.72777em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:2.00744em;vertical-align:-0.686em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mopen nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mfrac\&#34;&gt;&lt;span class=\&#34;vlist-t vlist-t2\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:1.32144em;\&#34;&gt;&lt;span style=\&#34;top:-2.314em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.23em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;frac-line\&#34; style=\&#34;border-bottom-width:0.04em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.677em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-s\&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.686em;\&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.8991079999999999em;\&#34;&gt;&lt;span style=\&#34;top:-3.113em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34; style=\&#34;margin-right:0.03148em;\&#34;&gt;k&lt;/span&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;如果需要检测某一个元素是不是在集合中，也就是该元素对应的k个hash元素hash出来的值，都需要设置为1。也就是该元素不存在，但是该元素对应的所有位都被hash成为1的概率是：&lt;/p&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;mo&gt;≈&lt;/mo&gt;&lt;msup&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;{(1-(1-\\frac{1}{m})^{kn})}^{k}\\approx {(1-e^{-kn/m})}^k \n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:2.246448em;vertical-align:-0.686em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mopen nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mfrac\&#34;&gt;&lt;span class=\&#34;vlist-t vlist-t2\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:1.32144em;\&#34;&gt;&lt;span style=\&#34;top:-2.314em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.23em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;frac-line\&#34; style=\&#34;border-bottom-width:0.04em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.677em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-s\&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.686em;\&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.8991079999999999em;\&#34;&gt;&lt;span style=\&#34;top:-3.113em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34; style=\&#34;margin-right:0.03148em;\&#34;&gt;k&lt;/span&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:1.560448em;\&#34;&gt;&lt;span style=\&#34;top:-3.7743400000000005em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34; style=\&#34;margin-right:0.03148em;\&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;≈&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1.4270079999999998em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;e&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.938em;\&#34;&gt;&lt;span style=\&#34;top:-3.113em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34; style=\&#34;margin-right:0.03148em;\&#34;&gt;k&lt;/span&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34;&gt;n&lt;/span&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;/&lt;/span&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:1.1770079999999998em;\&#34;&gt;&lt;span style=\&#34;top:-3.3909000000000002em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mathdefault mtight\&#34; style=\&#34;margin-right:0.03148em;\&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;可以大致看出，随着位数组大小m和hash函数个数的增加，其实概率会下降，随着插入的元素n的增加，概率会有所上升。&lt;/p&gt;\n&lt;p&gt;最后也可以通过自己期待的误判率P和期待添加的个数n，来大致计算出布隆过滤器的位数组的长度：&lt;/p&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;m=-(\\frac{nInP}{(In2)^2})\n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.43056em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;m&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:2.29633em;vertical-align:-0.936em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mopen nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mfrac\&#34;&gt;&lt;span class=\&#34;vlist-t vlist-t2\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:1.36033em;\&#34;&gt;&lt;span style=\&#34;top:-2.314em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07847em;\&#34;&gt;I&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;n&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.740108em;\&#34;&gt;&lt;span style=\&#34;top:-2.9890000000000003em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.23em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;frac-line\&#34; style=\&#34;border-bottom-width:0.04em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=\&#34;top:-3.677em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:3em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;n&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07847em;\&#34;&gt;I&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34;&gt;n&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.13889em;\&#34;&gt;P&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-s\&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.936em;\&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose nulldelimiter\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;上面就是误判率的大致计算方式，同时也提示我们，可以根据自己业务的数据量以及误判率，来调整我们的数组的大小。&lt;/p&gt;\n&lt;h2 id=\&#34;布隆过滤器的作用\&#34;&gt;布隆过滤器的作用&lt;/h2&gt;\n&lt;p&gt;除了我们前面说的过滤爬虫恶意请求，还可以对一些URL进行去重，过滤海量数据里面的重复数据，过滤数据库里面不存在的id等等。&lt;/p&gt;\n&lt;p&gt;但是，即使有布隆过滤器，我们也不可能完全避免，或者彻底解决缓存穿透这个问题。只是相当于做了优化，将准确率提高。&lt;/p&gt;\n&lt;p&gt;很多的key-value数据库也会使用布隆过滤器来加快查询效率，因为全部挨个判断一遍，这个效率太低了。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;bu-long-guo-lu-qi-xiang-jie&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;前面我们提到，在防止缓存穿透的情况（缓存穿透是指，&lt;strong&gt;缓存和数据库都没有的数据&lt;/strong&gt;，被大量请求，比如订单号不可能为&lt;code&gt;-1&lt;/code&gt;，但是用户请求了大量订单号为&lt;code&gt;-1&lt;/code&gt;的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。）,我们可以考虑使用布隆过滤器，来过滤掉绝对不存于集合中的元素。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;布隆过滤器详解&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;布隆过滤器&#34;,&#34;slug&#34;:&#34;oNYr9Gm6H&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/oNYr9Gm6H/&#34;}],&#34;date&#34;:&#34;2023-03-02 23:07:39&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/bu-long-guo-lu-qi-xiang-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;7 min read&#34;,&#34;time&#34;:387000,&#34;words&#34;:1798,&#34;minutes&#34;:7},&#34;description&#34;:&#34;\n前面我们提到，在防止缓存穿透的情况（缓存穿透是指，缓存和数据库都没有的数据，被大量请求，比如订单号不可能为-1，但是用户请求了大量订单号为-1的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。）,我们可以考虑...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2\&#34;&gt;布隆过滤器是什么呢？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8\&#34;&gt;为什么需要布隆过滤器？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4\&#34;&gt;具体步骤&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AF%AF%E5%88%A4%E7%8E%87%E6%8E%A8%E5%AF%BC\&#34;&gt;误判率推导&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8\&#34;&gt;布隆过滤器的作用&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n前面讲解到，如果出现网络延迟的情况下，多个请求阻塞，那么恶意攻击就可以全部请求领取接口成功，而针对这种做法，我们使用`setnx`来解决，确保只有一个请求可以进入接口请求。\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226230957.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public String receiveGitf(int activityId,int giftId,String uid){\n        // isExist判断活动是否存在，内部包括redis和数据库请求，省略\n        if(isActivityExist(activityId,giftId)){\n            // 活动和礼品有效,判断是否领取过\n            if(!userReceived(uid,activityId,giftId)){\n                // 没有领取过，调用C系统\n                try {\n                    // setnx\n                    if(redis.setnx(&amp;quot;uid_activityId_giftId&amp;quot;)){\n                        boolean receivedResult = Http.getMethod(C_Client.class, &amp;quot;distributeGift&amp;quot;);\n                        if(receivedResult){\n                            // 领取成功更新mysql\n                            updateMysql(uid,activityId,giftId);\n                        }else{\n                            // 领取成功更新redis\n                            deleteRedis(uid,activityId,giftId);\n                            return &amp;quot;已经领过/领取失败&amp;quot;;\n                        }\n                    }else{\n                        return &amp;quot;已经领过/领取失败&amp;quot;;\n                    }\n                }catch (Exception e){\n                    // 记录日志\n                    logHelper.log(e);\n                    return &amp;quot;调用领券系统失败，请重试&amp;quot;;\n                }\n            }\n        }\n        return &amp;quot;领取失败，活动不存在&amp;quot;;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;下面，我们就专门讲解一下&lt;code&gt;setnx&lt;/code&gt;，&lt;code&gt;setnx&lt;/code&gt;可以用作分布式锁，但是&lt;strong&gt;这个场景并不是分布式锁的一个较好的实践，因为每个用户的key都是不一样的，我们主要是防止同一个用户恶意领取&lt;/strong&gt;，&lt;code&gt;setnx&lt;/code&gt;本身是一个原子操作，可以保证多个线程只有一个能拿到锁，能返回&lt;code&gt;true&lt;/code&gt;,其他的都会返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;但是上面的做法，没有设置过期时间，在生产上一般是不可以这么使用。&lt;strong&gt;不设置过期时间的key多了之后，redis服务器很容易内存打满，这时候不知道哪些是强制依赖的，只能扩容，从代码层面去清理，如果直接清理不常用的，也很难保证不出事。&lt;/strong&gt;（基本不允许这么干，除非是基础数据，跟着服务器启动，写入&lt;code&gt;redis&lt;/code&gt;的，不会变更的，比如城市数据，国家数据等等，当然，这些也可以考虑在本地内存中实现）&lt;/p&gt;\n&lt;p&gt;如果在上面的代码中，加入超时时间，假设是一个月或者半年，流程变成这样：&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210228165201.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;设置key的超时时间使用&lt;code&gt;expire&lt;/code&gt;,但是这样还有缺陷么？&lt;/p&gt;\n&lt;p&gt;在&lt;code&gt;redis 2.6.12&lt;/code&gt;之前，&lt;code&gt;setnx&lt;/code&gt;和&lt;code&gt;expire&lt;/code&gt;都不是原子操作，也就是很有可能在&lt;code&gt;setnx&lt;/code&gt;成功之后，redis当季，expire设置失败，也就不会有超时时间了。虽然这个影响在当前业务不是很大，但是还是一个小缺陷。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;Redis2.6.12&lt;/code&gt;以上版本，可以用&lt;code&gt;set&lt;/code&gt;获取锁,set包含&lt;code&gt;setnx&lt;/code&gt;和&lt;code&gt;expire&lt;/code&gt;，实现了原子操作。也就是两步要么一起成功，要么一起失败。&lt;/p&gt;\n&lt;p&gt;除此之外，上面的流程可能还存在的一个问题，是请求&lt;code&gt;C&lt;/code&gt;服务的时候出现超时，然后删除key，恰好这个时候&lt;code&gt;redis&lt;/code&gt;有问题，删除失败了，这个&lt;code&gt;key&lt;/code&gt;就永远存在了。表现在业务上，就是&lt;code&gt;A&lt;/code&gt;用户点击了领取，领取失败了，但是后面再怎么点，都是已经领取的状态了。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;那这种现象怎么优化呢？&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;这种情况，其实已经是很少见的情况，按照我们当前的业务场景也看，就是当前的用户，&lt;code&gt;redis&lt;/code&gt;记录了它已经领取过了，但是由于接口的失败，成功之后还没将&lt;code&gt;mysql/其他数据库&lt;/code&gt;更新,两个数据库不一致了。&lt;/p&gt;\n&lt;p&gt;我能想到的一个方法，就是再删除失败的时候，告警，并且将业务相关的数据记录下来，比如&lt;code&gt;key&lt;/code&gt;，&lt;code&gt;uid&lt;/code&gt;等等，针对这部分数据，做一次补发，或者手动删除key。&lt;/p&gt;\n&lt;p&gt;或者，启动一个定时任务或者&lt;code&gt;lua&lt;/code&gt;脚本，去判定&lt;code&gt;redis&lt;/code&gt;和数据库不一致的情况，但是切记不要全部查询，应该是隔一段时间，查询最后增加的部分，做一个校验以及相应的处理。枚举&lt;code&gt;key&lt;/code&gt;是十分耗时的操作！！！&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;setnx&lt;/code&gt; 除了解决上面的问题，还可以应用在解决&lt;strong&gt;缓存击穿&lt;/strong&gt;的问题上。&lt;/p&gt;\n&lt;p&gt;譬如现在有热点数据，不仅在&lt;code&gt;mysql&lt;/code&gt;数据库存储了，还在&lt;code&gt;redis&lt;/code&gt;中存了一份缓存，那么如果有一个时间点，缓存失效了，这时候，大量的请求打过来，同时到达，缓存拿不到数据，都去数据库取数据，假设数据库操作比较耗时，那么压力全都在数据库服务器上了。&lt;/p&gt;\n&lt;p&gt;这个时候所有的请求都去更新数据，明显是不合适的，应该是使用分布式锁，让一个线程去请求&lt;code&gt;mysql&lt;/code&gt;一次即可。但是为了避免死锁的情况，如果超时，得及时额外释放锁，要不可能请求&lt;code&gt;mysql&lt;/code&gt;都失败了，其他线程又拿不到锁，那么数据就会一直为&lt;code&gt;null&lt;/code&gt;了。&lt;/p&gt;\n&lt;p&gt;可以使用以下的命令：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;SETNX lock.foo &amp;lt;current Unix time + lock timeout + 1&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;关于这个场景下的&lt;code&gt;setnx&lt;/code&gt;先讲到这里，后面再讲讲分布式锁相关的知识。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;bing-fa-zhong-fen-bu-shi-suo-setnx-jie-xi&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n前面讲解到，如果出现网络延迟的情况下，多个请求阻塞，那么恶意攻击就可以全部请求领取接口成功，而针对这种做法，我们使用`setnx`来解决，确保只有一个请求可以进入接口请求。&#34;,&#34;title&#34;:&#34;并发中分布式锁setnx解析&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;分布式锁&#34;,&#34;slug&#34;:&#34;8NKw8sUzF&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/8NKw8sUzF/&#34;},{&#34;name&#34;:&#34;系统设计&#34;,&#34;slug&#34;:&#34;7Kez_RJxK&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/7Kez_RJxK/&#34;}],&#34;date&#34;:&#34;2023-03-02 23:06:27&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/bing-fa-zhong-fen-bu-shi-suo-setnx-jie-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;5 min read&#34;,&#34;time&#34;:275000,&#34;words&#34;:1268,&#34;minutes&#34;:5},&#34;description&#34;:&#34;\n前面讲解到，如果出现网络延迟的情况下，多个请求阻塞，那么恶意攻击就可以全部请求领取接口成功，而针对这种做法，我们使用`setnx`来解决，确保只有一个请求可以进入接口请求。\n\n\n    public String receiveGitf(...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;现在 有一个场景，领取礼品，每个用户有次数限制，用户通过前端点击，调用了应用A的接口，里面调用了服务B，服务B里面去调用了服务C，注意服务C是其他部门的服务。服务C负责真正的发放礼品。（假设这个服务C我们是不可修改的，A,B是自己团队负责的，并且可能出现高并发的情况）&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226212257.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;我们应该如何做这个次数限制呢？&lt;/p&gt;\n&lt;p&gt;假设每次领取礼品的活动有一个&lt;code&gt;activityId&lt;/code&gt;，一个用户一个活动可以领取一件礼品，礼品有&lt;code&gt;giftId&lt;/code&gt;，不可以多领，每个用户对应一个&lt;code&gt;uid&lt;/code&gt;。&lt;/p&gt;\n&lt;h2 id=\&#34;查询是否可以领取\&#34;&gt;查询是否可以领取&lt;/h2&gt;\n&lt;p&gt;首先对于前端而言，进入系统，首先需要获取用户是否已经领取过，而这个是否已经领取过，具体的实现我们应该写在B服务中，用户通过应用A，请求到服务B，返回用户是否已经领取的结果。&lt;/p&gt;\n&lt;p&gt;查询是否领取的流程大致如下：&lt;br&gt;\n用户进入页面，前端如果有缓存的话，可以为他展示之前缓存的结果，假设没有缓存，就会请求A应用，A应用会去请求B服务，B服务首先需要判断礼品或者活动是否存在。&lt;/p&gt;\n&lt;p&gt;去redis里面取活动或者礼品是否存在，如果redis没有查询到，那么就查询数据库，返回结果，如果数据库都没有，说明这个前端请求很可能是捏造的，直接返回结果“活动或者礼品不存在”，如果此时查询出来，确实存在，那么就需要去查询是否领取过，同样是查询redis，不存在的情况下，查询数据库，再返回结果。，如果领取过，则会有领取结果，前端将按键置灰，否者用户按键可以领取。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226214848.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;上面的redis肯定是需要我们维护的，这里不展开讲。比如增加活动的时候，除了改数据库，同时需要&lt;code&gt;redis&lt;/code&gt;里面写一份数据，key可以是&lt;code&gt;activityId_giftId&lt;/code&gt;，记录已经有的活动，用户成功领取的时候，同样是不仅增加数据库记录，也需要往&lt;code&gt;redis&lt;/code&gt;写一份数据，key可以是&lt;code&gt;activityId_giftId_uid&lt;/code&gt;，记录该用户已经领取过该活动的奖品。&lt;/p&gt;\n&lt;p&gt;但是上面的系统，有一个问题，就是活动/礼品不存在的时候，请求会每一次都直接打到数据库，如果是恶意攻击，数据库就挂了。这里当然可以考虑使用布隆过滤器，对请求参数中的活动/礼品做过滤，同时也可以考虑其他的防爬虫手段，比如滑动窗口统计请求数，根据&lt;code&gt;ip&lt;/code&gt;，客户端&lt;code&gt;id&lt;/code&gt;,&lt;code&gt;uid&lt;/code&gt;等等。&lt;/p&gt;\n&lt;p&gt;当然，如果可以保证&lt;code&gt;redis&lt;/code&gt;数据可靠，稳定，可以不请求数据库，&lt;code&gt;redis&lt;/code&gt;不包含则说明不存在，直接返回。但是这种做法需要在增加活动/修改商品的时候，同时将&lt;code&gt;redis&lt;/code&gt;一同修改同步。如果redis挂掉的情况，或者请求&lt;code&gt;redis&lt;/code&gt;异常，再去查询数据库。如果能接受修改数据库活动信息不立马更新，也可以考虑更新完数据库，用消息队列发一条消息，收到再做&lt;code&gt;redis&lt;/code&gt;更新。当然，这个不是一种好的做法，解耦合之后，增加了复杂度。前面说的做法，只要&lt;code&gt;redis&lt;/code&gt;挂了，数据库理论上也支撑不了多久（极端情况）。&lt;/p&gt;\n&lt;p&gt;（当然，上面不是完美的方案，是个大致流程）&lt;/p&gt;\n&lt;h2 id=\&#34;领取礼品接口怎么处理\&#34;&gt;领取礼品接口怎么处理？&lt;/h2&gt;\n&lt;p&gt;首先流程上与上面的查询是否领取过有些类似，，但是在查询是否领取过这一步之后，有所不同。如果已经领取过，则直接返回，但是如果没有领取过，需要调用C服务进行领取，如果调用C接口失败，或者返回领取失败，B服务需要做的事，就是记录日志或者告警，同时返回失败。&lt;br&gt;\n如果C服务返回领取成功，那么需要记录领取记录到数据库，并且更新缓存，表示已经领取过该礼品，这也是上面为什么一般能直接查询缓存就可以知道用户是否领取过的原因。&lt;br&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226230957.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;p&gt;这个设计中，其实C服务才是真正实现方法奖品的服务，我们做的A和B相当于调用别人的服务，做了中间服务，这种情况更需要记录日志，控制爬虫，恶意攻击等等，同时做好异常处理。&lt;/p&gt;\n&lt;p&gt;上面的设计，如果我们来写段伪代码，来看看有什么问题？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public String receiveGitf(int activityId,int giftId,String uid){\n        // isExist判断活动是否存在，内部包括redis和数据库请求，省略\n        if(isActivityExist(activityId,giftId)){\n            // 活动和礼品有效,判断是否领取过\n            if(!userReceived(uid,activityId,giftId)){\n                // 没有领取过，调用C系统\n                try {\n                    boolean receivedResult = Http.getMethod(C_Client.class, &amp;quot;distributeGift&amp;quot;);\n                    if(receivedResult){\n                        // 领取成功更新mysql\n                        updateMysql(uid,activityId,giftId);\n                        // 领取成功更新redis\n                        updateRedis(uid,activityId,giftId);\n                    }else{\n                        return &amp;quot;已经领过/领取失败&amp;quot;;\n                    }\n                }catch (Exception e){\n                    // 记录日志\n                    logHelper.log(e);\n                    return &amp;quot;调用领券系统失败，请重试&amp;quot;;\n                }\n            }\n        }\n        return &amp;quot;领取失败，活动不存在&amp;quot;;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;看起来好像没有什么问题，领取成功写&lt;code&gt;redis&lt;/code&gt;，之后读到就不会再领取。但是高并发环境下呢？高并发环境下，很有可能出现领取多次的情况，因为网络请求不是瞬时可以返回的，如果有很多个同一个uid的请求，同时进来，C服务的处理或者延迟比较高。所有的请求都会堵塞在请求C服务这里。（网络请求需要时间！！！）&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210226233336.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这时候还没有任何请求成功，所以&lt;code&gt;redis&lt;/code&gt;根本不会更新，数据库也不会，所以的请求都会打到C服务，假设别人的服务是不可靠的，可以多次领取，那么所有的请求都会成功，并且会有多条成功的记录！！！&lt;/p&gt;\n&lt;p&gt;那如何来改进这个问题呢？&lt;br&gt;\n我们可以使用&lt;code&gt;setnx&lt;/code&gt;来处理，先请求&lt;code&gt;setnx&lt;/code&gt;，更新缓存，然后只有一个可以成功进来，如果真的成功，再写数据库，如果异常或者请求失败，将缓存删除。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public String receiveGitf(int activityId,int giftId,String uid){\n        // isExist判断活动是否存在，内部包括redis和数据库请求，省略\n        if(isActivityExist(activityId,giftId)){\n            // 活动和礼品有效,判断是否领取过\n            if(!userReceived(uid,activityId,giftId)){\n                // 没有领取过，调用C系统\n                try {\n                    // setnx\n                    if(redis.setnx(&amp;quot;uid_activityId_giftId&amp;quot;)){\n                        boolean receivedResult = Http.getMethod(C_Client.class, &amp;quot;distributeGift&amp;quot;);\n                        if(receivedResult){\n                            // 领取成功更新mysql\n                            updateMysql(uid,activityId,giftId);\n                        }else{\n                            // 领取成功更新redis\n                            deleteRedis(uid,activityId,giftId);\n                            return &amp;quot;已经领过/领取失败&amp;quot;;\n                        }\n                    }else{\n                        return &amp;quot;已经领过/领取失败&amp;quot;;\n                    }\n                }catch (Exception e){\n                    // 记录日志\n                    logHelper.log(e);\n                    return &amp;quot;调用领券系统失败，请重试&amp;quot;;\n                }\n            }\n        }\n        return &amp;quot;领取失败，活动不存在&amp;quot;;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在 &lt;code&gt;Redis&lt;/code&gt; 里，所谓 &lt;code&gt;SETNX&lt;/code&gt;，是&lt;code&gt;「SET if Not eXists」&lt;/code&gt;缩写，也就是只有&lt;code&gt;key&lt;/code&gt;不存在的时候才设置，可以利用它来实现锁的效果。这样只有一个请求可以进入。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;redis&amp;gt; EXISTS id                # id 不存在\n\nredis&amp;gt; SETNX id &amp;quot;1&amp;quot;    # id 设置成功1\n\nredis&amp;gt; SETNX id &amp;quot;2&amp;quot;   # 尝试覆盖 id ，返回失败 0\n\nredis&amp;gt; GET job                   # 没有被覆盖&amp;quot;2&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这个场景下的问题已经得到初步的解决，那这个&lt;code&gt;setnx&lt;/code&gt;有没有坑呢？下次我们聊一下...&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;she-ji-ling-qu-li-pin-de-jia-gou-yi-ji-bing-fa-wen-ti-jie-jue&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;现在 有一个场景，领取礼品，每个用户有次数限制，用户通过前端点击，调用了应用A的接口，里面调用了服务B，服务B里面去调用了服务C，注意服务C是其他部门的服务。服务C负责真正的发放礼品。（假设这个服务C我们是不可修改的，A,B是自己团队负责的，并且可能出现高并发的情况）&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;设计领取礼品的架构以及并发问题解决&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;系统设计&#34;,&#34;slug&#34;:&#34;7Kez_RJxK&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/7Kez_RJxK/&#34;}],&#34;date&#34;:&#34;2023-03-02 23:05:18&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/she-ji-ling-qu-li-pin-de-jia-gou-yi-ji-bing-fa-wen-ti-jie-jue/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:425000,&#34;words&#34;:1938,&#34;minutes&#34;:8},&#34;description&#34;:&#34;\n现在 有一个场景，领取礼品，每个用户有次数限制，用户通过前端点击，调用了应用A的接口，里面调用了服务B，服务B里面去调用了服务C，注意服务C是其他部门的服务。服务C负责真正的发放礼品。（假设这个服务C我们是不可修改的，A,B是自己团队负责...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9F%A5%E8%AF%A2%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%A2%86%E5%8F%96\&#34;&gt;查询是否可以领取&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%A2%86%E5%8F%96%E7%A4%BC%E5%93%81%E6%8E%A5%E5%8F%A3%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86\&#34;&gt;领取礼品接口怎么处理？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;h2 id=\&#34;引言\&#34;&gt;引言&lt;/h2&gt;\n&lt;p&gt;相信大家在生活中，特别是最近的双十一活动期间，会收到很多短信，而那些短信都有两个特征，第一个是几乎都是垃圾短信，这个特点此处可以忽略不计，第二个特点是&lt;strong&gt;链接很短&lt;/strong&gt;，比如下面这个：&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211110222405.png\&#34; style=\&#34;zoom:40%;\&#34; /&gt;\n&lt;p&gt;我们知道，短信有些是有字数限制的，直接放一个带满各种参数的链接，不合适，另外一点是，不想暴露参数。好处无非以下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;太长的链接容易被限制长度&lt;/li&gt;\n&lt;li&gt;短链接看着简洁，长链接看着容易懵&lt;/li&gt;\n&lt;li&gt;安全，不想暴露参数&lt;/li&gt;\n&lt;li&gt;可以统一链接转换，当然也可以实现统计点击次数等操作&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;那背后的原理是什么呢？怎么实现的？让你实现这样的系统，你会怎么设计呢？【来自于某鹅场面试官】&lt;/p&gt;\n&lt;h2 id=\&#34;短链接的原理\&#34;&gt;短链接的原理&lt;/h2&gt;\n&lt;h3 id=\&#34;短链接展示的逻辑\&#34;&gt;短链接展示的逻辑&lt;/h3&gt;\n&lt;p&gt;这里最重要的知识点是重定向，先复习一下&lt;code&gt;http&lt;/code&gt;的状态码：&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;分类&lt;/th&gt;\n&lt;th style=\&#34;text-align:left\&#34;&gt;含义&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;1**&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;服务器收到请求，需要请求者继续执行操作&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;2**&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;成功，操作被成功接收并处理&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;3**&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;重定向，需要进一步的操作以完成请求&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;4**&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;客户端错误，请求包含语法错误或无法完成请求&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;5**&lt;/td&gt;\n&lt;td style=\&#34;text-align:left\&#34;&gt;服务器错误，服务器在处理请求的过程中发生了错误&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;那么以 3 开头的状态码都是关于重定向的：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;300：多种选择，可以在多个位置存在&lt;/li&gt;\n&lt;li&gt;301：永久重定向，浏览器会缓存，自动重定向到新的地址&lt;/li&gt;\n&lt;li&gt;302：临时重定向，客户端还是会继续使用旧的URL&lt;/li&gt;\n&lt;li&gt;303：查看其他的地址，类似于301&lt;/li&gt;\n&lt;li&gt;304：未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。&lt;/li&gt;\n&lt;li&gt;305：需要使用代理才能访问到资源&lt;/li&gt;\n&lt;li&gt;306：废弃的状态码&lt;/li&gt;\n&lt;li&gt;307：临时重定向，使用Get请求重定向&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;整个跳转的流程：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1.用户访问短链接，请求到达服务器&lt;/li&gt;\n&lt;li&gt;2.服务器将短链接装换成为长链接，然后给浏览器返回重定向的状态码301/302\n&lt;ul&gt;\n&lt;li&gt;301永久重定向会导致浏览器缓存重定向地址，短链接系统统计访问次数会不正确&lt;/li&gt;\n&lt;li&gt;302临时重定向可以解决次数不准的问题，但是每次都会到短链接系统转换，服务器压力会变大。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;3.浏览器拿到重定向的状态码，以及真正需要访问的地址，重定向到真正的长链接上。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;从下图可以看出，确实链接被&lt;code&gt;302&lt;/code&gt;重定向到新的地址上去，返回的头里面有一个字段&lt;code&gt;Location&lt;/code&gt;就是所要重定向的地址：&lt;/p&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211110235518.png\&#34; style=\&#34;zoom:70%;\&#34; /&gt;\n&lt;h3 id=\&#34;短链接怎么设计的\&#34;&gt;短链接怎么设计的？&lt;/h3&gt;\n&lt;h4 id=\&#34;全局发号器\&#34;&gt;全局发号器&lt;/h4&gt;\n&lt;p&gt;肯定我们第一点想到的是压缩，像文件压缩那样，压缩之后再解压还原到原来的链接，重定向到原来的链接，但是很不幸的是，这个是行不通的，你有见过什么压缩方式能把这么长的数字直接压缩到这么短么？事实上不可能。就像是&lt;code&gt;Huffman&lt;/code&gt;树，也只能对那种重复字符较多的字符串压缩时效率较高，像链接这种，可能带很多参数，而且各种不规则的情况都有，直接压缩算法不现实。&lt;/p&gt;\n&lt;p&gt;那&lt;code&gt;https://dx.10086.cn/tzHLFw&lt;/code&gt;与&lt;code&gt;https://gd.10086.cn/gmccapp/webpage/payPhonemoney/index.html?channel=&lt;/code&gt;之间的装换是怎么样的呢？前面路径不变，变化的是后面，也就是&lt;code&gt;tzHLFw&lt;/code&gt;与&lt;code&gt;gmccapp/webpage/payPhonemoney/index.html?channel=&lt;/code&gt;之间的转换。&lt;/p&gt;\n&lt;p&gt;实际也很简单，就是数据库里面的一条数据，一个&lt;code&gt;id&lt;/code&gt;对应长链接（相当于全局的发号器，全局唯一的ID）：&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;id&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;url&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;1&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;https://gd.10086.cn/gmccapp/webpage/payPhonemoney/index.html?channel=&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;这里用到的，也就是我们之前说过的分布式全局唯一ID，如果我们直接用&lt;code&gt;id&lt;/code&gt;作为参数，貌似也可以：&lt;code&gt;https://dx.10086.cn/1&lt;/code&gt;，访问这个链接时，去数据库查询获得真正的url，再重定向。&lt;/p&gt;\n&lt;p&gt;单机的唯一&lt;code&gt;ID&lt;/code&gt;很简单，用原子类&lt;code&gt;AtomicLong&lt;/code&gt;就可以，但是分布式的就不行了，简单点可以用 &lt;code&gt;redis&lt;/code&gt;，或者数据库自增，或者可以考虑&lt;code&gt;Zookeeper&lt;/code&gt;之类的。&lt;/p&gt;\n&lt;h4 id=\&#34;id-转换策略\&#34;&gt;id 转换策略&lt;/h4&gt;\n&lt;p&gt;但是直接用递增的数字，有两个坏处：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;数字很大的时候，还是很长&lt;/li&gt;\n&lt;li&gt;递增的数字，不安全，规律性太强了&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;明显我们平时看到的链接也不是数字的，一般都是大小写字母加上数字。为了缩短链接的长度，我们必须把&lt;code&gt;id&lt;/code&gt;转换掉，比如我们的短链接由&lt;code&gt;a-z&lt;/code&gt;,&lt;code&gt;A-Z&lt;/code&gt;,&lt;code&gt;0-9&lt;/code&gt;组成，相当于&lt;code&gt;62&lt;/code&gt;进制的数字，将&lt;code&gt;id&lt;/code&gt;转换成为&lt;code&gt;62&lt;/code&gt;进制的数字:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class ShortUrl {\n\n    private static final String BASE = &amp;quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&amp;quot;;\n\n    public static String toBase62(long num) {\n        StringBuilder result = new StringBuilder();\n        do {\n            int i = (int) (num % 62);\n            result.append(BASE.charAt(i));\n            num /= 62;\n        } while (num &amp;gt; 0);\n\n        return result.reverse().toString();\n    }\n\n    public static long toBase10(String str) {\n        long result = 0;\n        for (int i = 0; i &amp;lt; str.length(); i++) {\n            result = result * 62 + BASE.indexOf(str.charAt(i));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        // tzHLFw\n        System.out.println(toBase10(&amp;quot;tzHLFw&amp;quot;));\n        System.out.println(toBase62(27095455234L));\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;id&lt;/code&gt;转 &lt;code&gt;62&lt;/code&gt;位的&lt;code&gt;key&lt;/code&gt; 或者&lt;code&gt;key&lt;/code&gt;装换成为&lt;code&gt;id&lt;/code&gt;都已经实现了，不过计算还是比较耗时的，不如加个字段存起来，于是数据库变成了：&lt;/p&gt;\n&lt;table&gt;\n&lt;thead&gt;\n&lt;tr&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;id&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;key&lt;/th&gt;\n&lt;th style=\&#34;text-align:center\&#34;&gt;url&lt;/th&gt;\n&lt;/tr&gt;\n&lt;/thead&gt;\n&lt;tbody&gt;\n&lt;tr&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;27095455234&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;tzHLFw&lt;/td&gt;\n&lt;td style=\&#34;text-align:center\&#34;&gt;https://gd.10086.cn/gmccapp/webpage/payPhonemoney/index.html?channel=&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/tbody&gt;\n&lt;/table&gt;\n&lt;p&gt;但是这样还是很容易被猜出这个&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;key&lt;/code&gt;的对应关系，要是被遍历访问，那还是很不安全的，如果担心，可以随机将短链接的字符顺序打乱，或者在适当的位置加上一些随机生成的字符，比如第&lt;code&gt;1，4，5 &lt;/code&gt;位是随机字符，其他位置不变，只要我们计算的时候，将它对应的关系存到数据库，我们就可以通过连接的&lt;code&gt;key&lt;/code&gt;找到对应的&lt;code&gt;url&lt;/code&gt;。（值得注意的是，&lt;code&gt;key&lt;/code&gt;必须是全局唯一的，如果冲突，必须重新生成）&lt;/p&gt;\n&lt;p&gt;一般短链接都有过期时间，那么我们也必须在数据库里面加上对应的字段，访问的时候，先判断是否过期，过期则不给予重定向。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211115003828.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h4 id=\&#34;性能考虑\&#34;&gt;性能考虑&lt;/h4&gt;\n&lt;p&gt;如果有很多短链接暴露出去了，数据库里面数据很多，这个时候可以考虑使用缓存优化，生成的时候顺便把缓存写入，然后读取的时候，走缓存即可，因为一般短链接和长链接的关系不会修改，即使修改，也是很低频的事情。&lt;/p&gt;\n&lt;p&gt;如果系统的&lt;code&gt;id&lt;/code&gt;用完了怎么办？这种概率很小，如果真的发生，可以重用旧的已经失效的&lt;code&gt;id&lt;/code&gt;号。&lt;/p&gt;\n&lt;p&gt;如果被人疯狂请求一些不存在的短链接怎么办？其实这就是缓存穿透，缓存穿透是指，&lt;strong&gt;缓存和数据库都没有的数据&lt;/strong&gt;，被大量请求，比如订单号不可能为&lt;code&gt;-1&lt;/code&gt;，但是用户请求了大量订单号为&lt;code&gt;-1&lt;/code&gt;的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。如果被恶意用户利用，疯狂请求不存在的数据，就会导致数据库压力过大，甚至垮掉。&lt;/p&gt;\n&lt;p&gt;针对这种情况，一般可以用布隆过滤器过滤掉不存在的数据请求，但是我们这里&lt;code&gt;id&lt;/code&gt;本来就是递增且有序的，其实我们范围大致都是已知的，更加容易判断，超出的肯定不存在，或者请求到的时候，缓存里面放一个空对象也是没有问题的。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;she-ji-yi-ge-duan-lian-jie-sheng-cheng-xi-tong&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;h2 id=\&#34;引言\&#34;&gt;引言&lt;/h2&gt;\n&lt;p&gt;相信大家在生活中，特别是最近的双十一活动期间，会收到很多短信，而那些短信都有两个特征，第一个是几乎都是垃圾短信，这个特点此处可以忽略不计，第二个特点是&lt;strong&gt;链接很短&lt;/strong&gt;，比如下面这个：&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;设计一个短链接生成系统&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;系统设计&#34;,&#34;slug&#34;:&#34;7Kez_RJxK&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/7Kez_RJxK/&#34;}],&#34;date&#34;:&#34;2023-03-02 23:01:07&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/she-ji-yi-ge-duan-lian-jie-sheng-cheng-xi-tong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:429000,&#34;words&#34;:1972,&#34;minutes&#34;:8},&#34;description&#34;:&#34;\n引言\n相信大家在生活中，特别是最近的双十一活动期间，会收到很多短信，而那些短信都有两个特征，第一个是几乎都是垃圾短信，这个特点此处可以忽略不计，第二个特点是链接很短，比如下面这个：\n\n\n我们知道，短信有些是有字数限制的，直接放一个带满各种...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BC%95%E8%A8%80\&#34;&gt;引言&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9F%AD%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8E%9F%E7%90%86\&#34;&gt;短链接的原理&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9F%AD%E9%93%BE%E6%8E%A5%E5%B1%95%E7%A4%BA%E7%9A%84%E9%80%BB%E8%BE%91\&#34;&gt;短链接展示的逻辑&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84\&#34;&gt;短链接怎么设计的？&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%A8%E5%B1%80%E5%8F%91%E5%8F%B7%E5%99%A8\&#34;&gt;全局发号器&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#id-%E8%BD%AC%E6%8D%A2%E7%AD%96%E7%95%A5\&#34;&gt;id 转换策略&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91\&#34;&gt;性能考虑&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;blockquote&gt;\n&lt;p&gt;程序 = 数据结构 + 算法&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;是的，上面这句话是非常经典的，程序由数据结构以及算法组成，当然数据结构和算法也是相辅相成的，不能完全独立来看待，但是本文会相对重点聊聊那些常用的数据结构。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;strong&gt;数据结构是什么呢？&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;首先得知道数据是什么？&lt;strong&gt;数据是对客观事务的符号表示&lt;/strong&gt;，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号总称。那为何加上**“结构”**两字？&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;数据元素是数据的基本单位&lt;/strong&gt;，而任何问题中，数据元素都不是独立存在的，它们之间总是存在着某种关系，这种&lt;strong&gt;数据元素之间的关系我们称之为结构&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;因此，我们有了以下定义：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;数据结构是&lt;a href=\&#34;https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338\&#34;&gt;计算机&lt;/a&gt;存储、组织&lt;a href=\&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE\&#34;&gt;数据&lt;/a&gt;的方式。数据结构是指相互之间存在一种或多种特定关系的&lt;a href=\&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0/715313\&#34;&gt;数据元素&lt;/a&gt;的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储&lt;a href=\&#34;https://baike.baidu.com/item/%E6%95%88%E7%8E%87/868847\&#34;&gt;效率&lt;/a&gt;。数据结构往往同高效的检索&lt;a href=\&#34;https://baike.baidu.com/item/%E7%AE%97%E6%B3%95/209025\&#34;&gt;算法&lt;/a&gt;和&lt;a href=\&#34;https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95/5716853\&#34;&gt;索引&lt;/a&gt;技术有关。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;简单讲，数据结构就是组织，管理以及存储数据的方式。虽然理论上所有的数据都可以混杂，或者糅合，或者饥不择食，随便存储，但是计算机是追求高效的，如果我们能了解数据结构，找到较为适合当前问题场景的数据结构，将数据之间的关系表现在存储上，计算的时候可以较为高效的利用适配的算法，那么程序的运行效率肯定也会有所提高。&lt;/p&gt;\n&lt;p&gt;常用的4种数据结构有：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;集合：只有同属于一个集合的关系，没有其他关系&lt;/li&gt;\n&lt;li&gt;线性结构：结构中的数据元素之间存在一个对一个的关系&lt;/li&gt;\n&lt;li&gt;树形结构：结构中的数据元素之间存在一个对多个的关系&lt;/li&gt;\n&lt;li&gt;图状结构或者网状结构：图状结构或者网状结构&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104211919.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;&lt;strong&gt;何为逻辑结构和存储结构？&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;数据元素之间的逻辑关系，称之为逻辑结构&lt;/strong&gt;，也就是我们定义了对操作对象的一种数学描述。但是我们还必须知道在计算机中如何表示它。&lt;strong&gt;数据结构在计算机中的表示（又称为映像），称之为数据的物理结构，又称存储结构&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;数据元素之前的关系在计算机中有两种不同的表示方法：&lt;strong&gt;顺序映像和非顺序映像&lt;/strong&gt;，并且由此得到两种不同的存储结构：&lt;strong&gt;顺序存储结构&lt;/strong&gt;和&lt;strong&gt;链式存储结构&lt;/strong&gt;，比如顺序存储结构，我们要表示复数&lt;code&gt;z1 =3.0 - 2.3i &lt;/code&gt;,可以直接借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104213735.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;而链式结构，则是以&lt;strong&gt;指针&lt;/strong&gt;表示数据元素之间的逻辑关系，同样是&lt;code&gt;z1 =3.0 - 2.3i &lt;/code&gt;，先找到下一个是 &lt;code&gt;100&lt;/code&gt;，是一个地址，根据地址找到真实的数据&lt;code&gt;-2.3i&lt;/code&gt;:&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104214041.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;位bit\&#34;&gt;位（bit）&lt;/h2&gt;\n&lt;p&gt;在计算机中表示信息的最小的单位是二进制数中的一位，叫做&lt;strong&gt;位&lt;/strong&gt;。也就是我们常见的类似&lt;code&gt;01010101010&lt;/code&gt;这种数据，计算机的底层就是各种晶体管，电路板，所以不管是什么数据，即使是图片，声音，在最底层也是&lt;code&gt;0&lt;/code&gt;和&lt;code&gt;1&lt;/code&gt;,如果有八条电路，那么每条电路有自己的闭合状态，有&lt;code&gt;8&lt;/code&gt;个&lt;code&gt;2&lt;/code&gt;相乘，2&lt;sup&gt;8&lt;/sup&gt;，也就是&lt;code&gt;256&lt;/code&gt;种不同的信号。&lt;/p&gt;\n&lt;p&gt;但是一般我们需要表示负数，也就是最高的一位表示符号位，&lt;code&gt;0&lt;/code&gt;表示正数，&lt;code&gt;1&lt;/code&gt;表示负数，也就是8位的最大值是&lt;code&gt;01111111&lt;/code&gt;，也就是&lt;code&gt;127&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;值得我们注意的是，计算机的世界里，多了原码，反码，补码的概念：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;原码：用第一位表示符号，其余位表示值&lt;/li&gt;\n&lt;li&gt;反码：正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反。&lt;/li&gt;\n&lt;li&gt;补码：正数的补码是其本身，负数的补码是在其反码的基础上 + 1&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;为什么有了原码还要反码和补码\&#34;&gt;为什么有了原码还要反码和补码？&lt;/h3&gt;\n&lt;p&gt;我们知道加减法是高频的运算，人可以很直观的看出加号减号，马上就可以算出来，但是计算机如果区分不同的符号，那么加减就会比较复杂，比如正数+正数，正数-正数，正数-负数，负数+负数...等等。于是，有人就想用同一个运算器（加号运算器），解决所有的加减法计算，可以减少很多复杂的电路，以及各种符号转换的开销，计算也更加高效。&lt;/p&gt;\n&lt;p&gt;我们可以看到，下面负数参加运算的结果也是符合补码的规则的：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;        00100011\t\t35\n +      11011101\t   -35\n-------------------------\n        00000000       0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;        00100011\t\t35\n + \t    11011011\t   -37\n-------------------------\n        11111110       -2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当然，如果计算结果超出了位数所能表示的范围，那就是溢出，就说明需要更多的位数才能正确表示。&lt;/p&gt;\n&lt;p&gt;一般能用位运算的，都尽量使用位运算，因为它比较高效, 常见的位运算：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;~&lt;/code&gt;：按位取反&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;：按为与运算&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;|&lt;/code&gt;：按位或运算&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;^&lt;/code&gt;：按位异或&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;: 带符号左移，比如&lt;code&gt;35(00100011)&lt;/code&gt;,左移一位为 &lt;code&gt;70(01000110)&lt;/code&gt;,&lt;code&gt;-35(11011101)&lt;/code&gt;左移一位为&lt;code&gt;-70(10111010)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;：带符号右移，比如&lt;code&gt;35(00100011)&lt;/code&gt;,右移一位为 &lt;code&gt;17(00010001)&lt;/code&gt;,&lt;code&gt;-35(11011101)&lt;/code&gt;左移一位为&lt;code&gt;-18(11101110)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;:无符号左移，比如&lt;code&gt;35(00100011)&lt;/code&gt;,左移一位为&lt;code&gt;70(01000110)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;:无符号右移，比如&lt;code&gt;-35(11011101)&lt;/code&gt;,右移一位为&lt;code&gt;110(01101110)&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;x ^= y; y ^= x; x ^= y;&lt;/code&gt;:交换&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;s &amp;amp;= ~(1 &amp;lt;&amp;lt; k)&lt;/code&gt;:第&lt;code&gt;k&lt;/code&gt;位置0&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;要说哪里使用位运算比较经典，那么要数&lt;strong&gt;布隆过滤器&lt;/strong&gt;，需要了解详情的可以参考：http://aphysia.cn/archives/cachebloomfilter&lt;/p&gt;\n&lt;h3 id=\&#34;布隆过滤器是什么呢\&#34;&gt;布隆过滤器是什么呢？&lt;/h3&gt;\n&lt;p&gt;布隆过滤器（&lt;code&gt;Bloom Filter&lt;/code&gt;）是由布隆（&lt;code&gt;Burton Howard Bloom&lt;/code&gt;）在1970年提出的，它实际上是由一个很长的二进制向量和一系列随机hash映射函数组成（说白了，就是用二进制数组存储数据的特征）。可以使用它来判断一个元素是否存在于集合中，它的优点在于查询效率高，空间小，缺点是存在一定的误差，以及我们想要剔除元素的时候，可能会相互影响。&lt;/p&gt;\n&lt;p&gt;也就是当一个元素被加入集合的时候，通过多个&lt;code&gt;hash&lt;/code&gt;函数，将元素映射到位数组中的&lt;code&gt;k&lt;/code&gt;个点，置为&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;重点是多个hash函数，可以将数据hash到不同的位上，也只有这些位全部为1的时候，我们才能判断该数据已经存在&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;假设有三个&lt;code&gt;hash&lt;/code&gt;函数，那么不同的元素，都会使用三个&lt;code&gt;hash&lt;/code&gt;函数，&lt;code&gt;hash&lt;/code&gt;到三个位置上。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233116.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;假设后面又来了一个张三，那么在&lt;code&gt;hash&lt;/code&gt;的时候，同样会&lt;code&gt;hash&lt;/code&gt;到以下位置，所有位都是&lt;code&gt;1&lt;/code&gt;，我们就可以说张三已经存在在里面了。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233607.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;那么有没有可能出现误判的情况呢？这是有可能的，比如现在只有张三，李四，王五，蔡八，&lt;code&gt;hash&lt;/code&gt;映射值如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233752.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;后面来了陈六，但是不凑巧的是，它&lt;code&gt;hash&lt;/code&gt;的三个函数hash出来的位，刚刚好就是被别的元素&lt;code&gt;hash&lt;/code&gt;之后，改成&lt;code&gt;1&lt;/code&gt;了，判断它已经存在了，但是实际上，陈六之前是不存在的。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20210308233900.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;上面的情况，就是误判，布隆过滤器都会不可避免的出现误判。但是它有一个好处是，&lt;strong&gt;布隆过滤器，判断存在的元素，可能不存在，但是判断不存在的元素，一定不存在。&lt;/strong&gt;，因为判断不存在说明至少有一位&lt;code&gt;hash&lt;/code&gt;出来是对不上的。&lt;/p&gt;\n&lt;p&gt;也是由于会出现多个元素可能&lt;code&gt;hash&lt;/code&gt;到一起，但有一个数据被踢出了集合，我们想把它映射的位，置为&lt;code&gt;0&lt;/code&gt;，相当于删除该数据。这个时候，就会影响到其他的元素，可能会把别的元素映射的位，置为了&lt;code&gt;0&lt;/code&gt;。这也就是为什么布隆过滤器不能删除的原因。&lt;/p&gt;\n&lt;h2 id=\&#34;数组\&#34;&gt;数组&lt;/h2&gt;\n&lt;p&gt;线性表示最常用而且最为简单的一种数据结构，一个线性表示 n 个数据元素的有限序列，有以下特点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;存在唯一的第一个的数据元素&lt;/li&gt;\n&lt;li&gt;存在唯一被称为最后一个的数据元素&lt;/li&gt;\n&lt;li&gt;除了第一个以外，集合中每一个元素均有一个前驱&lt;/li&gt;\n&lt;li&gt;除了最后一个元素之外，集合中的每一个数据元素都有一个后继元素&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;线性表包括下面几种：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;数组：查询 / 更新快，查找/删除慢&lt;/li&gt;\n&lt;li&gt;链表&lt;/li&gt;\n&lt;li&gt;队列&lt;/li&gt;\n&lt;li&gt;栈&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;数组是线性表的一种，线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素&lt;/strong&gt;：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104223923.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;在&lt;code&gt;Java&lt;/code&gt;中表示为：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;int[] nums = new int[100];\nint[] nums = {1,2,3,4,5};\n\nObject[] Objects = new Object[100];\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;在&lt;code&gt;C++&lt;/code&gt; 中表示为：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;int nums[100];\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;数组是一种线性的结构，一般在底层是连续的空间，存储相同类型的数据，由于连续紧凑结构以及天然索引支持，查询数据效率高:&lt;/p&gt;\n&lt;p&gt;假设我们知道数组&lt;code&gt;a&lt;/code&gt;的第 1 个值是 地址是  &lt;code&gt;296&lt;/code&gt;,里面的数据类型占 &lt;code&gt;2&lt;/code&gt; 个 单位，那么我们如果期望得到第 5 个： &lt;code&gt;296+（5-1）*2 = 304&lt;/code&gt;,&lt;code&gt;O(1)&lt;/code&gt;的时间复杂度就可以获取到。&lt;/p&gt;\n&lt;p&gt;更新的本质也是查找，先查找到该元素，就可以动手更新了：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104224829.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;但是如果期望插入数据的话，需要移动后面的数据，比如下面的数组，插入元素&lt;code&gt;6&lt;/code&gt;，最差的是移动所有的元素，时间复杂度为&lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220104225524289.png\&#34; alt=\&#34;image-20220104225524289\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;而删除元素则需要把后面的数据移动到前面，最差的时间复杂度同样为&lt;code&gt;O(n)&lt;/code&gt;:&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;12\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220104230125.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;Java代码实现数组的增删改查：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;package datastruction;\n\nimport java.util.Arrays;\n\npublic class MyArray {\n    private int[] data;\n\n    private int elementCount;\n\n    private int length;\n\n    public MyArray(int max) {\n        length = max;\n        data = new int[max];\n        elementCount = 0;\n    }\n\n    public void add(int value) {\n        if (elementCount == length) {\n            length = 2 * length;\n            data = Arrays.copyOf(data, length);\n        }\n        data[elementCount] = value;\n        elementCount++;\n    }\n\n    public int find(int searchKey) {\n        int i;\n        for (i = 0; i &amp;lt; elementCount; i++) {\n            if (data[i] == searchKey)\n                break;\n        }\n        if (i == elementCount) {\n            return -1;\n        }\n        return i;\n    }\n\n    public boolean delete(int value) {\n        int i = find(value);\n        if (i == -1) {\n            return false;\n        }\n        for (int j = i; j &amp;lt; elementCount - 1; j++) {\n            data[j] = data[j + 1];\n        }\n        elementCount--;\n        return true;\n    }\n\n    public boolean update(int oldValue, int newValue) {\n        int i = find(oldValue);\n        if (i == -1) {\n            return false;\n        }\n        data[i] = newValue;\n        return true;\n    }\n}\n\n// 测试类\npublic class Test {\n    public static void main(String[] args) {\n        MyArray myArray = new MyArray(2);\n        myArray.add(1);\n        myArray.add(2);\n        myArray.add(3);\n        myArray.delete(2);\n        System.out.println(myArray);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;链表\&#34;&gt;链表&lt;/h2&gt;\n&lt;p&gt;上面的例子中，我们可以看到数组是需要连续的空间，这里面如果空间大小只有 &lt;code&gt;2&lt;/code&gt;，放到第 &lt;code&gt;3&lt;/code&gt; 个元素的时候，就不得不扩容，不仅如此，还得拷贝元素。一些删除，插入操作会引起较多的数据移动的操作。&lt;/p&gt;\n&lt;p&gt;链表，也就是链式数据结构，由于它不要求逻辑上相邻的数据元素在物理位置上也相邻，所以它没有顺序存储结构所具有的缺点，但是同时也失去了通过索引下标直接查找元素的优点。&lt;/p&gt;\n&lt;p&gt;重点：&lt;strong&gt;链表在计算机的存储中不是连续的，而是前一个节点存储了后一个节点的指针（地址），通过地址找到后一个节点。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;下面是单链表的结构：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;13\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220105084859.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;一般我们会手动在单链表的前面设置一个前置结点，也可以称为头结点，但是这并非绝对：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;14\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220105085243.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;一般链表结构分为以下几种：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;单向链表&lt;/strong&gt;：链表中的每一个结点，都有且只有一个指针指向下一个结点，并且最后一个节点指向空。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;双向链表&lt;/strong&gt;：每个节点都有两个指针（为方便，我们称之为&lt;strong&gt;前指针&lt;/strong&gt;，&lt;strong&gt;后指针&lt;/strong&gt;），分别指向上一个节点和下一个节点，第一个节点的前指针指向&lt;code&gt;NULL&lt;/code&gt;，最后一个节点的后指针指向&lt;code&gt;NULL&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;循环链表&lt;/strong&gt;：每一个节点的指针指向下一个节点，并且最后一个节点的指针指向第一个节点（虽然是循环链表，但是必要的时候还需要标识头结点或者尾节点，避免死循环）&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;复杂链表&lt;/strong&gt;：每一个链表有一个后指针，指向下一个节点，同时有一个随机指针，指向任意一个结点。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;15\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220105235909.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;链表操作的时间复杂度：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;查询：&lt;code&gt;O(n)&lt;/code&gt;,需要遍历链表&lt;/li&gt;\n&lt;li&gt;插入：&lt;code&gt;O(1)&lt;/code&gt;，修改前后指针即可&lt;/li&gt;\n&lt;li&gt;删除：&lt;code&gt;O(1)&lt;/code&gt;，同样是修改前后指针即可&lt;/li&gt;\n&lt;li&gt;修改：不需要查询则为&lt;code&gt;O(1)&lt;/code&gt;，需要查询则为&lt;code&gt;O(n)&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;链表的结构代码怎么表示呢？&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;下面只表示单链表结构，&lt;code&gt;C++&lt;/code&gt;表示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-C++\&#34;&gt;// 结点\ntypedef struct LNode{\n  // 数据\n  ElemType data;\n  // 下一个节点的指针\n  struct LNode *next;\n}*Link,*Position;\n\n// 链表\ntypedef struct{\n  // 头结点，尾节点\n  Link head,tail;\n  // 长度\n  int len;\n}LinkList;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 代码表示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;    public class ListNode {\n        int val;\n        ListNode next = null;\n\n        ListNode(int val) {\n            this.val = val;\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;自己实现简单链表，实现增删改查功能：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;class ListNode&amp;lt;T&amp;gt; {\n    T val;\n    ListNode next = null;\n\n    ListNode(T val) {\n        this.val = val;\n    }\n}\n\npublic class MyList&amp;lt;T&amp;gt; {\n    private ListNode&amp;lt;T&amp;gt; head;\n    private ListNode&amp;lt;T&amp;gt; tail;\n    private int size;\n\n    public MyList() {\n        this.head = null;\n        this.tail = null;\n        this.size = 0;\n    }\n\n    public void add(T element) {\n        add(size, element);\n    }\n\n    public void add(int index, T element) {\n        if (index &amp;lt; 0 || index &amp;gt; size) {\n            throw new IndexOutOfBoundsException(&amp;quot;超出链表长度范围&amp;quot;);\n        }\n        ListNode current = new ListNode(element);\n        if (index == 0) {\n            if (head == null) {\n                head = current;\n                tail = current;\n            } else {\n                current.next = head;\n                head = current;\n            }\n        } else if (index == size) {\n            tail.next = current;\n            tail = current;\n        } else {\n            ListNode preNode = get(index - 1);\n            current.next = preNode.next;\n            preNode.next = current;\n        }\n        size++;\n    }\n\n    public ListNode get(int index) {\n        if (index &amp;lt; 0 || index &amp;gt;= size) {\n            throw new IndexOutOfBoundsException(&amp;quot;超出链表长度&amp;quot;);\n        }\n        ListNode temp = head;\n        for (int i = 0; i &amp;lt; index; i++) {\n            temp = temp.next;\n        }\n        return temp;\n    }\n\n    public ListNode delete(int index) {\n        if (index &amp;lt; 0 || index &amp;gt;= size) {\n            throw new IndexOutOfBoundsException(&amp;quot;超出链表节点范围&amp;quot;);\n        }\n        ListNode node = null;\n        if (index == 0) {\n            node = head;\n            head = head.next;\n        } else if (index == size - 1) {\n            ListNode preNode = get(index - 1);\n            node = tail;\n            preNode.next = null;\n            tail = preNode;\n        } else {\n            ListNode pre = get(index - 1);\n            pre.next = pre.next.next;\n            node = pre.next;\n        }\n        size--;\n        return node;\n    }\n\n    public void update(int index, T element) {\n        if (index &amp;lt; 0 || index &amp;gt;= size) {\n            throw new IndexOutOfBoundsException(&amp;quot;超出链表节点范围&amp;quot;);\n        }\n        ListNode node = get(index);\n        node.val = element;\n    }\n\n    public void display() {\n        ListNode temp = head;\n        while (temp != null) {\n            System.out.print(temp.val + &amp;quot; -&amp;gt; &amp;quot;);\n            temp = temp.next;\n        }\n        System.out.println(&amp;quot;&amp;quot;);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Test {\n    public static void main(String[] args) {\n        MyList myList = new MyList();\n        myList.add(1);\n        myList.add(2);\n        // 1-&amp;gt;2\n        myList.display();\n\n        // 1\n        System.out.println(myList.get(0).val);\n\n        myList.update(1,3);\n        // 1-&amp;gt;3\n        myList.display();\n\n        myList.add(4);\n        // 1-&amp;gt;3-&amp;gt;4\n        myList.display();\n\n        myList.delete(1);\n        // 1-&amp;gt;4\n        myList.display();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;1 -&amp;gt; 2 -&amp;gt; \n1\n1 -&amp;gt; 3 -&amp;gt; \n1 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; \n1 -&amp;gt; 4 -&amp;gt;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;单向链表的查找更新比较简单，我们看看插入新节点的具体过程（这里只展示中间位置的插入，头尾插入比较简单）：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;16\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108113826.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;17\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108113852.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;那如何删除一个中间的节点呢？下面是具体的过程：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;18\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220108114627633.png\&#34; alt=\&#34;image-20220108114627633\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;或许你会好奇，&lt;code&gt;a5&lt;/code&gt;节点只是指针没有了，那它去哪里了？&lt;/p&gt;\n&lt;p&gt;如果是&lt;code&gt;Java&lt;/code&gt;程序，垃圾回收器会收集这种没有被引用的节点，帮我们回收掉了这部分内存，但是为了加快垃圾回收的速度，一般不需要的节点我们需要置空，比如 &lt;code&gt;node = null&lt;/code&gt;, 如果在&lt;code&gt;C++&lt;/code&gt; 程序中，那么就需要手动回收了，否则容易造成内存泄漏等问题。&lt;/p&gt;\n&lt;p&gt;复杂链表的操作暂时讲到这里，后面我会单独把链表这一块的数据结构以及常用算法单独分享一下，本文章主要讲数据结构全貌。&lt;/p&gt;\n&lt;h3 id=\&#34;跳表\&#34;&gt;跳表&lt;/h3&gt;\n&lt;p&gt;上面我们可以观察到，链表如果搜索，是很麻烦的，如果这个节点在最后，需要遍历所有的节点，才能找到，查找效率实在太低，有没有什么好的办法呢？&lt;/p&gt;\n&lt;p&gt;办法总比问题多，但是想要绝对的”&lt;code&gt;多快好省&lt;/code&gt;“是不存在的，有舍有得，计算机的世界里，充满哲学的味道。既然搜索效率有问题，那么我们不如给链表排个序。排序后的链表，还是只能知道头尾节点，知道中间的范围，但是要找到中间的节点，还是得走遍历的老路。如果我们把中间节点存储起来呢？存起来，确实我们就知道数据在前一半，还是在后一半。比如找&lt;code&gt;7&lt;/code&gt;，肯定就从中间节点开始找。如果查找&lt;code&gt;4&lt;/code&gt;,就得从头开始找，最差到中间节点，就停止查找。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;19\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108120726.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;但是如此，还是没有彻底解决问题，因为链表很长的情况，只能通过前后两部分查找。不如回到原则：&lt;code&gt;空间和时间，我们选择时间，那就要舍弃一部分空间&lt;/code&gt;,我们每个节点再加一个指针，现在有 2 层指针（注意：&lt;strong&gt;节点只有一份，都是同一个节点，只是为了好看，弄了两份，实际上是同一个节点，有两个指针，比如 1 ，既指向2，也指向5&lt;/strong&gt;）：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;20\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108121514.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;两层指针，问题依然存在，那就不断加层，比如每两个节点，就加一层：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;21\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108122738.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这就是跳表了，跳表的定义如下：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;主要的原理是用空间换时间，可以实现近乎二分查找的效率，实际上消耗的空间，假设每两个加一层， &lt;code&gt;1 + 2 + 4 + ... + n = 2n-1&lt;/code&gt;,多出了差不多一倍的空间。你看它像不像书的目录，一级目录，二级，三级 ...&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;22\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108123726.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;如果我们不断往跳表中插入数据，可能出现某一段节点会特别多的情况，这个时候就需要动态更新索引，除了插入数据，还要插入到上一层的链表中，保证查询效率。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;redis&lt;/code&gt; 中使用了跳表来实现&lt;code&gt;zset&lt;/code&gt;,&lt;code&gt;redis&lt;/code&gt;中使用一个随机算法来计算层级，计算出每个节点到底多少层索引，虽然不能绝对保证比较平衡，但是基本保证了效率，实现起来比那些平衡树，红黑树的算法简单一点。&lt;/p&gt;\n&lt;h2 id=\&#34;栈\&#34;&gt;栈&lt;/h2&gt;\n&lt;p&gt;栈是一种数据结构，在&lt;code&gt;Java&lt;/code&gt;里面体现是&lt;code&gt;Stack&lt;/code&gt;类。它的本质是&lt;strong&gt;先进后出&lt;/strong&gt;，就像是一个桶，只能不断的放在上面，取出来的时候，也只能不断的取出最上面的数据。要想取出底层的数据，只有等到上面的数据都取出来，才能做到。当然，如果有这种需求，我们一般会使用双向队列。&lt;/p&gt;\n&lt;p&gt;以下是栈的特性演示：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;23\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211228083751.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;栈的底层用什么实现的？其实可以用链表，也可以用数组，但是&lt;code&gt;JDK&lt;/code&gt;底层的栈，是用数组实现的，封装之后，通过&lt;code&gt;API&lt;/code&gt;操作的永远都只能是最后一个元素，栈经常用来实现递归的功能。如果想要了解&lt;code&gt;Java&lt;/code&gt;里面的栈或者其他集合实现分析，可以看看这系列文章：http://aphysia.cn/categories/collection&lt;/p&gt;\n&lt;p&gt;元素加入称之为入栈（压栈），取出元素，称之为出栈，栈顶元素则是最后一次放进去的元素。&lt;/p&gt;\n&lt;p&gt;使用数组实现简单的栈(注意仅供参考测试，实际会有线程安全等问题)：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;import java.util.Arrays;\n\npublic class MyStack&amp;lt;T&amp;gt; {\n    private T[] data;\n    private int length = 2;\n    private int maxIndex;\n\n    public MyStack() {\n        data = (T[]) new Object[length];\n        maxIndex = -1;\n    }\n\n    public void push(T element) {\n        if (isFull()) {\n            length = 2 * length;\n            data = Arrays.copyOf(data, length);\n        }\n        data[maxIndex + 1] = element;\n        maxIndex++;\n    }\n\n    public T pop() {\n        if (isEmpty()) {\n            throw new IndexOutOfBoundsException(&amp;quot;栈内没有数据&amp;quot;);\n        } else {\n            T[] newdata = (T[]) new Object[data.length - 1];\n            for (int i = 0; i &amp;lt; data.length - 1; i++) {\n                newdata[i] = data[i];\n            }\n            T element = data[maxIndex];\n            maxIndex--;\n            data = newdata;\n            return element;\n        }\n    }\n\n    private boolean isFull() {\n        return data.length - 1 == maxIndex;\n    }\n\n    public boolean isEmpty() {\n        return maxIndex == -1;\n    }\n\n    public void display() {\n        for (int i = 0; i &amp;lt; data.length; i++) {\n            System.out.print(data[i]+&amp;quot; &amp;quot;);\n        }\n        System.out.println(&amp;quot;&amp;quot;);\n    }\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;public class MyStackTest {\n    public static void main(String[] args) {\n        MyStack&amp;lt;Integer&amp;gt; myStack = new MyStack&amp;lt;&amp;gt;();\n        myStack.push(1);\n        myStack.push(2);\n        myStack.push(3);\n        myStack.push(4);\n        myStack.display();\n\n        System.out.println(myStack.pop());\n\n        myStack.display();\n\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出结果如下，符合预期：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-text\&#34;&gt;1 2 3 4 \n4\n1 2 3 \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;栈的特点就是先进先出，但是如果需要随机取出前面的数据，效率会比较低，需要倒腾出来，但是如果底层使用数组，理论上是可以通过索引下标取出的，&lt;code&gt;Java&lt;/code&gt;里面正是这样实现。&lt;/p&gt;\n&lt;h2 id=\&#34;队列\&#34;&gt;队列&lt;/h2&gt;\n&lt;p&gt;既然前面有先进后出的数据结构，那我们必定也有先进先出的数据结构，疫情的时候，排队估计大家都有测过核酸，那排队老长了，排在前面先测，排在后面后测，这道理大家都懂。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;24\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108162737.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;blockquote&gt;\n&lt;p&gt;队列是一种特殊的&lt;a href=\&#34;https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081\&#34;&gt;线性表&lt;/a&gt;，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;队列的特点是先进先出，以下是例子：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;25\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108164851.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;一般只要说到先进先出（&lt;code&gt;FIFO&lt;/code&gt;）,全称&lt;code&gt;First In First Out&lt;/code&gt;,就会想到队列，但是如果你想拥有队列即可以从队头取出元素，又可以从队尾取出元素，那就需要用到特殊的队列（双向队列），双向队列一般使用双向链表实现会简单一点。&lt;/p&gt;\n&lt;p&gt;下面我们用&lt;code&gt;Java&lt;/code&gt;实现简单的单向队列：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;class Node&amp;lt;T&amp;gt; {\n    public T data;\n    public Node next;\n\n    public Node(T data) {\n        this.data = data;\n    }\n}\n\npublic class MyQueue&amp;lt;T&amp;gt; {\n    private Node&amp;lt;T&amp;gt;  head;\n    private Node&amp;lt;T&amp;gt;  rear;\n    private int size;\n\n    public MyQueue() {\n        size = 0;\n    }\n\n    public void pushBack(T element) {\n        Node newNode = new Node(element);\n        if (isEmpty()) {\n            head = newNode;\n        } else {\n            rear.next = newNode;\n        }\n        rear = newNode;\n        size++;\n    }\n\n    public boolean isEmpty() {\n        return head == null;\n    }\n\n    public T popFront() {\n        if (isEmpty()) {\n            throw new NullPointerException(&amp;quot;队列没有数据&amp;quot;);\n        } else {\n            Node&amp;lt;T&amp;gt; node = head;\n            head = head.next;\n            size--;\n            return node.data;\n        }\n    }\n\n    public void dispaly() {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data +&amp;quot; -&amp;gt; &amp;quot;);\n            temp = temp.next;\n        }\n        System.out.println(&amp;quot;&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;测试代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;public class MyStackTest {\n    public static void main(String[] args) {\n        MyStack&amp;lt;Integer&amp;gt; myStack = new MyStack&amp;lt;&amp;gt;();\n        myStack.push(1);\n        myStack.push(2);\n        myStack.push(3);\n        myStack.push(4);\n        myStack.display();\n\n        System.out.println(myStack.pop());\n\n        myStack.display();\n\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; \n1\n2 -&amp;gt; 3 -&amp;gt; \n2\n3 -&amp;gt; \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;常用的队列类型如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;单向队列：也就是我们说的普通队列，先进先出。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;双向队列：可以从不同方向进出队列&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;优先队列：内部是自动排序的，按照一定顺序出队列&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;阻塞队列：从队列取出元素的时候，队列没有元素则会阻塞，同样如果队列满了，往队列里面放入元素也会被阻塞。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;循环队列：可以理解为一个循环链表，但是一般需要标识出头尾节点，防止死循环，尾节点的&lt;code&gt;next&lt;/code&gt;指向头结点。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;队列一般可以用来保存需要顺序的数据，或者保存任务，在树的层次遍历中可以使用队列解决，一般广度优先搜索都可以使用队列解决。&lt;/p&gt;\n&lt;h2 id=\&#34;哈希表\&#34;&gt;哈希表&lt;/h2&gt;\n&lt;p&gt;前面的数据结构，查找的时候，一般都是使用&lt;code&gt;=&lt;/code&gt;或者&lt;code&gt;!=&lt;/code&gt;,在折半查找或者其他范围查询的时候，可能会使用&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;&amp;gt;&lt;/code&gt;,理想的时候，我们肯定希望不经过任何的比较，直接能定位到某个位置（存储位置），这种在数组中，可以通过索引取得元素。那么，如果我们将需要存储的数据和数组的索引对应起来，并且是一对一的关系，那不就可以很快定位到元素的位置了么？&lt;/p&gt;\n&lt;p&gt;只要通过函数&lt;code&gt;f(k)&lt;/code&gt;就能找到&lt;code&gt;k&lt;/code&gt;对应的位置，这个函数&lt;code&gt;f(k)&lt;/code&gt;就是&lt;code&gt;hash&lt;/code&gt;函数。它表示的是一种映射关系，但是对不同的值，可能会映射到同一个值（同一个&lt;code&gt;hash&lt;/code&gt;地址），也就是&lt;code&gt;f(k1) = f(k2)&lt;/code&gt;，这种现象我们称之为&lt;code&gt;冲突&lt;/code&gt;或者&lt;code&gt;碰撞&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;表定义如下：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;26\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108174206.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;一般常用的&lt;code&gt;hash&lt;/code&gt; 函数有：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;直接定址法：取出关键字或者关键字的某个线性函数的值为哈希函数，比如&lt;code&gt;H(key) = key&lt;/code&gt;或者&lt;code&gt;H(key) = a * key + b&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;数字分析法：对于可能出现的数值全部了解，取关键字的若干数位组成哈希地址&lt;/li&gt;\n&lt;li&gt;平方取中法：取关键字平方后的中间几位作为哈希地址&lt;/li&gt;\n&lt;li&gt;折叠法：将关键字分割成为位数相同的几部分（最后一部分的位数可以不同），取这几部分的叠加和（舍去进位），作为哈希地址。&lt;/li&gt;\n&lt;li&gt;除留余数法：取关键字被某个不大于散列表表长&lt;code&gt;m&lt;/code&gt;的数&lt;code&gt;p&lt;/code&gt;除后所得的余数为散列地址。即h&lt;code&gt;ash(k)=k mod p&lt;/code&gt;，&lt;code&gt;p&amp;lt; =m&lt;/code&gt;。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对&lt;code&gt;p&lt;/code&gt;的选择很重要，一般取素数或&lt;code&gt;m&lt;/code&gt;，若&lt;code&gt;p&lt;/code&gt;选择不好，容易产生冲突。&lt;/li&gt;\n&lt;li&gt;随机数法：取关键字的随机函数值作为它的哈希地址。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;但是这些方法，都无法避免哈希冲突，只能有意识的减少。那处理&lt;code&gt;hash&lt;/code&gt;冲突，一般有哪些方法呢？&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;开放地址法：&lt;code&gt;hash&lt;/code&gt;计算后，如果该位置已经有数据，那么对该地址&lt;code&gt;+1&lt;/code&gt;，也就是往后找，知道找到一个空的位置。&lt;/li&gt;\n&lt;li&gt;重新&lt;code&gt;hash&lt;/code&gt;法：发生哈希冲突后，可以使用另外的&lt;code&gt;hash&lt;/code&gt;函数重新极计算，找到空的&lt;code&gt;hash&lt;/code&gt;地址,如果有，还可以再叠加&lt;code&gt;hash&lt;/code&gt;函数。&lt;/li&gt;\n&lt;li&gt;链地址法：所有&lt;code&gt;hash&lt;/code&gt;值一样的,链接成为一个链表，挂在数组后面。&lt;/li&gt;\n&lt;li&gt;建立公共溢出区：不常见，意思是所有元素，如果和表中的元素&lt;code&gt;hash&lt;/code&gt;冲突，都弄到另外一个表，也叫溢出表。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;code&gt;Java&lt;/code&gt;里面，用的就是链地址法：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;27\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108175944.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;但是如果&lt;code&gt;hash&lt;/code&gt;冲突比较严重，链表会比较长，查询的时候，需要遍历后面的链表，因此&lt;code&gt;JDK&lt;/code&gt;优化了一版，链表的长度超过阈值的时候，会变成&lt;strong&gt;红黑树&lt;/strong&gt;，红黑树有一定的规则去平衡子树，避免退化成为链表，影响查询效率。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;28\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108180256.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;但是你肯定会想到，如果数组太小了，放了比较多数据了，怎么办？再放冲突的概率会越来越高，其实这个时候会触发一个扩容机制，将数组扩容成为 &lt;code&gt;2&lt;/code&gt;倍大小，重新&lt;code&gt;hash&lt;/code&gt;以前的数据，哈希到不同的数组中。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;表的优点是查找速度快，但是如果不断触发重新 &lt;code&gt;hash&lt;/code&gt;, 响应速度也会变慢。同时，如果希望范围查询，&lt;code&gt;hash&lt;/code&gt;表不是好的选择。&lt;/p&gt;\n&lt;h2 id=\&#34;树\&#34;&gt;树&lt;/h2&gt;\n&lt;p&gt;数组和链表都是线性结构，而这里要介绍的树，则是非线性结构。现实中树是金字塔结构，数据结构中的树，最上面称之为根节点。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;29\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108212239.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;我们该如何定义树结构呢？&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;是一种&lt;a href=\&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450\&#34;&gt;数据结构&lt;/a&gt;，它是由&lt;em&gt;n(n≥1&lt;/em&gt;)个有限节点组成一个具有层次关系的&lt;a href=\&#34;https://baike.baidu.com/item/%E9%9B%86%E5%90%88/2908117\&#34;&gt;集合&lt;/a&gt;。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：&lt;/p&gt;\n&lt;p&gt;每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树。(百度百科)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;下面是树的基本术语（来自于清华大学数据结构&lt;code&gt;C&lt;/code&gt;语言版）：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;节点的度：一个节点含有的子树的个数称为该节点的度&lt;/li&gt;\n&lt;li&gt;树的度：一棵树中，最大的节点度称为树的度；&lt;/li&gt;\n&lt;li&gt;叶节点或终端节点：度为零的节点；&lt;/li&gt;\n&lt;li&gt;非终端节点或分支节点：度不为零的节点；&lt;/li&gt;\n&lt;li&gt;父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；&lt;/li&gt;\n&lt;li&gt;孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；&lt;/li&gt;\n&lt;li&gt;兄弟节点：具有相同父节点的节点互称为兄弟节点；&lt;/li&gt;\n&lt;li&gt;节点的层次：从根开始定义起，根为第&lt;code&gt;1&lt;/code&gt;层，根的子节点为第&lt;code&gt;2&lt;/code&gt;层，以此类推；&lt;/li&gt;\n&lt;li&gt;深度：对于任意节点&lt;code&gt;n&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;的深度为从根到n的唯一路径长，根的深度为&lt;code&gt;0&lt;/code&gt;；&lt;/li&gt;\n&lt;li&gt;高度：对于任意节点&lt;code&gt;n&lt;/code&gt;,&lt;code&gt;n&lt;/code&gt;的高度为从&lt;code&gt;n&lt;/code&gt;到一片树叶的最长路径长，所有树叶的高度为&lt;code&gt;0&lt;/code&gt;；&lt;/li&gt;\n&lt;li&gt;堂兄弟节点：父节点在同一层的节点互为堂兄弟；&lt;/li&gt;\n&lt;li&gt;节点的祖先：从根到该节点所经分支上的所有节点；&lt;/li&gt;\n&lt;li&gt;子孙：以某节点为根的子树中任一节点都称为该节点的子孙。&lt;/li&gt;\n&lt;li&gt;有序树：将树种的节点的各个子树看成从左至右是有次序的（不能互换），则应该称该树为有序树，否则为无序树&lt;/li&gt;\n&lt;li&gt;第一个孩子：在有序树中最左边的子树的根称为第一个孩子&lt;/li&gt;\n&lt;li&gt;最后一个孩子：在有序树种最右边的子树的根称为最后一个孩子&lt;/li&gt;\n&lt;li&gt;森林：由&lt;code&gt;m&lt;/code&gt;（&lt;code&gt;m&amp;gt;=0&lt;/code&gt;）棵互不相交的树的集合称为森林；&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;树，其实我们最常用的是二叉树：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;30\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108213545.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;二叉树的特点是每个节点最多只有两个子树，并且子树有左右之分，左右子节点的次序不能任意颠倒。&lt;/p&gt;\n&lt;p&gt;二叉树在&lt;code&gt;Java&lt;/code&gt;中表示：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;public class TreeLinkNode {\n    int val;\n    TreeLinkNode left = null;\n    TreeLinkNode right = null;\n    TreeLinkNode next = null;\n\n    TreeLinkNode(int val) {\n        this.val = val;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;满二叉树：一棵深度为 k 且有 2&lt;sup&gt;k&lt;/sup&gt;-1 个节点的二叉树，称之为满二叉树&lt;/p&gt;\n&lt;p&gt;完全二叉树：深度为 k 的，有 n 个节点的二叉树，当且仅当其每一个节点都与深度为 k 的满二叉树中编号从 1 到 n 的节点一一对应是，称之为完全二叉树。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;31\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108214243.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;一般二叉树的遍历有几种：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;前序遍历：遍历顺序 根节点 --&amp;gt; 左子节点 --&amp;gt; 右子节点&lt;/li&gt;\n&lt;li&gt;中序遍历：遍历顺序  左子节点  --&amp;gt; 根节点 --&amp;gt; 右子节点&lt;/li&gt;\n&lt;li&gt;后序遍历：遍历顺序 左子节点 --&amp;gt; 右子节点 --&amp;gt; 根节点&lt;/li&gt;\n&lt;li&gt;广度 / 层次遍历： 从上往下，一层一层的遍历&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;如果是一棵混乱的二叉树，那查找或者搜索的效率也会比较低，和一条混乱的链表没有什么区别，何必弄更加复杂的结构呢？&lt;/p&gt;\n&lt;p&gt;其实，二叉树是可以用在排序或者搜索中的，因为二叉树有严格的左右子树之分，我们可以定义根节点，左子节点，右子节点的大小之分。于是有了二叉搜索树：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;a href=\&#34;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/7077965\&#34;&gt;二叉查找树&lt;/a&gt;（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的&lt;a href=\&#34;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879\&#34;&gt;二叉树&lt;/a&gt;： 若它的左子树不空，则左子树上所有结点的值均小于它的&lt;a href=\&#34;https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93%E7%82%B9/9795570\&#34;&gt;根结点&lt;/a&gt;的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为&lt;a href=\&#34;https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079\&#34;&gt;二叉排序树&lt;/a&gt;。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;二叉查找树样例如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;32\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108220407.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;比如上面的树，如果我们需要查找到 &lt;code&gt;4&lt;/code&gt;， 从 &lt;code&gt;5&lt;/code&gt;开始，&lt;code&gt;4&lt;/code&gt;比&lt;code&gt;5&lt;/code&gt;小，往左子树走，查找到&lt;code&gt;3&lt;/code&gt;，&lt;code&gt;4&lt;/code&gt;比&lt;code&gt;3&lt;/code&gt;大，往右子树走，找到了&lt;code&gt;4&lt;/code&gt;，也就是一个 &lt;code&gt;7&lt;/code&gt;个节点的树，我们只查找了&lt;code&gt;3&lt;/code&gt;次，也就是层数，假设&lt;code&gt;n&lt;/code&gt;个节点，那就是&lt;code&gt;log(n+1)&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;树维护好了，查询效率固然高，但是如果树没维护好，容易退化成为链表，查询效率也会下降，比如：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;33\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108222210.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;一棵对查询友好的二叉树，应该是一个平衡或者接近平衡的二叉树，何为平衡二叉树：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;平衡二叉搜索树的任何结点的左子树和右子树高度最多相差1。平衡二叉树也称为 AVL 树。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;为了保证插入或者删除数据等之后，二叉树还是平衡二叉树，那么就需要调整节点，这个也称为平衡过程，里面会涉及各种旋转调整，这里暂时不展开。&lt;/p&gt;\n&lt;p&gt;但是如果涉及大量的更新，删除操作，平衡树种的各种调整需要牺牲不小的性能，为了解决这个问题，有大佬提出了红黑树.&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在&lt;a href=\&#34;https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA\&#34;&gt;计算机&lt;/a&gt;科学中用到的一种&lt;a href=\&#34;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450\&#34;&gt;数据结构&lt;/a&gt;，典型的用途是实现&lt;a href=\&#34;https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/3317025\&#34;&gt;关联数组&lt;/a&gt;。 [1]&lt;/p&gt;\n&lt;p&gt;红黑树是在1972年由[Rudolf Bayer](https://baike.baidu.com/item/Rudolf Bayer/3014716)发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。 [2]&lt;/p&gt;\n&lt;p&gt;红黑树是一种特化的AVL树（&lt;a href=\&#34;https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057\&#34;&gt;平衡二叉树&lt;/a&gt;），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;红黑树有以下的特点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;性质1. 结点是红色或黑色。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;性质2. 根结点是黑色。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;性质3. 所有叶子都是黑色。（叶子是NIL结点）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;正是这些特性，让红黑树在调整的时候，不像普通的平衡二叉树调整那般困难，频繁。也就是加上了条条框框，让它符合一定的标准，减少平衡过程的混乱以及频次。&lt;/p&gt;\n&lt;p&gt;前面说的哈希表，&lt;code&gt;Java&lt;/code&gt; 中的实现，正是应用了红黑树，在&lt;code&gt;hash&lt;/code&gt;冲突较多的时候，会将链表转换成为红黑树。&lt;/p&gt;\n&lt;p&gt;上面说的都是二叉树，但是我们不得不扯一下多叉树，为什么呢？虽然二叉树中的各种搜索树，红黑树已经很优秀了，但是在与磁盘交互的时候，大多数是数据存储中，我们不得不考虑 IO 的因素，因为磁盘IO比内存慢太多了。如果索引树的层高有几千上万，那么磁盘读取的时候，需要次数太多了。B树更加适合磁盘存储。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;970年，R.Bayer和E.mccreight提出了一种适用于外查找的&lt;a href=\&#34;https://baike.baidu.com/item/%E6%A0%91/2699484\&#34;&gt;树&lt;/a&gt;，它是一种平衡的多叉树，称为B树（或B-树、B_树）。&lt;/p&gt;\n&lt;p&gt;一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：&lt;/p&gt;\n&lt;p&gt;1、根结点至少有两个子女；&lt;/p&gt;\n&lt;p&gt;2、每个非根节点所包含的关键字个数 j 满足：m/2 - 1 &amp;lt;= j &amp;lt;= m - 1；&lt;/p&gt;\n&lt;p&gt;3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故&lt;strong&gt;内部子树&lt;/strong&gt;个数 k 满足：m/2 &amp;lt;= k &amp;lt;= m ；&lt;/p&gt;\n&lt;p&gt;4、所有的叶子结点都位于同一层。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;每个节点放多一点数据，查找的时候，内存中的操作比磁盘快很多，&lt;code&gt;b&lt;/code&gt;树可以减少磁盘IO的次数。B 树：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;34\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108231118.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;而每个节点的&lt;code&gt;data&lt;/code&gt;可能很大,这样会导致每一页查出来的数据很少，IO查询次数自然就增加了，那我们不如只在叶子节点中存储数据：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;35\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220108231837.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;blockquote&gt;\n&lt;p&gt;B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:&lt;/p&gt;\n&lt;p&gt;(1)每个结点至多有m个子女；&lt;/p&gt;\n&lt;p&gt;(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；&lt;/p&gt;\n&lt;p&gt;(3)有k个子女的结点必有k个关键字。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;&lt;strong&gt;一般b+树的叶子节点，会用链表连接起来，方便遍历以及范围遍历。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;这就是&lt;code&gt;b+&lt;/code&gt;树，&lt;code&gt;b+&lt;/code&gt;树相对于&lt;code&gt;B树&lt;/code&gt;多了以下优势：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;&lt;code&gt;b+&lt;/code&gt;树的中间节点不保存数据，每次IO查询能查到更多的索引，,是一个矮胖的树。&lt;/li&gt;\n&lt;li&gt;对于范围查找来说，&lt;code&gt;b+&lt;/code&gt;树只需遍历叶子节点链表即可，&lt;code&gt;b&lt;/code&gt;树却需要从根节点都叶子节点。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;除了上面的树，其实还有一种叫&lt;code&gt;Huffman&lt;/code&gt;树：给定N个权值作为N个&lt;a href=\&#34;https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9/3620239\&#34;&gt;叶子结点&lt;/a&gt;，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。&lt;/p&gt;\n&lt;p&gt;一般用来作为压缩使用，因为数据中，每个字符出现的频率不一样，出现频率越高的字符，我们用越短的编码保存，就可以达到压缩的目的。那这个编码怎么来的呢？&lt;/p&gt;\n&lt;p&gt;假设字符是&lt;code&gt;hello&lt;/code&gt;,那么编码可能是（只是编码的大致雏形，高频率出现的字符，编码更短），编码就是从根节点到当前字符的路径的&lt;code&gt;01&lt;/code&gt;串：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;36\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109140839.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;通过不同权值的编码，哈夫曼树到了有效的压缩。&lt;/p&gt;\n&lt;h2 id=\&#34;堆\&#34;&gt;堆&lt;/h2&gt;\n&lt;p&gt;堆，其实也是二叉树中的一种，堆必须是完全二叉树，完全二叉树是：除了最后一层，其他层的节点个数都是满的，最后一层的节点都集中在左部连续位置。&lt;/p&gt;\n&lt;p&gt;而堆还有一个要求：堆中每一个节点的值都必须大于等于（或小于等于）其左右子节点的值。&lt;/p&gt;\n&lt;p&gt;堆主要分为两种：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;大顶堆：每个节点都大于等于其子树节点（堆顶是最大值）&lt;/li&gt;\n&lt;li&gt;小顶堆：每个节点都小于等于其子树节点（堆顶是最小值）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;一般情况下，我们都是用数组来表示堆，比如下面的小顶堆：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;37\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220109000632499.png\&#34; alt=\&#34;image-20220109000632499\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;数组中父子节点以及左右节点的关系如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;i &lt;/code&gt;结点的父结点 &lt;code&gt;parent = floor((i-1)/2) &lt;/code&gt;(向下取整)&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;i &lt;/code&gt;结点的左子结点 &lt;code&gt;2 * i +1&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;i &lt;/code&gt;结点的右子结点 &lt;code&gt;2 * i + 2&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;既然是存储数据的，那么一定会涉及到插入删除等操作，堆里面插入删除，会涉及到堆的调整，调整之后才能重新满足它的定义，这个调整的过程，叫做&lt;strong&gt;堆化&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;用小顶堆举例，调整主要是为了保证：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;还是完全二叉树&lt;/li&gt;\n&lt;li&gt;堆中每一个节点都还小于等于其左右子节点&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;对于小顶堆，调整的时候是：小元素往上浮，大元素往下沉，就是不断交换的过程。&lt;/p&gt;\n&lt;p&gt;堆一般可以用来求解&lt;code&gt;TOP K&lt;/code&gt; 问题，或者前面我们说的优先队列等。&lt;/p&gt;\n&lt;h2 id=\&#34;图\&#34;&gt;图&lt;/h2&gt;\n&lt;p&gt;终于来到了图的讲解，图其实就是二维平面，之前写过扫雷，扫雷的整个方块区域，其实也可以说是图相关的。图是非线性的数据结构，主要是由边和顶点组成。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;38\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20220109002114134.png\&#34; alt=\&#34;image-20220109002114134\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;同时图又分为有向图与无向图，上面的是无向图，因为边没有指明方向，只是表示两者关联关系，而有向图则是这样：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;39\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109002313.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;如果每个顶点是一个地方，每条边是路径，那么这就是一张地图网络，因此图也经常被用于求解最短距离。先来看看图相关的概念：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;顶点：图最基本的单元，那些节点&lt;/li&gt;\n&lt;li&gt;边：顶点之间的关联关系&lt;/li&gt;\n&lt;li&gt;相邻顶点：由边直接关联的顶点&lt;/li&gt;\n&lt;li&gt;度：一个顶点直接连接的相邻顶点的数量&lt;/li&gt;\n&lt;li&gt;权重：边的权值&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;一般表示图有以下几种方法：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;邻接矩阵，使用二维数组表示，为1 表示联通，0表示不连通，当然如果表示路径长度的时候，可以用大于&lt;code&gt;0&lt;/code&gt;的数表示路径长度，用&lt;code&gt;-1&lt;/code&gt;表示不连通。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;下面的图片中，0和 1，2连通，我们可以看到第 0行的第1，2列是1 ，表示连通。还有一点：顶点自身我们是标识了0，表示不连通，但是有些情况可以视为连通状态。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;40\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109115154.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ol start=\&#34;2\&#34;&gt;\n&lt;li&gt;邻接表&lt;/li&gt;\n&lt;/ol&gt;\n&lt;blockquote&gt;\n&lt;p&gt;邻接表，存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的&lt;a href=\&#34;https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/350782\&#34;&gt;存储结构&lt;/a&gt;。如这个表头结点所对应的顶点存在&lt;a href=\&#34;https://baike.baidu.com/item/%E7%9B%B8%E9%82%BB/1534684\&#34;&gt;相邻&lt;/a&gt;顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。&lt;/p&gt;\n&lt;p&gt;对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;41\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109123929.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;图里面遍历一般分为广度优先遍历和深度优先遍历，广度优先遍历是指优先遍历与当前顶点&lt;strong&gt;直接相关&lt;/strong&gt;的顶点，一般借助队列实现。而深度优先遍历则是往一个方向一直走到不能再走，有点不撞南墙不回头的意思，一般使用递归实现。&lt;/p&gt;\n&lt;p&gt;图，除了用了计算最小路径以外，还有一个概念：最小生成树。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;有一种说法，图是平面上的点，我们把其中一个点拎起来，能将其他顶点带起来的边，取最小权值，多余的边去掉，就是最小生成树。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;42\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20220109141906.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;当然，最小生成树并不一定是唯一的，可能存在多种结果。&lt;/p&gt;\n&lt;h2 id=\&#34;秦怀观点\&#34;&gt;秦怀@观点&lt;/h2&gt;\n&lt;p&gt;了解这些基本的数据结构，在写代码或者数据建模的时候，能够选择更加合适的，这是最大的用处。计算机是为人服务的，代码也是，数据结构的全部类型我们是无法一下子一一掌握的，但是基本的东西是变动不会很大，除非新一代革命性变化。&lt;/p&gt;\n&lt;p&gt;程序是由数据结构和算法组成，数据结构就像是基石，借助《数据结构C语言》版本中的一句话结尾：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;为了编写出一个”好“的程序，必须分析待处理的对象的特性以及各处理对象之间存在的关系，这就是”数据结构“这门学科和发展的背景。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;43\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E7%82%B9%E8%B5%9EV2.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;man-you-shu-ju-jie-gou-shi-jie&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;blockquote&gt;\n&lt;p&gt;程序 = 数据结构 + 算法&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;是的，上面这句话是非常经典的，程序由数据结构以及算法组成，当然数据结构和算法也是相辅相成的，不能完全独立来看待，但是本文会相对重点聊聊那些常用的数据结构。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;漫游数据结构世界&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;数据结构与算法&#34;,&#34;slug&#34;:&#34;bRrOd3Jmn&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/bRrOd3Jmn/&#34;}],&#34;date&#34;:&#34;2023-03-02 22:58:33&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/man-you-shu-ju-jie-gou-shi-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;42 min read&#34;,&#34;time&#34;:2486000,&#34;words&#34;:11250,&#34;minutes&#34;:42},&#34;description&#34;:&#34;\n\n程序 = 数据结构 + 算法\n\n是的，上面这句话是非常经典的，程序由数据结构以及算法组成，当然数据结构和算法也是相辅相成的，不能完全独立来看待，但是本文会相对重点聊聊那些常用的数据结构。\n\n\n数据结构是什么呢？\n首先得知道数据是什么？数...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%8Dbit\&#34;&gt;位（bit）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86%E5%8E%9F%E7%A0%81%E8%BF%98%E8%A6%81%E5%8F%8D%E7%A0%81%E5%92%8C%E8%A1%A5%E7%A0%81\&#34;&gt;为什么有了原码还要反码和补码？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2\&#34;&gt;布隆过滤器是什么呢？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E7%BB%84\&#34;&gt;数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%93%BE%E8%A1%A8\&#34;&gt;链表&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B7%B3%E8%A1%A8\&#34;&gt;跳表&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%88\&#34;&gt;栈&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%98%9F%E5%88%97\&#34;&gt;队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%93%88%E5%B8%8C%E8%A1%A8\&#34;&gt;哈希表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%91\&#34;&gt;树&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A0%86\&#34;&gt;堆&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%BE\&#34;&gt;图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A7%A6%E6%80%80%E8%A7%82%E7%82%B9\&#34;&gt;秦怀@观点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;前面文章在谈论分布式唯一ID生成的时候，有提到雪花算法，这一次，我们详细点讲解，只讲它。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;snowflake算法\&#34;&gt;SnowFlake算法&lt;/h2&gt;\n&lt;blockquote&gt;\n&lt;p&gt;据国家大气研究中心的查尔斯·奈特称，一般的雪花大约由10^19个水分子组成。在雪花形成过程中，会形成不同的结构分支，所以说大自然中不存在两片完全一样的雪花，每一片雪花都拥有自己漂亮独特的形状。雪花算法表示生成的id如雪花般独一无二。&lt;/p&gt;\n&lt;p&gt;snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;核心思想：分布式，唯一。&lt;/p&gt;\n&lt;h2 id=\&#34;算法具体介绍\&#34;&gt;算法具体介绍&lt;/h2&gt;\n&lt;p&gt;雪花算法是 64 位 的二进制，一共包含了四部分：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1位是符号位，也就是最高位，始终是0，没有任何意义，因为要是唯一计算机二进制补码中就是负数，0才是正数。&lt;/li&gt;\n&lt;li&gt;41位是时间戳，具体到毫秒，41位的二进制可以使用69年，因为时间理论上永恒递增，所以根据这个排序是可以的。&lt;/li&gt;\n&lt;li&gt;10位是机器标识，可以全部用作机器ID，也可以用来标识机房ID + 机器ID，10位最多可以表示1024台机器。&lt;/li&gt;\n&lt;li&gt;12位是计数序列号，也就是同一台机器上同一时间，理论上还可以同时生成不同的ID，12位的序列号能够区分出4096个ID。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211015001825.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;优化\&#34;&gt;优化&lt;/h3&gt;\n&lt;p&gt;由于41位是时间戳，我们的时间计算是从1970年开始的，只能使用69年，为了不浪费，其实我们可以用时间的相对值，也就是以项目开始的时间为基准时间，往后可以使用69年。获取唯一ID的服务，对处理速度要求比较高，所以我们全部使用位运算以及位移操作，获取当前时间可以使用&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;。&lt;/p&gt;\n&lt;h3 id=\&#34;时间回拨问题\&#34;&gt;时间回拨问题&lt;/h3&gt;\n&lt;p&gt;在获取时间的时候，可能会出现&lt;code&gt;时间回拨&lt;/code&gt;的问题，什么是时间回拨问题呢？就是服务器上的时间突然倒退到之前的时间。&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;人为原因，把系统环境的时间改了。&lt;/li&gt;\n&lt;li&gt;有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;回拨时间小的时候，不生成 ID，循环等待到时间点到达。&lt;/li&gt;\n&lt;li&gt;上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么超过一定大小的回拨直接报错，拒绝服务，或者有一种方案是利用拓展位，回拨之后在拓展位上加1就可以了，这样ID依然可以保持唯一。但是这个要求我们提前预留出位数，要么从机器id中，要么从序列号中，腾出一定的位，在时间回拨的时候，这个位置 &lt;code&gt;+1&lt;/code&gt;。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;p&gt;由于时间回拨导致的生产重复的ID的问题，其实百度和美团都有自己的解决方案了，有兴趣可以去看看，下面不是它们官网文档的信息：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;百度UIDGenerator：https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md\n&lt;ul&gt;\n&lt;li&gt;UidGenerator是Java实现的, 基于&lt;a href=\&#34;https://github.com/twitter/snowflake\&#34;&gt;Snowflake&lt;/a&gt;算法的唯一ID生成器。UidGenerator以组件形式工作在应用项目中, 支持自定义workerId位数和初始化策略, 从而适用于&lt;a href=\&#34;https://www.docker.com/\&#34;&gt;docker&lt;/a&gt;等虚拟化环境下实例自动重启、漂移等场景。 在实现上, UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;美团Leaf:https://tech.meituan.com/2019/03/07/open-source-project-leaf.html\n&lt;ul&gt;\n&lt;li&gt;leaf-segment 方案\n&lt;ul&gt;\n&lt;li&gt;优化：双buffer + 预分配&lt;/li&gt;\n&lt;li&gt;容灾：Mysql DB 一主两从，异地机房，半同步方式&lt;/li&gt;\n&lt;li&gt;缺点：如果用segment号段式方案：id是递增，可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;leaf-snowflake方案\n&lt;ul&gt;\n&lt;li&gt;使用Zookeeper持久顺序节点的特性自动对snowflake节点配置workerID\n&lt;ul&gt;\n&lt;li&gt;1.启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。&lt;/li&gt;\n&lt;li&gt;2.如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。&lt;/li&gt;\n&lt;li&gt;3.如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;缓存workerID，减少第三方组件的依赖&lt;/li&gt;\n&lt;li&gt;由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。&lt;strong&gt;或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警&lt;/strong&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;代码展示\&#34;&gt;代码展示&lt;/h2&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class SnowFlake {\n\n    // 数据中心(机房) id\n    private long datacenterId;\n    // 机器ID\n    private long workerId;\n    // 同一时间的序列\n    private long sequence;\n\n    public SnowFlake(long workerId, long datacenterId) {\n        this(workerId, datacenterId, 0);\n    }\n\n    public SnowFlake(long workerId, long datacenterId, long sequence) {\n        // 合法判断\n        if (workerId &amp;gt; maxWorkerId || workerId &amp;lt; 0) {\n            throw new IllegalArgumentException(String.format(&amp;quot;worker Id can&#39;t be greater than %d or less than 0&amp;quot;, maxWorkerId));\n        }\n        if (datacenterId &amp;gt; maxDatacenterId || datacenterId &amp;lt; 0) {\n            throw new IllegalArgumentException(String.format(&amp;quot;datacenter Id can&#39;t be greater than %d or less than 0&amp;quot;, maxDatacenterId));\n        }\n        System.out.printf(&amp;quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&amp;quot;,\n                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);\n\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n        this.sequence = sequence;\n    }\n\n    // 开始时间戳（2021-10-16 22:03:32）\n    private long twepoch = 1634393012000L;\n\n    // 机房号，的ID所占的位数 5个bit 最大:11111(2进制)--&amp;gt; 31(10进制)\n    private long datacenterIdBits = 5L;\n\n    // 机器ID所占的位数 5个bit 最大:11111(2进制)--&amp;gt; 31(10进制)\n    private long workerIdBits = 5L;\n\n    // 5 bit最多只能有31个数字，就是说机器id最多只能是32以内\n    private long maxWorkerId = -1L ^ (-1L &amp;lt;&amp;lt; workerIdBits);\n\n    // 5 bit最多只能有31个数字，机房id最多只能是32以内\n    private long maxDatacenterId = -1L ^ (-1L &amp;lt;&amp;lt; datacenterIdBits);\n\n    // 同一时间的序列所占的位数 12个bit 111111111111 = 4095  最多就是同一毫秒生成4096个\n    private long sequenceBits = 12L;\n\n    // workerId的偏移量\n    private long workerIdShift = sequenceBits;\n\n    // datacenterId的偏移量\n    private long datacenterIdShift = sequenceBits + workerIdBits;\n\n    // timestampLeft的偏移量\n    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;\n\n    // 序列号掩码 4095 (0b111111111111=0xfff=4095)\n    // 用于序号的与运算，保证序号最大值在0-4095之间\n    private long sequenceMask = -1L ^ (-1L &amp;lt;&amp;lt; sequenceBits);\n\n    // 最近一次时间戳\n    private long lastTimestamp = -1L;\n\n\n    // 获取机器ID\n    public long getWorkerId() {\n        return workerId;\n    }\n\n\n    // 获取机房ID\n    public long getDatacenterId() {\n        return datacenterId;\n    }\n\n\n    // 获取最新一次获取的时间戳\n    public long getLastTimestamp() {\n        return lastTimestamp;\n    }\n\n\n    // 获取下一个随机的ID\n    public synchronized long nextId() {\n        // 获取当前时间戳，单位毫秒\n        long timestamp = timeGen();\n\n        if (timestamp &amp;lt; lastTimestamp) {\n            System.err.printf(&amp;quot;clock is moving backwards.  Rejecting requests until %d.&amp;quot;, lastTimestamp);\n            throw new RuntimeException(String.format(&amp;quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&amp;quot;,\n                    lastTimestamp - timestamp));\n        }\n\n        // 去重\n        if (lastTimestamp == timestamp) {\n\n            sequence = (sequence + 1) &amp;amp; sequenceMask;\n\n            // sequence序列大于4095\n            if (sequence == 0) {\n                // 调用到下一个时间戳的方法\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {\n            // 如果是当前时间的第一次获取，那么就置为0\n            sequence = 0;\n        }\n\n        // 记录上一次的时间戳\n        lastTimestamp = timestamp;\n\n        // 偏移计算\n        return ((timestamp - twepoch) &amp;lt;&amp;lt; timestampLeftShift) |\n                (datacenterId &amp;lt;&amp;lt; datacenterIdShift) |\n                (workerId &amp;lt;&amp;lt; workerIdShift) |\n                sequence;\n    }\n\n    private long tilNextMillis(long lastTimestamp) {\n        // 获取最新时间戳\n        long timestamp = timeGen();\n        // 如果发现最新的时间戳小于或者等于序列号已经超4095的那个时间戳\n        while (timestamp &amp;lt;= lastTimestamp) {\n            // 不符合则继续\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    public static void main(String[] args) {\n        SnowFlake worker = new SnowFlake(1, 1);\n        long timer = System.currentTimeMillis();\n        for (int i = 0; i &amp;lt; 10000; i++) {\n            worker.nextId();\n        }\n        System.out.println(System.currentTimeMillis());\n        System.out.println(System.currentTimeMillis() - timer);\n    }\n\n}\n\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;问题分析\&#34;&gt;问题分析&lt;/h2&gt;\n&lt;h3 id=\&#34;1-第一位为什么不使用\&#34;&gt;1. 第一位为什么不使用?&lt;/h3&gt;\n&lt;p&gt;在计算机的表示中，第一位是符号位，0表示整数，第一位如果是1则表示负数，我们用的ID默认就是正数，所以默认就是0，那么这一位默认就没有意义。&lt;/p&gt;\n&lt;h3 id=\&#34;2机器位怎么用\&#34;&gt;2.机器位怎么用？&lt;/h3&gt;\n&lt;p&gt;机器位或者机房位，一共10 bit，如果全部表示机器，那么可以表示1024台机器，如果拆分，5 bit 表示机房，5bit表示机房里面的机器，那么可以有32个机房，每个机房可以用32台机器。&lt;/p&gt;\n&lt;h3 id=\&#34;3-twepoch表示什么\&#34;&gt;3. twepoch表示什么？&lt;/h3&gt;\n&lt;p&gt;由于时间戳只能用69年，我们的计时又是从1970年开始的，所以这个&lt;code&gt;twepoch&lt;/code&gt;表示从项目开始的时间，用生成ID的时间减去&lt;code&gt;twepoch&lt;/code&gt;作为时间戳，可以使用更久。&lt;/p&gt;\n&lt;h3 id=\&#34;4-1l-1l-x-表示什么\&#34;&gt;4. -1L ^ (-1L &amp;lt;&amp;lt; x) 表示什么？&lt;/h3&gt;\n&lt;p&gt;表示 x 位二进制可以表示多少个数值，假设x为3：&lt;/p&gt;\n&lt;p&gt;在计算机中，第一位是符号位，负数的反码是除了符号位，1变0，0变1, 而补码则是反码+1：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;-1L 原码：1000 0001\n-1L 反码：1111 1110\n-1L 补码：1111 1111\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从上面的结果可以知道，&lt;strong&gt;-1L其实在二进制里面其实就是全部为1&lt;/strong&gt;,那么 -1L 左移动 3位，其实得到 &lt;code&gt;1111 1000&lt;/code&gt;，也就是最后3位是0，再与&lt;code&gt;-1L&lt;/code&gt;异或计算之后，其实得到的，就是后面3位全是1。&lt;code&gt;-1L ^ (-1L &amp;lt;&amp;lt; x) &lt;/code&gt;表示的其实就是x位全是1的值，也就是x位的二进制能表示的最大数值。&lt;/p&gt;\n&lt;h3 id=\&#34;5时间戳比较\&#34;&gt;5.时间戳比较&lt;/h3&gt;\n&lt;p&gt;在获取时间戳小于上一次获取的时间戳的时候，不能生成ID，而是继续循环，直到生成可用的ID，这里没有使用拓展位防止时钟回拨。&lt;/p&gt;\n&lt;h3 id=\&#34;6前端直接使用发生精度丢失\&#34;&gt;6.前端直接使用发生精度丢失&lt;/h3&gt;\n&lt;p&gt;如果前端直接使用服务端生成的long 类型 id，会发生精度丢失的问题，因为 JS 中Number是16位的（指的是十进制的数字），而雪花算法计算出来最长的数字是19位的，这个时候需要用 String 作为中间转换，输出到前端即可。&lt;/p&gt;\n&lt;h2 id=\&#34;秦怀の观点\&#34;&gt;秦怀の观点&lt;/h2&gt;\n&lt;p&gt;雪花算法其实是依赖于时间的一致性的，如果时间回拨，就可能有问题，一般使用拓展位解决。而只能使用69年这个时间限制，其实可以根据自己的需要，把时间戳的位数设置得更多一点，比如42位可以用139年，但是很多公司首先得活下来。当然雪花算法也不是银弹，它也有缺点，在单机上递增，而多台机器只是大致递增趋势，并不是严格递增的。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;没有最好的设计方案，只有合适和不合适的方案。&lt;/strong&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;xue-hua-suan-fa-de-xi-zhi-mo-jie-jiang-jie&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;前面文章在谈论分布式唯一ID生成的时候，有提到雪花算法，这一次，我们详细点讲解，只讲它。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;雪花算法的细枝末节讲解&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;雪花算法&#34;,&#34;slug&#34;:&#34;s6hsDukxY&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/s6hsDukxY/&#34;},{&#34;name&#34;:&#34;分布式&#34;,&#34;slug&#34;:&#34;F4e4OmSkx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/F4e4OmSkx/&#34;}],&#34;date&#34;:&#34;2023-03-02 00:17:30&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/xue-hua-suan-fa-de-xi-zhi-mo-jie-jiang-jie/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;12 min read&#34;,&#34;time&#34;:663000,&#34;words&#34;:2833,&#34;minutes&#34;:12},&#34;description&#34;:&#34;\n前面文章在谈论分布式唯一ID生成的时候，有提到雪花算法，这一次，我们详细点讲解，只讲它。\n\nSnowFlake算法\n\n据国家大气研究中心的查尔斯·奈特称，一般的雪花大约由10^19个水分子组成。在雪花形成过程中，会形成不同的结构分支，所以...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#snowflake%E7%AE%97%E6%B3%95\&#34;&gt;SnowFlake算法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%97%E6%B3%95%E5%85%B7%E4%BD%93%E4%BB%8B%E7%BB%8D\&#34;&gt;算法具体介绍&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%98%E5%8C%96\&#34;&gt;优化&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%97%B6%E9%97%B4%E5%9B%9E%E6%8B%A8%E9%97%AE%E9%A2%98\&#34;&gt;时间回拨问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA\&#34;&gt;代码展示&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90\&#34;&gt;问题分析&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E7%AC%AC%E4%B8%80%E4%BD%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8\&#34;&gt;1. 第一位为什么不使用?&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2%E6%9C%BA%E5%99%A8%E4%BD%8D%E6%80%8E%E4%B9%88%E7%94%A8\&#34;&gt;2.机器位怎么用？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-twepoch%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88\&#34;&gt;3. twepoch表示什么？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-1l-1l-x-%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88\&#34;&gt;4. -1L ^ (-1L &amp;lt;&amp;lt; x) 表示什么？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#5%E6%97%B6%E9%97%B4%E6%88%B3%E6%AF%94%E8%BE%83\&#34;&gt;5.时间戳比较&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#6%E5%89%8D%E7%AB%AF%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%8F%91%E7%94%9F%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1\&#34;&gt;6.前端直接使用发生精度丢失&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A7%A6%E6%80%80%E3%81%AE%E8%A7%82%E7%82%B9\&#34;&gt;秦怀の观点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n分布式系统全局唯一的 id 是所有系统都会遇到的场景，往往会被用在搜索，存储方面，用于作为唯一的标识或者排序，比如全局唯一的订单号，优惠券的券码等，如果出现两个相同的订单号，对于用户无疑将是一个巨大的bug。\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;分布式唯一id介绍\&#34;&gt;分布式唯一ID介绍&lt;/h2&gt;\n&lt;p&gt;在单体的系统中，生成唯一的 id 没有什么挑战，因为只有一台机器一个应用，直接使用单例加上一个原子操作自增即可。而在分布式系统中，不同的应用，不同的机房，不同的机器，要想生成的 ID 都是唯一的，确实需要下点功夫。&lt;/p&gt;\n&lt;p&gt;一句话总结：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;分布式唯一ID是为了给数据进行唯一标识。&lt;/strong&gt;&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;分布式唯一id的特征\&#34;&gt;分布式唯一ID的特征&lt;/h3&gt;\n&lt;p&gt;分布式唯一ID的核心是唯一性，其他的都是附加属性，一般来说，一个优秀的全局唯一ID方案有以下的特点，仅供参考：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;全局唯一：不可以重复，核心特点！&lt;/li&gt;\n&lt;li&gt;大致有序或者单调递增：自增的特性有利于搜索，排序，或者范围查询等&lt;/li&gt;\n&lt;li&gt;高性能：生成ID响应要快，延迟低&lt;/li&gt;\n&lt;li&gt;高可用：要是只能单机，挂了，全公司依赖全局唯一ID的服务，全部都不可用了，所以生成ID的服务必须高可用&lt;/li&gt;\n&lt;li&gt;方便使用：对接入者友好，能封装到开箱即用最好&lt;/li&gt;\n&lt;li&gt;信息安全：有些场景，如果连续，那么很容易被猜到，攻击也是有可能的，这得取舍。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;分布式唯一id的生成方案\&#34;&gt;分布式唯一ID的生成方案&lt;/h2&gt;\n&lt;h3 id=\&#34;uuid直接生成\&#34;&gt;UUID直接生成&lt;/h3&gt;\n&lt;p&gt;写过 Java 的朋友都知道，有时候我们写日志会用到一个类 UUID，会生成一个随机的ID，去作为当前用户请求记录的唯一识别码,只要用以下的代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;String uuid = UUID.randomUUID();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;用法简单粗暴，UUID的全称其实是&lt;code&gt;Universally Unique IDentifier&lt;/code&gt;,或者&lt;code&gt;GUID(Globally Unique IDentifier)&lt;/code&gt;,它本质上是一个 128 位的二进制整数，通常我们会表示成为 32 个 16 进制数组成的字符串，几乎不会重复，2 的 128 次方，那是无比庞大的数字。&lt;/p&gt;\n&lt;p&gt;以下是百度百科说明：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;UUID由以下几部分的组合：&lt;/p&gt;\n&lt;p&gt;（1）UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。&lt;/p&gt;\n&lt;p&gt;（2）时钟序列。&lt;/p&gt;\n&lt;p&gt;（3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。&lt;/p&gt;\n&lt;p&gt;UUID的唯一缺陷在于生成的结果串会比较长。关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。在ColdFusion中可以用CreateUUID()函数很简单地生成UUID，其格式为：xxxxxxxx-xxxx- xxxx-xxxxxxxxxxxxxxxx(8-4-4-16)，其中每个 x 是 0-9 或 a-f 范围内的一个十六进制的数字。而标准的UUID格式为：xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (8-4-4-4-12)，可以从cflib 下载CreateGUID() UDF进行转换。 [2]&lt;/p&gt;\n&lt;p&gt;（4）在 hibernate（Java orm框架）中， 采用 IP-JVM启动时间-当前时间右移32位-当前时间-内部计数（8-8-4-8-4）来组成UUID&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;要想重复，两台完全相同的虚拟机，开机时间一致，随机种子一致，同一时间生成uuid，才有极小的概率会重复，因此我们可认为，理论上会重复，实际不可能重复！！！&lt;/p&gt;\n&lt;p&gt;uuid优点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;性能好，效率高&lt;/li&gt;\n&lt;li&gt;不用网络请求，直接本地生成&lt;/li&gt;\n&lt;li&gt;不同的机器个干个的，不会重复&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;uuid 这么好，难不成是银弹？当然缺点也很突出：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;没办法保证递增趋势，没法排序&lt;/li&gt;\n&lt;li&gt;uuid太长了，存储占用空间大，特别落在数据库，对建立索引不友好&lt;/li&gt;\n&lt;li&gt;没有业务属性，这东西就是一串数字，没啥意义，或者说规律&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;当然也有人想要改进这家伙，比如不可读性改造，用&lt;code&gt;uuid to int64&lt;/code&gt;，把它转成 long 类型：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;byte[] bytes = Guid.NewGuid().ToByteArray();\nreturn BitConverter.ToInt64(bytes, 0);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;又比如，改造无序性，比如 &lt;code&gt;NHibernate&lt;/code&gt; 的 &lt;code&gt;Comb&lt;/code&gt; 算法，把 uuid 的前 20 个字符保留下来，后面 12 个字符用 &lt;code&gt;guid&lt;/code&gt; 生成的时间,时间是大致有序的，是一种小改进。&lt;/p&gt;\n&lt;p&gt;点评：&lt;strong&gt;UUID不存在数据库当索引，作为一些日志，上下文的识别，还是挺香的，但是要是这玩意用来当订单号，真是令人崩溃&lt;/strong&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;数据库自增序列\&#34;&gt;数据库自增序列&lt;/h3&gt;\n&lt;h4 id=\&#34;单机的数据库\&#34;&gt;单机的数据库&lt;/h4&gt;\n&lt;p&gt;数据库的主键本身就拥有一个自增的天然特性，只要设置ID为主键并且自增，我们就可以向数据库中插入一条记录，可以返回自增的ID，比如以下的建表语句：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;CREATE DATABASE `test`;\nuse test;\nCREATE TABLE id_table (\n    id bigint(20) unsigned NOT NULL auto_increment, \n    value char(10) NOT NULL default &#39;&#39;,\n    PRIMARY KEY (id),\n) ENGINE=MyISAM;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;插入语句：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;insert into id_table(value)  VALUES (&#39;v1&#39;);\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;优点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;单机，简单，速度也很快&lt;/li&gt;\n&lt;li&gt;天然自增，原子性&lt;/li&gt;\n&lt;li&gt;数字id排序，搜索，分页都比较有利&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;缺点也很明显：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;单机，挂了就要提桶跑路了&lt;/li&gt;\n&lt;li&gt;一台机器，高并发也不可能&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;集群的数据库\&#34;&gt;集群的数据库&lt;/h4&gt;\n&lt;p&gt;既然单机高并发和高可用搞不定，那就加机器，搞集群模式的数据库，既然集群模式，如果有多个master，那肯定不能每台机器自己生成自己的id，这样会导致重复的id。&lt;/p&gt;\n&lt;p&gt;这个时候，每台机器设置&lt;strong&gt;起始值&lt;/strong&gt;和&lt;strong&gt;步长&lt;/strong&gt;，就尤为重要。比如三台机器V1，V2，V3：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;统一步长：3\nV1起始值：1\nV2起始值：2\nV3起始值：3\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;生成的ID：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;V1：1, 4, 7, 10...\nV2：2, 5, 8, 11...\nV3：3, 6, 9, 12...\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;设置命令行可以使用：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;set @@auto_increment_offset = 1;     // 起始值\nset @@auto_increment_increment = 3;  // 步长\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这样确实在master足够多的情况下，高性能保证了，就算有的机器宕机了，slave 也可以补充上来，基于主从复制就可以，可以大大降低对单台机器的压力。但是这样做还是有缺点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;主从复制延迟了，master宕机了，从节点切换成为主节点之后，可能会重复发号。&lt;/li&gt;\n&lt;li&gt;起始值和步长设置好之后，要是后面需要增加机器（水平拓展），要调整很麻烦，很多时候可能需要停机更新&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;批量号段式数据库\&#34;&gt;批量号段式数据库&lt;/h4&gt;\n&lt;p&gt;上面的访问数据库太频繁了，并发量一上来，很多小概率问题都可能发生，那为什么我们不直接一次性拿出一段id呢？直接放在内存里，以供使用，用完了再申请一段就可以了。同样也可以保留集群模式的优点，每次从数据库取出一个范围的id，比如3台机器，发号：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;每次取1000，每台步长3000\nV1：1-1000,3001-4000,\nV2：1001-2000,4001-5000\nV3：2001-3000,5001-6000\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当然，如果不搞多台机器，也是可以的，一次申请10000个号码，用乐观锁实现，加一个版本号，&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;CREATE TABLE id_table (\n  id int(10) NOT NULL,\n  max_id bigint(20) NOT NULL COMMENT &#39;当前最大id&#39;,\n  step int(20) NOT NULL COMMENT &#39;号段的步长&#39;,\n  version int(20) NOT NULL COMMENT &#39;版本号&#39;,\n  `create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,\n  `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,\n  PRIMARY KEY (`id`)\n) \n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;只有用完的时候，才会重新去数据库申请，竞争的时候乐观锁保证只能一个请求成功，其他的直接等着别人取出来放在应用内存里面，再取就可以了，取的时候其实就是一个update操作：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-sql\&#34;&gt;update id_table set max_id = #{max_id+step}, version = version + 1 where version = # {version}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;重点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;批量获取，减少数据库请求&lt;/li&gt;\n&lt;li&gt;乐观锁，保证数据准确&lt;/li&gt;\n&lt;li&gt;获取只能从数据库中获取，批量获取可以做成异步定时任务，发现少于某个阈值，自动补充&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;redis自增\&#34;&gt;Redis自增&lt;/h3&gt;\n&lt;p&gt;redis有一个原子命令&lt;code&gt;incr&lt;/code&gt;,原子自增，redis速度快，基于内存：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;127.0.0.1:6379&amp;gt; set id 1\nOK\n127.0.0.1:6379&amp;gt; incr id      \n(integer) 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;当然，redis 如果单机有问题，也可以上集群，同样可以用初始值 + 步长，可以用 &lt;code&gt;INCRBY&lt;/code&gt; 命令，搞几台机器基本能抗住高并发。&lt;/p&gt;\n&lt;p&gt;优点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;基于内存，速度快&lt;/li&gt;\n&lt;li&gt;天然排序，自增，有利于排序搜索&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;缺点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;步长确定之后，增加机器也比较难调整&lt;/li&gt;\n&lt;li&gt;需要关注持久化，可用性等，增加系统复杂度&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;redis持久化如果是RDB，一段时间打一个快照，那么可能会有数据没来得及被持久化到磁盘，就挂掉了，重启可能会出现重复的ID，同时要是主从延迟，主节点挂掉了，主从切换，也可能出现重复的ID。如果使用AOF，一条命令持久化一次，可能会拖慢速度，一秒钟持久化一次，那么就可能最多丢失一秒钟的数据，同时，数据恢复也会比较慢，这是一个取舍的过程。&lt;/p&gt;\n&lt;h3 id=\&#34;zookeeper生成唯一id\&#34;&gt;Zookeeper生成唯一ID&lt;/h3&gt;\n&lt;p&gt;zookeeper其实是可以用来生成唯一ID的，但是大家不用，因为性能不高。znode有数据版本，可以生成32或者64位的序列号，这个序列号是唯一的，但是如果竞争比较大，还需要加分布式锁，不值得，效率低。&lt;/p&gt;\n&lt;h3 id=\&#34;美团的leaf\&#34;&gt;美团的Leaf&lt;/h3&gt;\n&lt;p&gt;下面均来自美团的官方文档：https://tech.meituan.com/2019/03/07/open-source-project-leaf.html&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;Leaf在设计之初就秉承着几点要求：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;全局唯一，绝对不会出现重复的ID，且ID整体趋势递增。&lt;/li&gt;\n&lt;li&gt;高可用，服务完全基于分布式架构，即使MySQL宕机，也能容忍一段时间的数据库不可用。&lt;/li&gt;\n&lt;li&gt;高并发低延时，在CentOS 4C8G的虚拟机上，远程调用QPS可达5W+，TP99在1ms内。&lt;/li&gt;\n&lt;li&gt;接入简单，直接通过公司RPC服务或者HTTP调用即可接入。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;文档里面讲得很清晰，一共有两个版本：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;V1：预分发的方式提供ID，也就是前面说的号段式分发，表设计也差不多，意思就是批量的拉取id&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20211012002835752.png\&#34; alt=\&#34;image-20211012002835752\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;这样做的缺点就是更新号段的时候，耗时比较高，还有就是如果这时候宕机或者主从复制，就不可用。&lt;/p&gt;\n&lt;p&gt;优化：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;1.先做了一个双Buffer优化，就是异步更新，意思就是搞两个号段出来，一个号段比如被消耗10%的时候，就开始分配下一个号段，有种提前分配的意思，而且异步线程更新&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;2.上面的方案，号段可能固定，跨度可能太大或者太小，那就做成动态变化，根据流量来决定下一次的号段的大小，动态调整&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;V2：Leaf-snowflake，Leaf提供了Java版本的实现，同时对Zookeeper生成机器号做了弱依赖处理，即使Zookeeper有问题，也不会影响服务。Leaf在第一次从Zookeeper拿取workerID后，会在本机文件系统上缓存一个workerID文件。即使ZooKeeper出现问题，同时恰好机器也在重启，也能保证服务的正常运行。这样做到了对第三方组件的弱依赖，一定程度上提高了SLA。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;snowflake雪花算法\&#34;&gt;snowflake(雪花算法）&lt;/h3&gt;\n&lt;p&gt;snowflake 是 twitter 公司内部分布式项目采用的 ID 生成算法,开源后广受欢迎，它生成的ID是 &lt;code&gt;Long&lt;/code&gt; 类型，8个字节，一共64位，从左到右：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;1位：不使用，二进制中最高位是为1都是负数，但是要生成的唯一ID都是正整数，所以这个1位固定为0。&lt;/li&gt;\n&lt;li&gt;41位：记录时间戳(毫秒)，这个位数可以用 &lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mn&gt;41&lt;/mn&gt;&lt;/msup&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;/&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1000&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;60&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;60&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;24&lt;/mn&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mn&gt;365&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;69&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;(2^{41}-1) / (1000 * 60 * 60 * 24 * 365) = 69&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1.064108em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;span class=\&#34;msupsub\&#34;&gt;&lt;span class=\&#34;vlist-t\&#34;&gt;&lt;span class=\&#34;vlist-r\&#34;&gt;&lt;span class=\&#34;vlist\&#34; style=\&#34;height:0.8141079999999999em;\&#34;&gt;&lt;span style=\&#34;top:-3.063em;margin-right:0.05em;\&#34;&gt;&lt;span class=\&#34;pstrut\&#34; style=\&#34;height:2.7em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;sizing reset-size6 size3 mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;4&lt;/span&gt;&lt;span class=\&#34;mord mtight\&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;−&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;/&lt;/span&gt;&lt;span class=\&#34;mopen\&#34;&gt;(&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;1&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;6&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;6&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;0&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;2&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;4&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;∗&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:1em;vertical-align:-0.25em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;3&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;6&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;5&lt;/span&gt;&lt;span class=\&#34;mclose\&#34;&gt;)&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.64444em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;6&lt;/span&gt;&lt;span class=\&#34;mord\&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;年&lt;/li&gt;\n&lt;li&gt;10位：记录工作机器的ID，可以机器ID，也可以机房ID + 机器ID&lt;/li&gt;\n&lt;li&gt;12位：序列号，就是某个机房某台机器上这一毫秒内同时生成的 id 序号&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;那么每台机器按照上面的逻辑去生成ID，就会是趋势递增的，因为时间在递增，而且不需要搞个分布式的，简单很多。&lt;/p&gt;\n&lt;p&gt;可以看出 snowflake 是强依赖于时间的，因为时间理论上是不断往前的，所以这一部分的位数，也是趋势递增的。但是有一个问题，是时间回拨，也就是时间突然间倒退了，可能是故障，也可能是重启之后时间获取出问题了。那我们该如何解决时间回拨问题呢？&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;第一种方案：获取时间的时候判断，如果小于上一次的时间戳，那么就不要分配，继续循环获取时间，直到时间符合条件。&lt;/li&gt;\n&lt;li&gt;第二种方案：上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么超过一定大小的回拨直接报错，拒绝服务，或者有一种方案是利用拓展位，回拨之后在拓展位上加1就可以了，这样ID依然可以保持唯一。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;Java代码实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class SnowFlake {\n\n    // 数据中心(机房) id\n    private long datacenterId;\n    // 机器ID\n    private long workerId;\n    // 同一时间的序列\n    private long sequence;\n\n    public SnowFlake(long workerId, long datacenterId) {\n        this(workerId, datacenterId, 0);\n    }\n\n    public SnowFlake(long workerId, long datacenterId, long sequence) {\n        // 合法判断\n        if (workerId &amp;gt; maxWorkerId || workerId &amp;lt; 0) {\n            throw new IllegalArgumentException(String.format(&amp;quot;worker Id can&#39;t be greater than %d or less than 0&amp;quot;, maxWorkerId));\n        }\n        if (datacenterId &amp;gt; maxDatacenterId || datacenterId &amp;lt; 0) {\n            throw new IllegalArgumentException(String.format(&amp;quot;datacenter Id can&#39;t be greater than %d or less than 0&amp;quot;, maxDatacenterId));\n        }\n        System.out.printf(&amp;quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&amp;quot;,\n                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);\n\n        this.workerId = workerId;\n        this.datacenterId = datacenterId;\n        this.sequence = sequence;\n    }\n\n    // 开始时间戳\n    private long twepoch = 1420041600000L;\n\n    // 机房号，的ID所占的位数 5个bit 最大:11111(2进制)--&amp;gt; 31(10进制)\n    private long datacenterIdBits = 5L;\n\n    // 机器ID所占的位数 5个bit 最大:11111(2进制)--&amp;gt; 31(10进制)\n    private long workerIdBits = 5L;\n\n    // 5 bit最多只能有31个数字，就是说机器id最多只能是32以内\n    private long maxWorkerId = -1L ^ (-1L &amp;lt;&amp;lt; workerIdBits);\n\n    // 5 bit最多只能有31个数字，机房id最多只能是32以内\n    private long maxDatacenterId = -1L ^ (-1L &amp;lt;&amp;lt; datacenterIdBits);\n\n    // 同一时间的序列所占的位数 12个bit 111111111111 = 4095  最多就是同一毫秒生成4096个\n    private long sequenceBits = 12L;\n\n    // workerId的偏移量\n    private long workerIdShift = sequenceBits;\n\n    // datacenterId的偏移量\n    private long datacenterIdShift = sequenceBits + workerIdBits;\n\n    // timestampLeft的偏移量\n    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;\n\n    // 序列号掩码 4095 (0b111111111111=0xfff=4095)\n    // 用于序号的与运算，保证序号最大值在0-4095之间\n    private long sequenceMask = -1L ^ (-1L &amp;lt;&amp;lt; sequenceBits);\n\n    // 最近一次时间戳\n    private long lastTimestamp = -1L;\n\n\n    // 获取机器ID\n    public long getWorkerId() {\n        return workerId;\n    }\n\n\n    // 获取机房ID\n    public long getDatacenterId() {\n        return datacenterId;\n    }\n\n\n    // 获取最新一次获取的时间戳\n    public long getLastTimestamp() {\n        return lastTimestamp;\n    }\n\n\n    // 获取下一个随机的ID\n    public synchronized long nextId() {\n        // 获取当前时间戳，单位毫秒\n        long timestamp = timeGen();\n\n        if (timestamp &amp;lt; lastTimestamp) {\n            System.err.printf(&amp;quot;clock is moving backwards.  Rejecting requests until %d.&amp;quot;, lastTimestamp);\n            throw new RuntimeException(String.format(&amp;quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&amp;quot;,\n                    lastTimestamp - timestamp));\n        }\n\n        // 去重\n        if (lastTimestamp == timestamp) {\n\n            sequence = (sequence + 1) &amp;amp; sequenceMask;\n\n            // sequence序列大于4095\n            if (sequence == 0) {\n                // 调用到下一个时间戳的方法\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {\n            // 如果是当前时间的第一次获取，那么就置为0\n            sequence = 0;\n        }\n\n        // 记录上一次的时间戳\n        lastTimestamp = timestamp;\n\n        // 偏移计算\n        return ((timestamp - twepoch) &amp;lt;&amp;lt; timestampLeftShift) |\n                (datacenterId &amp;lt;&amp;lt; datacenterIdShift) |\n                (workerId &amp;lt;&amp;lt; workerIdShift) |\n                sequence;\n    }\n\n    private long tilNextMillis(long lastTimestamp) {\n        // 获取最新时间戳\n        long timestamp = timeGen();\n        // 如果发现最新的时间戳小于或者等于序列号已经超4095的那个时间戳\n        while (timestamp &amp;lt;= lastTimestamp) {\n            // 不符合则继续\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    public static void main(String[] args) {\n        SnowFlake worker = new SnowFlake(1, 1);\n        long timer = System.currentTimeMillis();\n        for (int i = 0; i &amp;lt; 100; i++) {\n            worker.nextId();\n        }\n        System.out.println(System.currentTimeMillis());\n        System.out.println(System.currentTimeMillis() - timer);\n    }\n\n}\n  \n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;百度-uid-generator\&#34;&gt;百度 uid-generator&lt;/h3&gt;\n&lt;p&gt;换汤不换药，百度开发的，基于&lt;code&gt;Snowflake&lt;/code&gt;算法，不同的地方是可以自己定义每部分的位数,也做了不少优化和拓展：https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;UidGenerator是Java实现的, 基于&lt;a href=\&#34;https://github.com/twitter/snowflake\&#34;&gt;Snowflake&lt;/a&gt;算法的唯一ID生成器。UidGenerator以组件形式工作在应用项目中, 支持自定义workerId位数和初始化策略, 从而适用于&lt;a href=\&#34;https://www.docker.com/\&#34;&gt;docker&lt;/a&gt;等虚拟化环境下实例自动重启、漂移等场景。 在实现上, UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;秦怀の观点\&#34;&gt;秦怀の观点&lt;/h2&gt;\n&lt;p&gt;不管哪一种uid生成器，保证唯一性是核心，在这个核心上才能去考虑其他的性能，或者高可用等问题，总体的方案分为两种：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;中心化：第三方的一个中心，比如 Mysql，Redis，Zookeeper\n&lt;ul&gt;\n&lt;li&gt;优点：趋势自增&lt;/li&gt;\n&lt;li&gt;缺点：增加复杂度，一般得集群，提前约定步长之类&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;无中心化：直接本地机器上生成，snowflake，uuid\n&lt;ul&gt;\n&lt;li&gt;优点：简单，高效，没有性能瓶颈&lt;/li&gt;\n&lt;li&gt;缺点：数据比较长，自增属性较弱&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;没有哪一种是完美的，只有符合业务以及当前体量的方案，技术方案里面，没有最优解。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;fen-bu-shi-xi-tong-wei-yi-id-zen-me-sheng-cheng&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n分布式系统全局唯一的 id 是所有系统都会遇到的场景，往往会被用在搜索，存储方面，用于作为唯一的标识或者排序，比如全局唯一的订单号，优惠券的券码等，如果出现两个相同的订单号，对于用户无疑将是一个巨大的bug。&#34;,&#34;title&#34;:&#34;分布式系统唯一id怎么生成&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;分布式&#34;,&#34;slug&#34;:&#34;F4e4OmSkx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/F4e4OmSkx/&#34;}],&#34;date&#34;:&#34;2023-03-02 00:16:12&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/fen-bu-shi-xi-tong-wei-yi-id-zen-me-sheng-cheng/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;17 min read&#34;,&#34;time&#34;:1014000,&#34;words&#34;:4379,&#34;minutes&#34;:17},&#34;description&#34;:&#34;\n分布式系统全局唯一的 id 是所有系统都会遇到的场景，往往会被用在搜索，存储方面，用于作为唯一的标识或者排序，比如全局唯一的订单号，优惠券的券码等，如果出现两个相同的订单号，对于用户无疑将是一个巨大的bug。\n\n分布式唯一ID介绍\n在单体...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80id%E4%BB%8B%E7%BB%8D\&#34;&gt;分布式唯一ID介绍&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80id%E7%9A%84%E7%89%B9%E5%BE%81\&#34;&gt;分布式唯一ID的特征&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80id%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88\&#34;&gt;分布式唯一ID的生成方案&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#uuid%E7%9B%B4%E6%8E%A5%E7%94%9F%E6%88%90\&#34;&gt;UUID直接生成&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%88%97\&#34;&gt;数据库自增序列&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%95%E6%9C%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93\&#34;&gt;单机的数据库&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9B%86%E7%BE%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93\&#34;&gt;集群的数据库&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%89%B9%E9%87%8F%E5%8F%B7%E6%AE%B5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93\&#34;&gt;批量号段式数据库&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#redis%E8%87%AA%E5%A2%9E\&#34;&gt;Redis自增&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#zookeeper%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80id\&#34;&gt;Zookeeper生成唯一ID&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BE%8E%E5%9B%A2%E7%9A%84leaf\&#34;&gt;美团的Leaf&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#snowflake%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95\&#34;&gt;snowflake(雪花算法）&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%99%BE%E5%BA%A6-uid-generator\&#34;&gt;百度 uid-generator&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A7%A6%E6%80%80%E3%81%AE%E8%A7%82%E7%82%B9\&#34;&gt;秦怀の观点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n# 线程池\n&lt;p&gt;&lt;strong&gt;本文关键字：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;线程&lt;/code&gt;，&lt;code&gt;线程池&lt;/code&gt;，&lt;code&gt;单线程&lt;/code&gt;，&lt;code&gt;多线程&lt;/code&gt;，&lt;code&gt;线程池的好处&lt;/code&gt;，&lt;code&gt;线程回收&lt;/code&gt;，&lt;code&gt;创建方式&lt;/code&gt;，&lt;code&gt;核心参数&lt;/code&gt;，&lt;code&gt;底层机制&lt;/code&gt;，&lt;code&gt;拒绝策略&lt;/code&gt;,&lt;code&gt;参数设置&lt;/code&gt;,&lt;code&gt;动态监控&lt;/code&gt;，&lt;code&gt;线程隔离&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;线程和线程池相关的知识，是Java学习或者面试中一定会遇到的知识点，本篇我们会从线程和进程，并行与并发，单线程和多线程等，一直讲解到线程池，线程池的好处，创建方式，重要的核心参数，几个重要的方法，底层实现，拒绝策略，参数设置，动态调整，线程隔离等等。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;主要的大纲如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.svg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;线程池的好处\&#34;&gt;线程池的好处&lt;/h2&gt;\n&lt;p&gt;线程池，使用了池化思想来管理线程，池化技术就是为了最大化效益，最小化用户风险，将资源统一放在一起管理的思想。这种思想在很多地方都有使用到，不仅仅是计算机，比如金融，企业管理，设备管理等。&lt;/p&gt;\n&lt;p&gt;为什么要线程池？如果在并发的场景，编码人员根据需求来创建线程池，可能会有以下的问题：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;我们很难确定系统有多少线程在运行，如果使用就创建，不使用就销毁，那么创建和销毁线程的消耗也是比较大的&lt;/li&gt;\n&lt;li&gt;假设来了很多请求，可能是爬虫，疯狂创建线程，可能把系统资源耗尽。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;实现线程池有什么好处呢？&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;降低资源消耗：池化技术可以重复利用已经创建的线程，降低线程创建和销毁的损耗。&lt;/li&gt;\n&lt;li&gt;提高响应速度：利用已经存在的线程进行处理，少去了创建线程的时间&lt;/li&gt;\n&lt;li&gt;管理线程可控：线程是稀缺资源，不能无限创建，线程池可以做到统一分配和监控&lt;/li&gt;\n&lt;li&gt;拓展其他功能：比如定时线程池，可以定时执行任务&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;其实池化技术，用在比较多地方，比如：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;数据库连接池：数据库连接是稀缺资源，先创建好，提高响应速度，重复利用已有的连接&lt;/li&gt;\n&lt;li&gt;实例池：先创建好对象放到池子里面，循环利用，减少来回创建和销毁的消耗&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;线程池相关的类\&#34;&gt;线程池相关的类&lt;/h2&gt;\n&lt;p&gt;下面是与线程池相关的类的继承关系：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619135200.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;executor\&#34;&gt;Executor&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;Executor&lt;/code&gt; 是顶级接口，里面只有一个方法&lt;code&gt;execute(Runnable command)&lt;/code&gt;，定义的是调度线程池来执行任务，它定义了线程池的基本规范，执行任务是它的天职。&lt;/p&gt;\n&lt;h3 id=\&#34;executorservice\&#34;&gt;ExecutorService&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;ExecutorService&lt;/code&gt; 继承了&lt;code&gt;Executor&lt;/code&gt;，但是它仍然是一个接口，它多了一些方法：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619135250.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;void shutdown()&lt;/code&gt;:关闭线程池，会等待任务执行完。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;List&amp;lt;Runnable&amp;gt; shutdownNow()&lt;/code&gt;:立刻关闭线程池，尝试停止所有正在积极执行的任务，停止等待任务的处理，并&lt;strong&gt;返回一个正在等待执行的任务列表（还没有执行的）&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;boolean isShutdown()&lt;/code&gt;:判断线程池是不是已经关闭，但是可能线程还在执行。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;boolean isTerminated()&lt;/code&gt;:在执行shutdown/shutdownNow之后，所有的任务已经完成，这个状态就是true。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;boolean awaitTermination(long timeout, TimeUnit unit)&lt;/code&gt;:执行shutdown之后，阻塞等到terminated状态，除非超时或者被打断。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task)&lt;/code&gt;: 提交一个有返回值的任务，并且返回该任务尚未有结果的Future，调用future.get()方法，可以返回任务完成的时候的结果。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result)&lt;/code&gt;:提交一个任务，传入返回结果，这个result没有什么作用，只是指定类型和一个返回的结果。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Future&amp;lt;?&amp;gt; submit(Runnable task)&lt;/code&gt;: 提交任务，返回Future&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)&lt;/code&gt;:批量执行tasks，获取Future的list，可以批量提交任务。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,long timeout, TimeUnit unit)&lt;/code&gt;:批量提交任务，并指定超时时间&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks)&lt;/code&gt;: 阻塞，获取第一个完成任务的结果值，&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;&amp;lt;T&amp;gt; T invokeAny(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks,long timeout, TimeUnit unit)&lt;/code&gt;:阻塞，获取第一个完成结果的值，指定超时时间&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;可能有同学对前面的&lt;code&gt;&amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result)&lt;/code&gt;有疑问，这个reuslt有什么作用？&lt;/p&gt;\n&lt;p&gt;其实它没有什么作用，只是持有它，任务完成后，还是调用 &lt;code&gt;future.get（）&lt;/code&gt;返回这个结果，用&lt;code&gt;result&lt;/code&gt; new 了一个 &lt;code&gt;ftask&lt;/code&gt;，其内部其实是使用了Runnable的包装类 &lt;code&gt;RunnableAdapter&lt;/code&gt;,没有对result做特殊的处理，调用 &lt;code&gt;call()&lt;/code&gt; 方法的时候，直接返回这个结果。（Executors 中具体的实现）&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) {\n        if (task == null) throw new NullPointerException();\n        RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);\n        execute(ftask);\n        return ftask;\n    }\n\n    static final class RunnableAdapter&amp;lt;T&amp;gt; implements Callable&amp;lt;T&amp;gt; {\n        final Runnable task;\n        final T result;\n        RunnableAdapter(Runnable task, T result) {\n            this.task = task;\n            this.result = result;\n        }\n        public T call() {\n            task.run();\n            // 返回传入的结果\n            return result;\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;还有一个方法值得一提：&lt;code&gt;invokeAny()&lt;/code&gt;: 在 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;中使用&lt;code&gt;ExecutorService&lt;/code&gt; 中的方法 &lt;code&gt;invokeAny()&lt;/code&gt; 取得第一个完成的任务的结果，当第一个任务执行完成后，会调用 &lt;code&gt;interrupt()&lt;/code&gt; 方法将其他任务中断。&lt;/p&gt;\n&lt;p&gt;注意，&lt;code&gt;ExecutorService&lt;/code&gt;是接口，里面都是定义，并没有涉及实现，而前面的讲解都是基于它的名字（规定的规范）以及它的普遍实现来说的。&lt;/p&gt;\n&lt;p&gt;可以看到 &lt;code&gt;ExecutorService&lt;/code&gt; 定义的是线程池的一些操作，包括关闭，判断是否关闭，是否停止，提交任务，批量提交任务等等。&lt;/p&gt;\n&lt;h3 id=\&#34;abstractexecutorservice\&#34;&gt;AbstractExecutorService&lt;/h3&gt;\n&lt;p&gt;&lt;code&gt;AbstractExecutorService&lt;/code&gt; 是一个抽象类，实现了 &lt;code&gt;ExecutorService&lt;/code&gt;接口，这是大部分线程池的基本实现，定时的线程池先不关注，主要的方法如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619163946.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;不仅实现了&lt;code&gt;submit&lt;/code&gt;，&lt;code&gt;invokeAll&lt;/code&gt;，&lt;code&gt;invokeAny&lt;/code&gt; 等方法，而且提供了一个 &lt;code&gt;newTaskFor&lt;/code&gt; 方法用于构建 &lt;code&gt;RunnableFuture&lt;/code&gt; 对象，那些能够获取到任务返回结果的对象都是通过 &lt;code&gt;newTaskFor&lt;/code&gt; 来获取的。不展开里面所有的源码的介绍，仅以submit()方法为例：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public Future&amp;lt;?&amp;gt; submit(Runnable task) {\n        if (task == null) throw new NullPointerException();\n        // 封装任务\n        RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);\n        // 执行任务\n        execute(ftask);\n        // 返回 RunnableFuture 对象\n        return ftask;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是在 &lt;code&gt;AbstractExecutorService&lt;/code&gt; 是没有对最最重要的方法进行实现的，也就是 &lt;code&gt;execute()&lt;/code&gt; 方法。线程池具体是怎么执行的，这个不同的线程池可以有不同的实现，一般都是继承 &lt;code&gt;AbstractExecutorService&lt;/code&gt; (定时任务有其他的接口)，我们最最常用的就是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619165858.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;threadpoolexecutor\&#34;&gt;ThreadPoolExecutor&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;重点来了!!!&lt;/strong&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 一般就是我们平时常用到的线程池类，所谓创建线程池，如果不是定时线程池，就是使用它。&lt;/p&gt;\n&lt;p&gt;先看&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的内部结构(属性)：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class ThreadPoolExecutor extends AbstractExecutorService {\n    // 状态控制，主要用来控制线程池的状态，是核心的遍历，使用的是原子类\n    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n  \t// 用来表示线程数量的位数（使用的是位运算，一部分表示线程的数量，一部分表示线程池的状态）\n    // SIZE = 32 表示32位，那么COUNT_BITS就是29位\n    private static final int COUNT_BITS = Integer.SIZE - 3;\n  \t// 线程池的容量，也就是27位表示的最大值\n    private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;\n\n    // 状态量，存储在高位，32位中的前3位\n  \t// 111（第一位是符号位，1表示负数），线程池运行中\n    private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS; \n  \t// 000\n    private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;\n  \t// 001\n    private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;\n  \t// 010\n    private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;\n  \t// 011\n    private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;\n\n    // 取出运行状态\n    private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }\n  \t// 取出线程数量\n    private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }\n  \t// 用运行状态和线程数获取ctl\n    private static int ctlOf(int rs, int wc) { return rs | wc; }\n  \t\n  \t// 任务等待队列\n    private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;\n  \t// 可重入主锁（保证一些操作的线程安全）\n    private final ReentrantLock mainLock = new ReentrantLock();\n  \t// 线程的集合\n    private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();\n  \n  \t// 在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，\n    // 传统线程的通信方式，Condition都可以实现，Condition和传统的线程通信没什么区别，Condition的强大之处在于它可以为多个线程间建立不同的Condition\n    private final Condition termination = mainLock.newCondition();\n  \n  \t// 最大线程池大小\n    private int largestPoolSize;\n  \t// 完成的任务数量\n    private long completedTaskCount;\n  \t// 线程工厂\n    private volatile ThreadFactory threadFactory;\n  \t// 任务拒绝处理器\n    private volatile RejectedExecutionHandler handler;\n \t\t// 非核心线程的存活时间\n    private volatile long keepAliveTime;\n  \t// 允许核心线程的超时时间\n    private volatile boolean allowCoreThreadTimeOut;\n \t\t// 核心线程数\n    private volatile int corePoolSize;\n\t\t// 工作线程最大容量\n    private volatile int maximumPoolSize;\n \t\t// 默认的拒绝处理器（丢弃任务）\n  \tprivate static final RejectedExecutionHandler defaultHandler =\n        new AbortPolicy();\n  \t// 运行时关闭许可\n    private static final RuntimePermission shutdownPerm =\n        new RuntimePermission(&amp;quot;modifyThread&amp;quot;);\n  \t// 上下文\n    private final AccessControlContext acc;\n  \t// 只有一个线程\n    private static final boolean ONLY_ONE = true;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;线程池状态\&#34;&gt;线程池状态&lt;/h4&gt;\n&lt;p&gt;从上面的代码可以看出，用一个32位的对象保存线程池的状态以及线程池的容量，高3位是线程池的状态，而剩下的29位，则是保存线程的数量：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    // 状态量，存储在高位，32位中的前3位\n  \t// 111（第一位是符号位，1表示负数），线程池运行中\n    private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS; \n  \t// 000\n    private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;\n  \t// 001\n    private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;\n  \t// 010\n    private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;\n  \t// 011\n    private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;各种状态之间是不一样的，他们的状态之间变化如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619211431.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;RUNNING：运行状态，可以接受任务，也可以处理任务&lt;/li&gt;\n&lt;li&gt;SHUTDOWN：不可以接受任务，但是可以处理任务&lt;/li&gt;\n&lt;li&gt;STOP：不可以接受任务，也不可以处理任务，中断当前任务&lt;/li&gt;\n&lt;li&gt;TIDYING：所有线程停止&lt;/li&gt;\n&lt;li&gt;TERMINATED：线程池的最后状态&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;worker-实现\&#34;&gt;Worker 实现&lt;/h4&gt;\n&lt;p&gt;线程池，肯定得有池子，并且是放线程的地方，在 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 中表现为 &lt;code&gt;Worker&lt;/code&gt;，这是内部类：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619170610.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;线程池其实就是 &lt;code&gt;Worker&lt;/code&gt; (打工人，不断的领取任务，完成任务)的集合，这里使用的是 &lt;code&gt;HashSet&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;Worker&lt;/code&gt; 怎么实现的呢？&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;Worker&lt;/code&gt; 除了继承了 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;,也就是 &lt;code&gt;AQS&lt;/code&gt; ， &lt;code&gt;AQS&lt;/code&gt; 本质上就是个队列锁，一个简单的互斥锁，一般是在中断或者修改 &lt;code&gt;worker&lt;/code&gt; 状态的时候使用。&lt;/p&gt;\n&lt;p&gt;内部引入&lt;code&gt;AQS&lt;/code&gt;，是为了线程安全，线程执行任务的时候，调用的是&lt;code&gt;runWorker(Worker w)&lt;/code&gt;，这个方法不是worker的方法，而是 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的方法。从下面的代码可以看出，每次修改&lt;code&gt;Worke&lt;/code&gt;r的状态的时候，都是线程安全的。&lt;code&gt;Worker&lt;/code&gt;里面，持有了一个线程&lt;code&gt;Thread&lt;/code&gt;,可以理解为是对线程的封装。&lt;/p&gt;\n&lt;p&gt;至于&lt;code&gt;runWorker(Worker w)&lt;/code&gt;是怎么运行的？先保持这个疑问，后面详细讲解。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    // 实现 Runnable，封装了线程\n    private final class Worker\n        extends AbstractQueuedSynchronizer\n        implements Runnable\n    {\n        // 序列化id\n        private static final long serialVersionUID = 6138294804551838833L;\n\n        // worker运行的线程\n        final Thread thread;\n        \n        // 初始化任务，有可能是空的，如果任务不为空的时候，其他进来的任务，可以直接运行，不在添加到任务队列\n        Runnable firstTask;\n        // 线程任务计数器\n        volatile long completedTasks;\n\n        // 指定一个任务让工人忙碌起来，这个任务可能是空的\n        Worker(Runnable firstTask) {\n          \t// 初始化AQS队列锁的状态\n            setState(-1); // 禁止中断直到 runWorker\n            this.firstTask = firstTask;\n            // 从线程工厂，取出一个线程初始化\n            this.thread = getThreadFactory().newThread(this);\n        }\n\n        // 实际上运行调用的是runWorker\n        public void run() {\n          \t// 不断循环获取任务进行执行\n            runWorker(this);\n        }\n\n        // 0表示没有被锁\n        // 1表示被锁的状态\n        protected boolean isHeldExclusively() {\n            return getState() != 0;\n        }\n        // 独占，尝试获取锁，如果成功返回true，失败返回false\n        protected boolean tryAcquire(int unused) {\n            // CAS 乐观锁\n            if (compareAndSetState(0, 1)) {\n                // 成功，当前线程独占锁\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n        // 独占方式，尝试释放锁\n        protected boolean tryRelease(int unused) {\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n        // 上锁，调用的是AQS的方法\n        public void lock()        { acquire(1); }\n        // 尝试上锁\n        public boolean tryLock()  { return tryAcquire(1); }\n        // 解锁\n        public void unlock()      { release(1); }\n        // 是否锁住\n        public boolean isLocked() { return isHeldExclusively(); }\n\n        // 如果开始可就中断\n        void interruptIfStarted() {\n            Thread t;\n            if (getState() &amp;gt;= 0 &amp;amp;&amp;amp; (t = thread) != null &amp;amp;&amp;amp; !t.isInterrupted()) {\n                try {\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                }\n            }\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;任务队列\&#34;&gt;任务队列&lt;/h4&gt;\n&lt;p&gt;除了放线程池的地方，要是任务很多，没有那么多线程，肯定需要一个地方放任务，充当缓冲作用，也就是任务队列，在代码中表现为：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;拒绝策略和处理器\&#34;&gt;拒绝策略和处理器&lt;/h4&gt;\n&lt;p&gt;计算机的内存总是有限的，我们不可能一直往队列里面增加内容，所以线程池为我们提供了选择，可以选择多种队列。同时当任务实在太多，占满了线程，并且把任务队列也占满的时候，我们需要做出一定的反应，那就是拒绝还是抛出错误，丢掉任务？丢掉哪些任务，这些都是可能需要定制的内容。&lt;/p&gt;\n&lt;h2 id=\&#34;如何创建线程池\&#34;&gt;如何创建线程池&lt;/h2&gt;\n&lt;p&gt;关于如何创建线程池，其实 &lt;code&gt;ThreadPoolExecutor&lt;/code&gt;提供了构造方法，主要参数如下，不传的话会使用默认的：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;核心线程数：核心线程数，一般是指常驻的线程，没有任务的时候通常也不会销毁&lt;/li&gt;\n&lt;li&gt;最大线程数：线程池允许创建的最大的线程数量&lt;/li&gt;\n&lt;li&gt;非核心线程的存活时间：指的是没有任务的时候，非核心线程能够存活多久&lt;/li&gt;\n&lt;li&gt;时间的单位：存活时间的单位&lt;/li&gt;\n&lt;li&gt;存放任务的队列：用来存放任务&lt;/li&gt;\n&lt;li&gt;线程工厂&lt;/li&gt;\n&lt;li&gt;拒绝处理器:如果添加任务失败，将由该处理器处理&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t// 指定核心线程数，最大线程数，非核心线程没有任务的存活时间，时间单位，任务队列    \n\tpublic ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), defaultHandler);\n    }\n\t  // 指定核心线程数，最大线程数，非核心线程没有任务的存活时间，时间单位，任务队列，线程池工厂    \n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,\n                              ThreadFactory threadFactory) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             threadFactory, defaultHandler);\n    }\n\t  // 指定核心线程数，最大线程数，非核心线程没有任务的存活时间，时间单位，任务队列，拒绝任务处理器\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,\n                              RejectedExecutionHandler handler) {\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), handler);\n    }\n\t\t// 最后其实都是调用了这个方法\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) {\n      ...\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其实，除了显示的指定上面的参数之外，JDK也封装了一些直接创建线程池的方法给我们，那就是&lt;code&gt;Executors&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;\t\t// 固定线程数量的线程池，无界的队列\n\t\tpublic static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());\n    }\n\t\t// 单个线程的线程池，无界的队列，按照任务提交的顺序，串行执行    \n\t\tpublic static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),\n                                    threadFactory));\n    }\n\t\t// 动态调节，没有核心线程，全部都是普通线程，每个线程存活60s，使用容量为1的阻塞队列\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;());\n    }\n\t  // 定时任务线程池\n    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {\n        return new DelegatedScheduledExecutorService\n            (new ScheduledThreadPoolExecutor(1));\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;但是一般是不推荐使用上面别人封装的线程池的哈！！！&lt;/p&gt;\n&lt;h2 id=\&#34;线程池的底层参数以及核心方法\&#34;&gt;线程池的底层参数以及核心方法&lt;/h2&gt;\n&lt;p&gt;看完上面的创建参数大家可能会有点懵，但是没关系，一一为大家道来：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;8\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619215638.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看出，当有任务进来的时候，先判断核心线程池是不是已经满了，如果还没有，将会继续创建线程。注意，如果一个任务进来，创建线程执行，执行完成，线程空闲下来，这时候再来一个任务，是会继续使用之前的线程，还是重新创建一个线程来执行呢？&lt;/p&gt;\n&lt;p&gt;答案是重新创建线程，这样线程池可以快速达到核心线程数的规模大小，以便快速响应后面的任务。&lt;/p&gt;\n&lt;p&gt;如果线程数量已经到达核心线程数，来了任务，线程池的线程又都不是空闲状态，那么就会判断队列是不是满的，倘若队列还有空间，那么就会把任务放进去队列中，等待线程领取执行。&lt;/p&gt;\n&lt;p&gt;如果任务队列已经满了，放不下任务，那么就会判断线程数是不是已经到最大线程数了，要是还没有到达，就会继续创建线程并执行任务，这个时候创建的是非核心部分线程。&lt;/p&gt;\n&lt;p&gt;如果已经到达最大线程数，那么就不能继续创建线程了，只能执行拒绝策略，默认的拒绝策略是丢弃任务，我们可以自定义拒绝策略。&lt;/p&gt;\n&lt;p&gt;值得注意的是，倘若之前任务比较多，创建出了一些非核心线程，那么任务少了之后，领取不到任务，过了一定时间，非核心线程就会销毁，只剩下核心线程池的数量的线程。这个时间就是前面说的&lt;code&gt;keepAliveTime&lt;/code&gt;。&lt;/p&gt;\n&lt;h3 id=\&#34;提交任务\&#34;&gt;提交任务&lt;/h3&gt;\n&lt;p&gt;提交任务，我们看&lt;code&gt;execute()&lt;/code&gt;，会先获取线程池的状态和个数，要是线程个数还没达到核心线程数，会直接添加线程，否则会放到任务队列，如果任务队列放不下，会继续增加线程，但是不是增加核心线程。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public void execute(Runnable command) {\n        if (command == null)\n            throw new NullPointerException();\n        // 获取状态和个数\n        int c = ctl.get();\n      \t// 如果个数小于核心线程数\n        if (workerCountOf(c) &amp;lt; corePoolSize) {\n          \t// 直接添加\n            if (addWorker(command, true))\n                return;\n          \t// 添加失败则继续获取\n            c = ctl.get();\n        }\n      \t// 判断线程池状态是不是运行中，任务放到队列中\n        if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {\n          \t// 再次检查\n            int recheck = ctl.get();\n          \t// 判断线程池是不是还在运行\n            if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))\n              \t// 如果不是，那么就拒绝并移除任务\n                reject(command);\n            else if (workerCountOf(recheck) == 0)\n              \t// 如果线程数为0，并且还在运行，那么就直接添加\n                addWorker(null, false);\n        }else if (!addWorker(command, false))\n          \t// 添加任务队列失败，拒绝\n            reject(command);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的源码中，调用了一个重要的方法：&lt;code&gt;addWorker(Runnable firstTask, boolean core)&lt;/code&gt;,该方法主要是为了增加工作的线程，我们来看看它是如何执行的：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    private boolean addWorker(Runnable firstTask, boolean core) {\n      \t// 回到当前位置重试\n        retry:\n        for (;;) {\n          \t// 获取状态\n            int c = ctl.get();\n            int rs = runStateOf(c);\n\n            // 大于SHUTDOWN说明线程池已经停止\n          \t// ! (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null &amp;amp;&amp;amp; ! workQueue.isEmpty()) 表示三个条件至少有一个不满足\n          \t// 不等于SHUTDOWN说明是大于shutdown\n          \t// firstTask ！= null 任务不是空的\n          \t// workQueue.isEmpty() 队列是空的\n            if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;\n                ! (rs == SHUTDOWN &amp;amp;&amp;amp;\n                   firstTask == null &amp;amp;&amp;amp;\n                   ! workQueue.isEmpty()))\n                return false;\n\n            for (;;) {\n                // 工作线程数\n                int wc = workerCountOf(c);\n              \t// 是否符合容量\n                if (wc &amp;gt;= CAPACITY ||\n                    wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))\n                    return false;\n              \t// 添加成功，跳出循环\n                if (compareAndIncrementWorkerCount(c))\n                    break retry;\n                c = ctl.get();  // Re-read ctl\n              \t// cas失败，重新尝试\n                if (runStateOf(c) != rs)\n                    continue retry;\n                // else CAS failed due to workerCount change; retry inner loop\n            }\n        }\n\n      \t// 前面线程计数增加成功\n        boolean workerStarted = false;\n        boolean workerAdded = false;\n        Worker w = null;\n        try {\n          \t// 创建了一个worker，包装了任务\n            w = new Worker(firstTask);\n            final Thread t = w.thread;\n          \t// 线程创建成功\n            if (t != null) {\n              \t// 获取锁\n                final ReentrantLock mainLock = this.mainLock;\n                mainLock.lock();\n                try {\n                    // 再次确认状态\n                    int rs = runStateOf(ctl.get());\n                    if (rs &amp;lt; SHUTDOWN ||\n                        (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {\n                      \t// 如果线程已经启动，失败\n                        if (t.isAlive()) // precheck that t is startable\n                            throw new IllegalThreadStateException();\n                      \t// 新增线程到集合\n                        workers.add(w);\n                      \t// 获取大小\n                        int s = workers.size();\n                      \t// 判断最大线程池数量\n                        if (s &amp;gt; largestPoolSize)\n                            largestPoolSize = s;\n                      \t// 已经添加工作线程\n                        workerAdded = true;\n                    }\n                } finally {\n                  \t// 解锁\n                    mainLock.unlock();\n                }\n              \t// 如果已经添加\n                if (workerAdded) {\n                  \t// 启动线程\n                    t.start();\n                    workerStarted = true;\n                }\n            }\n        } finally {\n          \t// 如果没有启动\n            if (! workerStarted)\n              \t// 失败处理\n                addWorkerFailed(w);\n        }\n        return workerStarted;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;处理任务\&#34;&gt;处理任务&lt;/h3&gt;\n&lt;p&gt;前面在介绍&lt;code&gt;Worker&lt;/code&gt;这个类的时候，我们讲解到其实它的&lt;code&gt;run()&lt;/code&gt;方法调用的是外部的&lt;code&gt;runWorker()&lt;/code&gt;方法，那么我们来看看&lt;code&gt;runWorkder()&lt;/code&gt;方法：&lt;/p&gt;\n&lt;p&gt;首先，它会直接处理自己的firstTask,这个任务并没有在任务队列里面，而是它自己持有的：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;final void runWorker(Worker w) {\n  \t\t\t// 当前线程\n        Thread wt = Thread.currentThread();\n  \t\t\t// 第一个任务\n        Runnable task = w.firstTask;\n  \t\t\t// 重置为null\n        w.firstTask = null;\n  \t\t\t// 允许打断\n        w.unlock();\n        boolean completedAbruptly = true;\n        try {\n           // 任务不为空，或者获取的任务不为空\n            while (task != null || (task = getTask()) != null) {\n              \t// 加锁\n                w.lock();\n\t\t\t\t\t\t\t\t//如果线程池停止，确保线程被中断;\n\t\t\t\t\t\t\t\t//如果不是，确保线程没有被中断。这\n\t\t\t\t\t\t\t\t//在第二种情况下需要复查处理\n\t\t\t\t\t\t\t\t// shutdown - now竞赛同时清除中断\n                if ((runStateAtLeast(ctl.get(), STOP) ||\n                     (Thread.interrupted() &amp;amp;&amp;amp;\n                      runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;\n                    !wt.isInterrupted())\n                    wt.interrupt();\n                try {\n                  \t// 执行之前回调方法（可以由我们自己实现）\n                    beforeExecute(wt, task);\n                    Throwable thrown = null;\n                    try {\n                      \t// 执行任务\n                        task.run();\n                    } catch (RuntimeException x) {\n                        thrown = x; throw x;\n                    } catch (Error x) {\n                        thrown = x; throw x;\n                    } catch (Throwable x) {\n                        thrown = x; throw new Error(x);\n                    } finally {\n                      \t// 执行之后回调方法\n                        afterExecute(task, thrown);\n                    }\n                } finally {\n                  \t// 置为null\n                    task = null;\n                  \t// 更新完成任务\n                    w.completedTasks++;\n                    w.unlock();\n                }\n            }\n          \t// 完成\n            completedAbruptly = false;\n        } finally {\n          \t// 处理线程退出相关工作\n            processWorkerExit(w, completedAbruptly);\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面可以看到如果当前的任务是null，会去获取一个task，我们看看&lt;code&gt;getTask()&lt;/code&gt;，里面涉及到了两个参数，一个是是不是允许核心线程销毁，另外一个是线程数是不是大于核心线程数，如果满足条件，就从队列中取出任务，如果超时取不到，那就返回空，表示没有取到任务，没有取到任务，就不会执行前面的循环，就会触发线程销毁&lt;code&gt;processWorkerExit()&lt;/code&gt;等工作。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;private Runnable getTask() {\n  \t// 是否超时\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // SHUTDOWN状态继续处理队列中的任务，但是不接收新的任务\n        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n      \t// 线程数\n        int wc = workerCountOf(c);\n\n        // 是否允许核心线程超时或者线程数大于核心线程数\n        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;\n\n        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))\n            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {\n          \t// 减少线程成功，就返回null，后面由processWorkerExit()处理\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n          \t// 如果允许核心线程关闭，或者超过了核心线程，就可以在超时的时间内获取任务，或者直接取出任务\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n          \t// 如果能取到任务，那就肯定可以执行\n            if (r != null)\n                return r;\n          \t// 否则就获取不到任务，超时了\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;销毁线程\&#34;&gt;销毁线程&lt;/h3&gt;\n&lt;p&gt;前面提到，如果线程当前任务为空，又允许核心线程销毁，或者线程超过了核心线程数，等待了一定时间，超时了却没有从任务队列获取到任务的话，就会跳出循环执行到后面的线程销毁（结束）程序。那销毁线程的时候怎么做呢？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    private void processWorkerExit(Worker w, boolean completedAbruptly) {\n      \t// 如果是突然结束的线程，那么之前的线程数是没有调整的，这里需要调整\n        if (completedAbruptly)\n            decrementWorkerCount();\n      \t// 获取锁\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n      \n        try {\n          \t// 完成的任务数\n            completedTaskCount += w.completedTasks;\n            // 移除线程\n          \tworkers.remove(w);\n        } finally {\n          \t// 解锁\n            mainLock.unlock();\n        }\n      \t// 试图停止\n        tryTerminate();\n      \t// 获取状态\n        int c = ctl.get();\n      \t// 比stop小，至少是shutdown\n        if (runStateLessThan(c, STOP)) {\n          \t// 如果不是突然完成\n            if (!completedAbruptly) {\n              \t// 最小值要么是0，要么是核心线程数，要是允许核心线程超时销毁，那么就是0\n                int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n              \t// 如果最小的是0或者队列不是空的，那么保留一个线程\n                if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty())\n                    min = 1;\n              \t// 只要大于等于最小的线程数，就结束当前线程\n                if (workerCountOf(c) &amp;gt;= min)\n                    return; // replacement not needed\n            }\n          \t// 否则的话，可能还需要新增工作线程\n            addWorker(null, false);\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;如何停止线程池\&#34;&gt;如何停止线程池&lt;/h3&gt;\n&lt;p&gt;停止线程池可以使用&lt;code&gt;shutdown()&lt;/code&gt;或者&lt;code&gt;shutdownNow()&lt;/code&gt;，&lt;code&gt;shutdown()&lt;/code&gt;可以继续处理队列中的任务，而&lt;code&gt;shutdownNow()&lt;/code&gt;会立即清理任务，并返回未执行的任务。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public void shutdown() {\n        // 获取锁\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n          \t// 检查停止权限\n            checkShutdownAccess();\n          \t// 更新状态\n            advanceRunState(SHUTDOWN);\n          \t// 中断所有线程\n            interruptIdleWorkers();\n          \t// 回调钩子\n            onShutdown(); // hook for ScheduledThreadPoolExecutor\n        } finally {\n            mainLock.unlock();\n        }\n        tryTerminate();\n    }\n\t\t// 立刻停止\n   public List&amp;lt;Runnable&amp;gt; shutdownNow() {\n        List&amp;lt;Runnable&amp;gt; tasks;\n     \t\t// 获取锁\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n          \t// 检查停止权限\n            checkShutdownAccess();\n          \t// 更新状态到stop\n            advanceRunState(STOP);\n          \t// 中断所有线程\n            interruptWorkers();\n            // 清理队列\n            tasks = drainQueue();\n        } finally {\n            mainLock.unlock();\n        }\n        tryTerminate();\n     \t\t// 返回任务列表（未完成）\n        return tasks;\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;execute和submit方法\&#34;&gt;execute()和submit()方法&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;execute() &lt;/code&gt;方法可以提交不需要返回值的任务，无法判断任务是否被线程池执行是否成功&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;submit()&lt;/code&gt;方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个对象，我们调用&lt;code&gt;get()&lt;/code&gt;方法就可以&lt;strong&gt;阻塞&lt;/strong&gt;，直到获取到线程执行完成的结果，同时我们也可以使用有超时时间的等待方法&lt;code&gt;get（long timeout，TimeUnit unit）&lt;/code&gt;,这样不管线程有没有执行完成，如果到时间，也不会阻塞，直接返回null。返回的是&lt;code&gt;RunnableFuture&lt;/code&gt;对象，继承了&lt;code&gt;Runnable, Future&amp;lt;V&amp;gt;&lt;/code&gt;两个接口：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; {\n    /**\n     * Sets this Future to the result of its computation\n     * unless it has been cancelled.\n     */\n    void run();\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;线程池为什么使用阻塞队列\&#34;&gt;线程池为什么使用阻塞队列？&lt;/h2&gt;\n&lt;p&gt;阻塞队列，首先是一个队列，肯定具有先进先出的属性。&lt;/p&gt;\n&lt;p&gt;而阻塞，则是这个模型的演化，一般队列，可以用在生产消费者模型，也就是数据共享，有人往里面放任务，有人不断的往里面取出任务，这是一个理想的状态。&lt;/p&gt;\n&lt;p&gt;但是倘若不理想，产生任务和消费任务的速度不一样，要是任务放在队列里面比较多，消费比较慢，还可以慢慢消费，或者生产者得暂停一下产生任务（阻塞生产者线程）。可以使用 &lt;code&gt;offer(E o, long timeout, TimeUnit unit)&lt;/code&gt;设定等待的时间，如果在指定的时间内，还不能往队列中加入&lt;code&gt;BlockingQueue&lt;/code&gt;，则返回失败,也可以使用&lt;code&gt;put(Object)&lt;/code&gt;,将对象放到阻塞队列里面，如果没有空间，那么这个方法会阻塞到有空间才会放进去。&lt;/p&gt;\n&lt;p&gt;如果消费速度快，生产者来不及生产，获取任务的时候，可以使用&lt;code&gt;poll(time)&lt;/code&gt;,有数据则直接取出来，没数据则可以等待&lt;code&gt;time&lt;/code&gt;时间后，返回&lt;code&gt;null&lt;/code&gt;。也可以使用&lt;code&gt;take()&lt;/code&gt;取出第一个任务，没有任务就会一直阻塞到队列有任务为止。&lt;/p&gt;\n&lt;p&gt;上面说了阻塞队列的属性，那么为啥要用呢？&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;如果产生任务，来了就往队列里面放，资源很容易被耗尽。&lt;/li&gt;\n&lt;li&gt;创建线程需要获取锁，这个一个线程池的全局锁，如果各个线程不断的获取锁，解锁，线程上下文切换之类的开销也比较大，不如在队列为空的时候，然一个线程阻塞等待。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;常见的阻塞队列\&#34;&gt;常见的阻塞队列&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;9\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210621005042.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;：基于数组实现，内部有一个定长的数组，同时保存着队列头和尾部的位置。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;：基于链表的阻塞对垒，生产者和消费者使用独立的锁，并行能力强，如果不指定容量，默认是无效容量，容易系统内存耗尽。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;DelayQueue&lt;/strong&gt;：延迟队列，没有大小限制，生产数据不会被阻塞，消费数据会，只有指定的延迟时间到了，才能从队列中获取到该元素。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;PriorityBlockingQueue&lt;/strong&gt;：基于优先级的阻塞队列，按照优先级进行消费，内部控制同步的是公平锁。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;SynchronousQueue&lt;/strong&gt;：没有缓冲，生产者直接把任务交给消费者，少了中间的缓存区。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;线程池如何复用线程的执行完成的线程怎么处理\&#34;&gt;线程池如何复用线程的？执行完成的线程怎么处理&lt;/h2&gt;\n&lt;p&gt;前面的源码分析，其实已经讲解过这个问题了，线程池的线程调用的&lt;code&gt;run()&lt;/code&gt;方法，其实调用的是&lt;code&gt;runWorker()&lt;/code&gt;，里面是死循环，除非获取不到任务，如果没有了任务firstTask并且从任务队列中获取不到任务，超时的时候，会再判断是不是可以销毁核心线程，或者超过了核心线程数，满足条件的时候，才会让当前的线程结束。&lt;/p&gt;\n&lt;p&gt;否则，一直都在一个循环中，不会结束。&lt;/p&gt;\n&lt;p&gt;我们知道&lt;code&gt;start()&lt;/code&gt;方法只能调用一次,因此调用到&lt;code&gt;run()&lt;/code&gt;方法的时候，调用外面的&lt;code&gt;runWorker()&lt;/code&gt;,让其在&lt;code&gt;runWorker()&lt;/code&gt;的时候，不断的循环，获取任务。获取到任务，调用任务的&lt;code&gt;run()&lt;/code&gt;方法。&lt;/p&gt;\n&lt;p&gt;执行完成的线程会调用&lt;code&gt;processWorkerExit（）&lt;/code&gt;,前面有分析，里面会获取锁，把线程数减少，从工作线程从集合中移除，移除掉之后，会判断线程是不是太少了，如果是，会再加回来，个人以为是一种补救。&lt;/p&gt;\n&lt;h2 id=\&#34;如何配置线程池参数\&#34;&gt;如何配置线程池参数？&lt;/h2&gt;\n&lt;p&gt;一般而言，有个公式，如果是计算（CPU）密集型的任务，那么核心线程数设置为&lt;code&gt;处理器核数-1&lt;/code&gt;，如果是io密集型（很多网络请求），那么就可以设置为&lt;code&gt;2*处理器核数&lt;/code&gt;。但是这并不是一个银弹，一切要从实际出发，最好就是在测试环境进行压测，实践出真知，并且很多时候一台机器不止一个线程池或者还会有其他的线程，因此参数不可设置得太过饱满。&lt;/p&gt;\n&lt;p&gt;一般 8 核的机器，设置 10-12 个核心线程就差不多了，这一切必须按照业务具体值进行计算。设置过多的线程数，上下文切换，竞争激烈，设置过少，没有办法充分利用计算机的资源。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;计算（CPU）密集型消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。&lt;/p&gt;\n&lt;p&gt;io密集型系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;为什么不推荐默认的线程池创建方式\&#34;&gt;为什么不推荐默认的线程池创建方式？&lt;/h2&gt;\n&lt;p&gt;阿里的编程规范里面，不建议使用默认的方式来创建线程，是因为这样创建出来的线程很多时候参数都是默认的，可能创建者不太了解，很容易出问题，最好通过&lt;code&gt;new ThreadPoolExecutor()&lt;/code&gt;来创建，方便控制参数。默认的方式创建的问题如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Executors.newFixedThreadPool()：无界队列，内存可能被打爆&lt;/li&gt;\n&lt;li&gt;Executors.newSingleThreadExecutor()：单个线程，效率低，串行。&lt;/li&gt;\n&lt;li&gt;Executors.newCachedThreadPool()：没有核心线程，最大线程数可能为无限大，内存可能还会爆掉。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;使用具体的参数创建线程池，开发者必须了解每个参数的作用，不会胡乱设置参数，减少内存溢出等问题。&lt;/p&gt;\n&lt;p&gt;一般体现在几个问题：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;任务队列怎么设置？&lt;/li&gt;\n&lt;li&gt;核心线程多少个？&lt;/li&gt;\n&lt;li&gt;最大线程数多少？&lt;/li&gt;\n&lt;li&gt;怎么拒绝任务？&lt;/li&gt;\n&lt;li&gt;创建线程的时候没有名称，追溯问题不好找。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;线程池的拒绝策略\&#34;&gt;线程池的拒绝策略&lt;/h2&gt;\n&lt;p&gt;线程池一般有以下四种拒绝策略，其实我们可以从它的内部类看出来：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;10\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210620025945.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;ul&gt;\n&lt;li&gt;AbortPolicy: 不执行新的任务，直接抛出异常，提示线程池已满&lt;/li&gt;\n&lt;li&gt;DisCardPolicy：不执行新的任务，但是也不会抛出异常，默默的&lt;/li&gt;\n&lt;li&gt;DisCardOldSetPolicy：丢弃消息队列中最老的任务，变成新进来的任务&lt;/li&gt;\n&lt;li&gt;CallerRunsPolicy：直接调用当前的execute来执行任务&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;一般而言，上面的拒绝策略都不会特别理想，一般要是任务满了，首先需要做的就是看任务是不是必要的，如果非必要，非核心，可以考虑拒绝掉，并报错提醒，如果是必须的，必须把它保存起来，不管是使用mq消息，还是其他手段，不能丢任务。在这些过程中，日志是非常必要的。既要保护线程池，也要对业务负责。&lt;/p&gt;\n&lt;h2 id=\&#34;线程池监控与动态调整\&#34;&gt;线程池监控与动态调整&lt;/h2&gt;\n&lt;p&gt;线程池提供了一些API，可以动态获取线程池的状态，并且还可以设置线程池的参数，以及状态：&lt;/p&gt;\n&lt;p&gt;查看线程池的状态：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;11\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210621013706.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;修改线程池的状态：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;12\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210621013450.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;关于这一点，美团的线程池文章讲得很清楚，甚至做了一个实时调整线程池参数的平台，可以进行跟踪监控，线程池活跃度、任务的执行Transaction（频率、耗时）、Reject异常、线程池内部统计信息等等。这里我就不展开了，原文：https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html ，这是我们可以参考的思路。&lt;/p&gt;\n&lt;h2 id=\&#34;线程池隔离\&#34;&gt;线程池隔离&lt;/h2&gt;\n&lt;p&gt;线程隔离，很多同学可能知道，就是不同的任务放在不同的线程里面运行，而线程池隔离，一般是按照业务类型来隔离，比如订单的处理线程放在一个线程池，会员相关的处理放在一个线程池。&lt;/p&gt;\n&lt;p&gt;也可以通过核心和非核心来隔离，核心处理流程放在一起，非核心放在一起，两个使用不一样的参数，不一样的拒绝策略，尽量保证多个线程池之间不影响，并且最大可能保住核心线程的运行，非核心线程可以忍受失败。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;Hystrix&lt;/code&gt;里面运用到这个技术，&lt;code&gt;Hystrix&lt;/code&gt;的线程隔离技术，来防止不同的网络请求之间的雪崩，即使依赖的一个服务的线程池满了，也不会影响到应用程序的其他部分。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;xian-cheng-chi-na-xie-shi-xia-pian&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n# 线程池\n&lt;p&gt;&lt;strong&gt;本文关键字：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;线程&lt;/code&gt;，&lt;code&gt;线程池&lt;/code&gt;，&lt;code&gt;单线程&lt;/code&gt;，&lt;code&gt;多线程&lt;/code&gt;，&lt;code&gt;线程池的好处&lt;/code&gt;，&lt;code&gt;线程回收&lt;/code&gt;，&lt;code&gt;创建方式&lt;/code&gt;，&lt;code&gt;核心参数&lt;/code&gt;，&lt;code&gt;底层机制&lt;/code&gt;，&lt;code&gt;拒绝策略&lt;/code&gt;,&lt;code&gt;参数设置&lt;/code&gt;,&lt;code&gt;动态监控&lt;/code&gt;，&lt;code&gt;线程隔离&lt;/code&gt;&lt;/p&gt;\n&lt;p&gt;线程和线程池相关的知识，是Java学习或者面试中一定会遇到的知识点，本篇我们会从线程和进程，并行与并发，单线程和多线程等，一直讲解到线程池，线程池的好处，创建方式，重要的核心参数，几个重要的方法，底层实现，拒绝策略，参数设置，动态调整，线程隔离等等。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;线程池那些事下篇&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;线程池&#34;,&#34;slug&#34;:&#34;S8fse4uyb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/S8fse4uyb/&#34;}],&#34;date&#34;:&#34;2023-03-02 00:13:17&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/xian-cheng-chi-na-xie-shi-xia-pian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;34 min read&#34;,&#34;time&#34;:2009000,&#34;words&#34;:8629,&#34;minutes&#34;:34},&#34;description&#34;:&#34;\n# 线程池\n本文关键字：\n线程，线程池，单线程，多线程，线程池的好处，线程回收，创建方式，核心参数，底层机制，拒绝策略,参数设置,动态监控，线程隔离\n线程和线程池相关的知识，是Java学习或者面试中一定会遇到的知识点，本篇我们会从线程和进...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84\&#34;&gt;线程池的好处&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB\&#34;&gt;线程池相关的类&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#executor\&#34;&gt;Executor&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#executorservice\&#34;&gt;ExecutorService&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#abstractexecutorservice\&#34;&gt;AbstractExecutorService&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#threadpoolexecutor\&#34;&gt;ThreadPoolExecutor&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81\&#34;&gt;线程池状态&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#worker-%E5%AE%9E%E7%8E%B0\&#34;&gt;Worker 实现&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97\&#34;&gt;任务队列&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E5%92%8C%E5%A4%84%E7%90%86%E5%99%A8\&#34;&gt;拒绝策略和处理器&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0\&#34;&gt;如何创建线程池&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8F%82%E6%95%B0%E4%BB%A5%E5%8F%8A%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95\&#34;&gt;线程池的底层参数以及核心方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1\&#34;&gt;提交任务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1\&#34;&gt;处理任务&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%94%80%E6%AF%81%E7%BA%BF%E7%A8%8B\&#34;&gt;销毁线程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0\&#34;&gt;如何停止线程池&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#execute%E5%92%8Csubmit%E6%96%B9%E6%B3%95\&#34;&gt;execute()和submit()方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97\&#34;&gt;线程池为什么使用阻塞队列？&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97\&#34;&gt;常见的阻塞队列&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E5%A4%8D%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86\&#34;&gt;线程池如何复用线程的？执行完成的线程怎么处理&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8F%82%E6%95%B0\&#34;&gt;如何配置线程池参数？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E9%BB%98%E8%AE%A4%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F\&#34;&gt;为什么不推荐默认的线程池创建方式？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5\&#34;&gt;线程池的拒绝策略&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4\&#34;&gt;线程池监控与动态调整&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB\&#34;&gt;线程池隔离&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;&lt;strong&gt;本文关键字：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;线程&lt;/code&gt;，&lt;code&gt;线程池&lt;/code&gt;，&lt;code&gt;单线程&lt;/code&gt;，&lt;code&gt;多线程&lt;/code&gt;，&lt;code&gt;线程池的好处&lt;/code&gt;，&lt;code&gt;线程回收&lt;/code&gt;，&lt;code&gt;创建方式&lt;/code&gt;，&lt;code&gt;核心参数&lt;/code&gt;，&lt;code&gt;底层机制&lt;/code&gt;，&lt;code&gt;拒绝策略&lt;/code&gt;,&lt;code&gt;参数设置&lt;/code&gt;,&lt;code&gt;动态监控&lt;/code&gt;，&lt;code&gt;线程隔离&lt;/code&gt;&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;线程和线程池相关的知识，是Java学习或者面试中一定会遇到的知识点，本篇我们会从线程和进程，并行与并发，单线程和多线程等，一直讲解到线程池，线程池的好处，创建方式，重要的核心参数，几个重要的方法，底层实现，拒绝策略，参数设置，动态调整，线程隔离等等。主要的大纲如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.svg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;进程和线程\&#34;&gt;进程和线程&lt;/h1&gt;\n&lt;h2 id=\&#34;从线程到进程\&#34;&gt;从线程到进程&lt;/h2&gt;\n&lt;p&gt;要说线程池，就不得不先讲讲线程，什么是线程？&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;（英语：thread）是&lt;a href=\&#34;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\&#34;&gt;操作系统&lt;/a&gt;能够进行运算&lt;a href=\&#34;https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6\&#34;&gt;调度&lt;/a&gt;的最小单位。它被包含在&lt;a href=\&#34;https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B\&#34;&gt;进程&lt;/a&gt;之中，是&lt;a href=\&#34;https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B\&#34;&gt;进程&lt;/a&gt;中的实际运作单位。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;那么问题来了，进程又是什么？&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;进程是操作系统中进行保护和资源分配的基本单位。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;是不是有点懵，进程摸得着看得见么？具体怎么表现？打开&lt;code&gt;Windows&lt;/code&gt;的任务管理器或者&lt;code&gt;Mac&lt;/code&gt;的活动监视器，就可以看到，基本每一个打开的&lt;code&gt;App&lt;/code&gt;就是一个进程，但是并不是一定的，&lt;strong&gt;一个应用程序可能存在多个进程&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;比如下面的&lt;code&gt;Typora&lt;/code&gt;就显示了两个进程，每个进程后面有一个&lt;code&gt;PID&lt;/code&gt;是唯一的标识，也是由系统分配的。除此之外，每个进程都可以看到有多少个线程在执行，比如微信有&lt;code&gt;32&lt;/code&gt;个线程在执行。**重要的一句话：**一个程序运行之后至少有一个进程，一个进程可以包含多个线程。&lt;/p&gt;\n&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210508225417275.png\&#34; alt=\&#34;image-20210508225417275\&#34; style=\&#34;zoom:50%;\&#34; /&gt;\n&lt;h2 id=\&#34;为什么需要进程\&#34;&gt;为什么需要进程？&lt;/h2&gt;\n&lt;p&gt;程序，就是指令的集合，指令的集合说白了就是文件，让程序跑起来，在执行的程序，才是进程。程序是静态的描述文本，而进程是程序的一次执行活动，是动态的。进程是拥有计算机分配的资源的运行程序。&lt;/p&gt;\n&lt;p&gt;我们不可能一个计算机只有一个进程，就跟我们全国不可能只有一个市或者一个部门，计算机是一个庞然大物，里面的运转需要有条理，就需要按照功能划分出比较独立的单位，分开管理。每个进程有自己的职责，也有自己的独立内存空间，不可能混着使用，要是所有的程序共用一个进程就会乱套。&lt;/p&gt;\n&lt;p&gt;**每个进程，都有各自独立的内存，进程之间内存地址隔离，进程的资源，比如：代码段，数据集，堆等等，还可能包括一些打开的文件或者信号量，这都是每个进程自己的数据。**同时，由于进程的隔离性，即使有一个程序的进程出现问题了，一般不会影响到其他的进程的使用。&lt;/p&gt;\n&lt;p&gt;进程在Linux系统中，进程有一个比较重要的东西，叫进程控制块（&lt;code&gt;PCB&lt;/code&gt;），仅做了解：&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;PCB&lt;/code&gt;是进程的唯一标识，由链表实现，是为了动态的插入以及删除，创建进程的时候，生成一个&lt;code&gt;PCB&lt;/code&gt;，进程结束的时候，回收这个&lt;code&gt;PCB&lt;/code&gt;。&lt;code&gt;PCB&lt;/code&gt;主要包括以下的信息：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;进程状态&lt;/li&gt;\n&lt;li&gt;进程标识信息&lt;/li&gt;\n&lt;li&gt;定时器&lt;/li&gt;\n&lt;li&gt;用户可见的寄存器，控制状态寄存区，栈指针等等。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;进程怎么切换的呢\&#34;&gt;进程怎么切换的呢？&lt;/h4&gt;\n&lt;p&gt;先明白计算机里面的一个事实：&lt;strong&gt;CPU运转得超级无敌快&lt;/strong&gt;，快到其他的只有寄存器差不多能匹配它的速度，但是很多时候我们需要从磁盘或者内存读或者写数据，这些设备的速度太慢了，与之相差太远。（&lt;strong&gt;如果不特殊说明，默认是单核的CPU&lt;/strong&gt;）&lt;/p&gt;\n&lt;p&gt;假设一个程序/进程的任务执行一段时间，要写磁盘，写磁盘不需要&lt;code&gt;CUP&lt;/code&gt;进行计算，那&lt;code&gt;CPU&lt;/code&gt;就空出来了，但是其他的程序也不能用，&lt;code&gt;CPU&lt;/code&gt;就干等着，等到写完磁盘再接着执行。这多浪费，&lt;code&gt;CPU&lt;/code&gt;又不是这个程序一家的，其他的应用也要使用。&lt;code&gt;CPU&lt;/code&gt;你不用的时候，总有别人需要用。&lt;/p&gt;\n&lt;p&gt;所以&lt;code&gt;CPU&lt;/code&gt;资源需要调度，程序&lt;code&gt;A&lt;/code&gt;不用的时候，可以切出来，让程序&lt;code&gt;B&lt;/code&gt;去使用，但是程序&lt;code&gt;A&lt;/code&gt;切回来的时候怎么保证它能够接着之前的位置继续执行呢？这时候不得不提&lt;strong&gt;上下文&lt;/strong&gt;的事。&lt;/p&gt;\n&lt;p&gt;当程序&lt;code&gt;A&lt;/code&gt;（假设为单进程）放弃&lt;code&gt;CPU&lt;/code&gt;的时候，需要保存当前的上下文，**何为上下文？**也就是除了&lt;code&gt;CPU&lt;/code&gt;之外，寄存器或者其他的状态，就跟犯罪现场一样，需要拍个照，要不到时候别的程序执行完之后，怎么知道接下来怎么执行程序&lt;code&gt;A&lt;/code&gt;，之前执行到哪一步了。&lt;strong&gt;总结一句话：保存当前程序的执行状态。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;上下文切换一般还涉及缓存的开销，也就是缓存会失效，一般执行的时候，CPU会缓存一些数据方便下次更快的执行，一旦进行上下文切换，原来的缓存就失效了，需要重新缓存。&lt;/p&gt;\n&lt;p&gt;调度一般有两种（一般是按照线程维度来调度）,&lt;code&gt;CPU&lt;/code&gt;的时间被分为特别小的时间片：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;分时调度：每个线程或者进程轮流的使用&lt;code&gt;CPU&lt;/code&gt;，平均时间分配到每个线程或者进程。&lt;/li&gt;\n&lt;li&gt;抢占式调度：优先级高的线程/进程立即抢占下一个时间片，如果优先级相同，那么随机选择一个进程。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;&lt;strong&gt;时间片超级短，CPU超级快，给我们无比丝滑的感觉，就像是多个任务在同时进行&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;我们现在操作系统或者其他的系统，基本都是抢占式调度，为什么？&lt;/p&gt;\n&lt;p&gt;因为如果使用分时调度，很难做到实时响应，当后台的聊天程序在进行网络传输的时候，分配予它的时间片还没有使用完，那我点击浏览器，是没有办法实时响应的。除此之外，如果前面的进程挂了，但是一直占有&lt;code&gt;CPU&lt;/code&gt;，那么后面的任务将永远得不到执行。&lt;/p&gt;\n&lt;p&gt;由于&lt;code&gt;CPU&lt;/code&gt;的处理能力超级快，就算是单核的&lt;code&gt;CPU&lt;/code&gt;，运行着多个程序，多个进程，经过抢占式的调度，每一个程序使用的时候都像是独享了&lt;code&gt;CPU&lt;/code&gt;一样顺滑。进程有效的提高了&lt;code&gt;CPU&lt;/code&gt;的使用率，但是进程在上下文切换的时候是存在着一定的成本的。&lt;/p&gt;\n&lt;h2 id=\&#34;线程和进程什么关系\&#34;&gt;线程和进程什么关系？&lt;/h2&gt;\n&lt;p&gt;前面说了进程，那有了进程，为啥还要线程，多个应用程序，假设我们每个应用程序要做&lt;code&gt;n&lt;/code&gt;件事，就用&lt;code&gt;n&lt;/code&gt;个进程不行么？&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;可以，但是没必要。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;进程一般由程序，数据集合和进程控制块组成，同一个应用程序一般是需要使用同一个数据空间的，要是一个应用程序搞很多个进程，就算有能力做到数据空间共享，进程的上下文切换都会消耗很多资源。（一般一个应用程序不会有很多进程，大多数一个，少数有几个）&lt;/p&gt;\n&lt;p&gt;进程的颗粒度比较大，每次执行都需要上下文切换，如果同一个程序里面的代码段&lt;code&gt;A&lt;/code&gt;，&lt;code&gt;B&lt;/code&gt;，&lt;code&gt;C&lt;/code&gt;，做不一样的东西，如果分给多个进程去处理，那么每次执行都有切换进程上下文。这太惨了。&lt;strong&gt;一个应用程序的任务是一家人，住在同一个屋子下（同一个内存空间），有必要每个房间都当成每一户，去派出所登记成一个户口么？&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;进程缺点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;信息共享难，空间独立&lt;/li&gt;\n&lt;li&gt;切换需要&lt;code&gt;fork()&lt;/code&gt;，切换上下文，开销大&lt;/li&gt;\n&lt;li&gt;只能在一个时间点做一件事&lt;/li&gt;\n&lt;li&gt;如果进程阻塞了，要等待网络传过来数据，那么其他不依赖这个数据的任务也做不了&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;但是有人会说，那我一个应用程序有很多事情要做，总不能只用一个进程，所有事情都等着它来处理啊？那不是会阻塞住么？&lt;/p&gt;\n&lt;p&gt;确实啊，单独一个进程处理不了问题，那么我们&lt;strong&gt;把进程分得更小&lt;/strong&gt;，里面分成很多线程，一家人，每个人都有自己的事情做，那我们每个人就是一个线程，一家人就是一个进程，这样岂不是更好么？&lt;/p&gt;\n&lt;p&gt;进程是描述CPU时间片调度的时间片段，但是线程是更细小的时间片段，两者的颗粒度不一样。&lt;strong&gt;线程可以称为轻量级的进程&lt;/strong&gt;。其实，线程也不是一开始就有的概念，而是随着计算机发展，对多个任务上下文切换要求越来越高，随之抽象出来的概念。&lt;/p&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;进&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;间&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;段&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;加&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;载&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;下&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;间&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;间&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;保&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;存&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;序&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;下&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;间&lt;/mi&gt;&lt;mspace linebreak=\&#34;newline\&#34;&gt;&lt;/mspace&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;线&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;间&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;段&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;加&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;载&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;线&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;下&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;间&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;执&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;间&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mi&gt;U&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;保&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;存&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;线&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;程&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;上&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;下&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;文&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;间&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;进程时间段 = CPU加载程序上下文的时间 + CPU执行时间 + CPU保存程序上下文的时间\\\\\n线程时间段 = CPU加载线程上下文的时间 + CPU执行时间 + CPU保存线程上下文的时间\n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.36687em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;进&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;程&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;时&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;间&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;段&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.76666em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07153em;\&#34;&gt;C&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.13889em;\&#34;&gt;P&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;U&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;加&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;载&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;程&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;序&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;上&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;下&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;文&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;时&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;间&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.76666em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07153em;\&#34;&gt;C&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.13889em;\&#34;&gt;P&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;U&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;执&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;行&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;时&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;间&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.68333em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07153em;\&#34;&gt;C&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.13889em;\&#34;&gt;P&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;U&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;保&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;存&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;程&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;序&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;上&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;下&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;文&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;时&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;间&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;mspace newline\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.36687em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;线&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;程&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;时&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;间&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;段&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.76666em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07153em;\&#34;&gt;C&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.13889em;\&#34;&gt;P&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;U&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;加&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;载&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;线&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;程&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;上&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;下&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;文&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;时&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;间&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.76666em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07153em;\&#34;&gt;C&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.13889em;\&#34;&gt;P&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;U&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;执&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;行&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;时&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;间&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.68333em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.07153em;\&#34;&gt;C&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.13889em;\&#34;&gt;P&lt;/span&gt;&lt;span class=\&#34;mord mathdefault\&#34; style=\&#34;margin-right:0.10903em;\&#34;&gt;U&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;保&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;存&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;线&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;程&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;上&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;下&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;文&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;的&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;时&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;最重要的是，进程切换上下文的时间远比线程切换上下文的时间成本要高&lt;/strong&gt;，如果是同一个进程的不同线程之间抢占到&lt;code&gt;CPU&lt;/code&gt;，切换成本会比较低，因为他们&lt;strong&gt;共享了进程的地址空间&lt;/strong&gt;，线程间的通信容易很多，通过共享进程级全局变量即可实现。&lt;/p&gt;\n&lt;p&gt;况且，现在多核的处理器，让不同进程在不同核上跑，进程内的线程在同个核上做切换，尽量减少（不可以避免）进程的上下文切换，或者让不同线程跑在不同的处理器上，进一步提高效率。&lt;/p&gt;\n&lt;p&gt;进程和线程的模型如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210509163642149.png\&#34; alt=\&#34;image-20210509163642149\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;线程和进程的区别或者优点\&#34;&gt;线程和进程的区别或者优点&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;线程是程序执行的最小单位，进程是操作系统分配资源的最小单位。&lt;/li&gt;\n&lt;li&gt;一个应用可能多个进程，一个进程由一个或者多个线程组成&lt;/li&gt;\n&lt;li&gt;进程相互独立，通信或者沟通成本高，在同一个进程下的线程共享进程的内存等，相互之间沟通或者协作成本低。&lt;/li&gt;\n&lt;li&gt;线程切换上下文比进程切换上下文要快得多。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;线程有哪些状态\&#34;&gt;线程有哪些状态&lt;/h2&gt;\n&lt;p&gt;现在我们所说的是&lt;code&gt;Java&lt;/code&gt;中的线程&lt;code&gt;Thread&lt;/code&gt;,一个线程在一个给定的时间点，只能处于一种状态，这些状态都是虚拟机的状态，不能反映任何操作系统的线程状态，一共有六种/七种状态：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;NEW&lt;/code&gt;：创建了线程对象，但是还没有调用&lt;code&gt;Start()&lt;/code&gt;方法，还没有启动的线程处于这种状态。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;Running&lt;/code&gt;：运行状态，其实包含了两种状态，但是&lt;code&gt;Java&lt;/code&gt;线程将就绪和运行中统称为可运行&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Runnable&lt;/code&gt;：就绪状态：创建对象后，调用了&lt;code&gt;start()&lt;/code&gt;方法，该状态的线程还位于可运行线程池中，等待调度，获取&lt;code&gt;CPU&lt;/code&gt;的使用权\n&lt;ul&gt;\n&lt;li&gt;只是有资格执行，不一定会执行&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;start()&lt;/code&gt;之后进入就绪状态，&lt;code&gt;sleep()&lt;/code&gt;结束或者&lt;code&gt;join()&lt;/code&gt;结束，线程获得对象锁等都会进入该状态。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt;时间片结束或者主动调用&lt;code&gt;yield()&lt;/code&gt;方法，也会进入该状态&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Running&lt;/code&gt; ：获取到&lt;code&gt;CPU&lt;/code&gt;的使用权（获得CPU时间片），变成运行中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;BLOCKED&lt;/code&gt; ：阻塞，线程阻塞于锁，等待监视器锁，一般是&lt;code&gt;Synchronize&lt;/code&gt;关键字修饰的方法或者代码块&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;WAITING&lt;/code&gt; ：进入该状态，需要等待其他线程通知（&lt;code&gt;notify&lt;/code&gt;）或者中断，一个线程无限期地等待另一个线程。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt; ：超时等待，在指定时间后自动唤醒，返回，不会一直等待&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;TERMINATED&lt;/code&gt; ：线程执行完毕，已经退出。如果已终止再调用start()，将会抛出&lt;code&gt;java.lang.IllegalThreadStateException&lt;/code&gt;异常。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210509224848865.png\&#34; alt=\&#34;image-20210509224848865\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到&lt;code&gt;Thread.java&lt;/code&gt;里面有一个&lt;code&gt;State&lt;/code&gt;枚举类，枚举了线程的各种状态(&lt;code&gt;Java&lt;/code&gt;线程将&lt;strong&gt;就绪&lt;/strong&gt;和&lt;strong&gt;运行中&lt;/strong&gt;统称为&lt;strong&gt;可运行&lt;/strong&gt;)：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;public enum State {\n    /**\n     * 尚未启动的线程的线程状态。\n     */\n    NEW,\n\n    /**\n     * 可运行线程的线程状态，一个处于可运行状态的线程正在Java虚拟机中执行，但它可能正在等待来自操作系统(如处理器)的其他资源。\n     */\n    RUNNABLE,\n\n    /**\n     * 等待监视器锁而阻塞的线程的线程状态。\n     * 处于阻塞状态的线程正在等待一个监视器锁进入一个同步的块/方法，或者在调用Oject.wait()方法之后重新进入一个同步代码块\n     */\n    BLOCKED,\n\n    /**\n     * 等待线程的线程状态，线程由于调用其中一个线程而处于等待状态\n     */\n    WAITING,\n\n    /**\n     * 具有指定等待时间的等待线程的线程状态，线程由于调用其中一个线程而处于定时等待状态。\n     */\n    TIMED_WAITING,\n\n    /**\n     * 终止线程的线程状态，线程已经完成执行。\n     */\n    TERMINATED;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;除此之外，Thread类还有一些属性是和线程对象有关的：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;long tid：线程序号&lt;/li&gt;\n&lt;li&gt;char name[]：线程名称&lt;/li&gt;\n&lt;li&gt;int priority：线程优先级&lt;/li&gt;\n&lt;li&gt;boolean daemon：是否守护线程&lt;/li&gt;\n&lt;li&gt;Runnable target：线程需要执行的方法&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;介绍一下上面图中讲解到线程的几个重要方法，它们都会导致线程的状态发生一些变化：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Thread.sleep(long)&lt;/code&gt;:调用之后，线程进入&lt;code&gt;TIMED_WAITING&lt;/code&gt;状态，但是不会释放对象锁，到时间苏醒后进入&lt;code&gt;Runnable&lt;/code&gt;就绪状态&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Thread.yield()&lt;/code&gt;:线程调用该方法，表示放弃获取的&lt;code&gt;CPU&lt;/code&gt;时间片，但是不会释放锁资源，同样变成就绪状态，等待重新调度，不会阻塞，但是也不能保证一定会让出&lt;code&gt;CPU&lt;/code&gt;，很可能又被重新选中。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;thread.join(long)&lt;/code&gt;:当前线程调用其他线程&lt;code&gt;thread&lt;/code&gt;的&lt;code&gt;join()&lt;/code&gt;方法，当前线程不会释放锁，会进入&lt;code&gt;WAITING&lt;/code&gt;或者&lt;code&gt;TIMED_WAITING&lt;/code&gt;状态，等待thread执行完毕或者时间到，当前线程进入就绪状态。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;object.wait(long)&lt;/code&gt;:当前线程调用对象的&lt;code&gt;wait()&lt;/code&gt;方法，当前线程会释放获得的对象锁，进入等待队列，&lt;code&gt;WAITING&lt;/code&gt;，等到时间到或者被唤醒。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;object.notify()&lt;/code&gt;：唤醒在该对象监视器上等待的线程，随机挑一个&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;object.notifyAll()&lt;/code&gt;：唤醒在该对象监视器上等待的所有线程&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;单线程和多线程\&#34;&gt;单线程和多线程&lt;/h2&gt;\n&lt;p&gt;单线程，就是只有一条线程在执行任务，串行的执行，而多线程，则是多条线程同时执行任务，所谓同时，并不是一定真的同时，如果在单核的机器上，就是假同时，只是看起来同时，实际上是轮流占据CPU时间片。&lt;/p&gt;\n&lt;p&gt;下面的每一个格子是一个时间片（每一个时间片实际上超级无敌短），不同的线程其实可以抢占不同的时间片，获得执行权。&lt;strong&gt;时间片分配的单位是线程，而不是进程，进程只是容器&lt;/strong&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210511002923132.png\&#34; alt=\&#34;image-20210511002923132\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;如何启动一个线程\&#34;&gt;如何启动一个线程&lt;/h3&gt;\n&lt;p&gt;其实&lt;code&gt;Java&lt;/code&gt;的&lt;code&gt;main()&lt;/code&gt;方法本质上就启动了一个线程，但是&lt;strong&gt;本质上不是只有一个线程&lt;/strong&gt;，看结果的 5 就大致知道，其实一共有 5 个线程，主线程是第 5 个,大多是&lt;strong&gt;后台线程&lt;/strong&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;public class Test {\n    public static void main(String[] args) {\n        System.out.println(Thread.currentThread().toString());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;Thread[main,5,main]\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看出上面的线程是&lt;code&gt;main&lt;/code&gt;线程，但是要想创建出有别于&lt;code&gt;main&lt;/code&gt;线程的方式，有四种：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;自定义类去实现&lt;code&gt;Runnable&lt;/code&gt;接口&lt;/li&gt;\n&lt;li&gt;继承&lt;code&gt;Thread&lt;/code&gt;类，重写&lt;code&gt;run()&lt;/code&gt;方法&lt;/li&gt;\n&lt;li&gt;通过&lt;code&gt;Callable&lt;/code&gt;和&lt;code&gt;FutureTask&lt;/code&gt;创建线程&lt;/li&gt;\n&lt;li&gt;线程池直接启动（本质上不算是）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;实现runnable接口\&#34;&gt;实现Runnable接口&lt;/h4&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class MyThread implements Runnable{\n    @Override\n    public void run(){\n        System.out.println(&amp;quot;Hello world&amp;quot;);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new MyThread());\n        thread.start();\n        System.out.println(&amp;quot;Main Thread&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;Main Thread\nHello world\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;如果看底层就可以看到，构造函数的时候，我们将&lt;code&gt;Runnable&lt;/code&gt;的实现类对象传递进入,会将&lt;code&gt;Runnable&lt;/code&gt;实现类对象保存下来：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public Thread(Runnable target) {\n        this(null, target, &amp;quot;Thread-&amp;quot; + nextThreadNum(), 0);\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;然后再调用&lt;code&gt;start()&lt;/code&gt;方法的时候,会调用原生的&lt;code&gt;start0()&lt;/code&gt;方法，原生方法是由&lt;code&gt;c&lt;/code&gt;或者&lt;code&gt;c++&lt;/code&gt;写的,这里看不到具体的实现：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    public synchronized void start() {\n        if (threadStatus != 0)\n            throw new IllegalThreadStateException();\n        group.add(this);\n        boolean started = false;\n        try {\n          \t// 正式的调用native原生方法\n            start0();\n            started = true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadStartFailed(this);\n                }\n            } catch (Throwable ignore) {\n            }\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;&lt;code&gt;Start0()&lt;/code&gt;在底层确实调用了&lt;code&gt;run()&lt;/code&gt;方法，并且不是直接调用的，而是启用了另外一个线程进行调用的，这一点在代码注释里面写得比较清楚，在这里我们就不展开讲，我们将关注点放到&lt;code&gt;run()&lt;/code&gt;方法上，调用的就是刚刚那个&lt;code&gt;Runnable&lt;/code&gt;实现类的对象的&lt;code&gt;run()&lt;/code&gt;方法:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    @Override\n    public void run() {\n        if (target != null) {\n            target.run();\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;继承thread类\&#34;&gt;继承Thread类&lt;/h4&gt;\n&lt;p&gt;由于&lt;code&gt;Thread&lt;/code&gt;类本身就实现了&lt;code&gt;Runnable&lt;/code&gt;接口，所以我们只要继承它就可以了：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class Thread implements Runnable {\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;继承之后重写run()方法即可：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;class MyThread extends Thread{\n    @Override\n    public void run(){\n        System.out.println(&amp;quot;Hello world&amp;quot;);\n    }\n}\npublic class Test {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new MyThread());\n        thread.start();\n        System.out.println(&amp;quot;Main Thread&amp;quot;);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行结果和上面的一样，其实两种方式本质上都是一样的，一个是实现了&lt;code&gt;Runnable&lt;/code&gt;接口，另外一个是继承了实现了&lt;code&gt;Runnable&lt;/code&gt;接口的&lt;code&gt;Thread&lt;/code&gt;类。两种都没有返回值，因为&lt;code&gt;run()&lt;/code&gt;方法的返回值是&lt;code&gt;void&lt;/code&gt;。&lt;/p&gt;\n&lt;h4 id=\&#34;callable和futuretask创建线程\&#34;&gt;Callable和FutureTask创建线程&lt;/h4&gt;\n&lt;p&gt;要使用该方式，按照以下步骤：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;创建&lt;code&gt;Callable&lt;/code&gt;接口的实现类，实现&lt;code&gt;call()&lt;/code&gt;方法&lt;/li&gt;\n&lt;li&gt;创建&lt;code&gt;Callable&lt;/code&gt;实现类的对象实例，用&lt;code&gt;FutureTask&lt;/code&gt;包装Callable的实现类实例，包装成&lt;code&gt;FutureTask&lt;/code&gt;的实例，&lt;code&gt;FutureTask&lt;/code&gt;的实例封装了&lt;code&gt;Callable&lt;/code&gt;对象的&lt;code&gt;Call()&lt;/code&gt;方法的返回值&lt;/li&gt;\n&lt;li&gt;使用&lt;code&gt;FutureTask&lt;/code&gt;对象作为&lt;code&gt;Thread&lt;/code&gt;对象的&lt;code&gt;target&lt;/code&gt;创建并启动线程，&lt;code&gt;FutureTask&lt;/code&gt;实现了&lt;code&gt;RunnableFuture&lt;/code&gt;，&lt;code&gt;RunnableFuture&lt;/code&gt;继承了&lt;code&gt;Runnable&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;调用&lt;code&gt;FutureTask&lt;/code&gt;对象的&lt;code&gt;get()&lt;/code&gt;来获取子线程执行结束的返回值&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\n\npublic class CallableTest {\n    public static void main(String[] args) throws Exception{\n\n        Callable&amp;lt;String&amp;gt; callable = new MyCallable&amp;lt;String&amp;gt;();\n        FutureTask&amp;lt;String&amp;gt; task = new FutureTask&amp;lt;String&amp;gt;(callable);\n\n        Thread thread = new Thread(task);\n        thread.start();\n\n        System.out.println(Thread.currentThread().getName());\n        System.out.println(task.get());\n\n    }\n}\n\nclass MyCallable&amp;lt;String&amp;gt; implements Callable&amp;lt;String&amp;gt; {\n    @Override\n    public String call() throws Exception {\n        System.out.println(\n                Thread.currentThread().getName() +\n                        &amp;quot; Callable Thread&amp;quot;);\n        return (String) &amp;quot;Hello&amp;quot;;\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;main\nThread-0 Callable Thread\nHello\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;其实这种方式本质上也是&lt;code&gt;Runnable&lt;/code&gt;接口来实现的，只不过做了一系列的封装，但是不同的是，它可以实现返回值，如果我们期待一件事情可以通过另外一个线程来获取结果，但是可能需要消耗一些时间，比如异步网络请求，其实可以考虑这种方式。&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;Callable&lt;/code&gt;和&lt;code&gt;FutureTask&lt;/code&gt;是后面才加入的功能，是为了适应多种并发场景，&lt;code&gt;Callable&lt;/code&gt;和&lt;code&gt;Runnable&lt;/code&gt;的区别如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt; 定义方法是&lt;code&gt;call()&lt;/code&gt;，&lt;code&gt;Runnable&lt;/code&gt;定义的方法是&lt;code&gt;run()&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt;的&lt;code&gt;call()&lt;/code&gt;方法有返回值，&lt;code&gt;Runnable&lt;/code&gt;的&lt;code&gt;run()&lt;/code&gt;方法没有返回值&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Callable&lt;/code&gt;的&lt;code&gt;call()&lt;/code&gt;方法可以抛出异常，&lt;code&gt;Runnable&lt;/code&gt;的&lt;code&gt;run()&lt;/code&gt;方法不能抛出异常&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;线程池启动线程\&#34;&gt;线程池启动线程&lt;/h4&gt;\n&lt;p&gt;本质上也是通过实现&lt;code&gt;Runnable&lt;/code&gt;接口，然后放到线程池中进行执行：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nclass MyThread extends Thread {\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + &amp;quot; : hello world&amp;quot;);\n    }\n}\n\npublic class Test {\n    public static void main(String[] args) throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(5);\n        for (int i = 0; i &amp;lt; 10; i++) {\n            MyThread thread = new MyThread();\n            executorService.execute(thread);\n        }\n        executorService.shutdown();\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行结果如下，可以看到五个核心线程一直在执行，没有规律，循环十次，但是并没有创建出十个线程，这和线程池的设计以及参数有关，后面会讲解：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-txt\&#34;&gt;pool-1-thread-5 : hello world\npool-1-thread-4 : hello world\npool-1-thread-5 : hello world\npool-1-thread-3 : hello world\npool-1-thread-2 : hello world\npool-1-thread-1 : hello world\npool-1-thread-2 : hello world\npool-1-thread-3 : hello world\npool-1-thread-5 : hello world\npool-1-thread-4 : hello world\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;总结一下，启动一个线程，其实本质上都离不开&lt;code&gt;Runnable&lt;/code&gt;接口，不管是继承还是实现接口。&lt;/p&gt;\n&lt;h3 id=\&#34;多线程可能带来的问题\&#34;&gt;多线程可能带来的问题&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;消耗资源：上下文切换，或者创建以及销毁线程，都是比较消耗资源的。&lt;/li&gt;\n&lt;li&gt;竞态条件：多线程访问或者修改同一个对象，假设自增操作&lt;code&gt;num++&lt;/code&gt;，操作分为三步，读取&lt;code&gt;num&lt;/code&gt;，&lt;code&gt;num&lt;/code&gt;加1，写回&lt;code&gt;num&lt;/code&gt;，并非原子操作，那么多个线程之间交叉运行，就会产生不如预期的结果。&lt;/li&gt;\n&lt;li&gt;内存的可见性：每个线程都有自己的内存（缓存），一般修改的值都放在自己线程的缓存上，到刷新至主内存有一定的时间，所以可能一个线程更新了，但是另外一个线程获取到的还是久的值，这就是不可见的问题。&lt;/li&gt;\n&lt;li&gt;执行顺序难预知：线程先&lt;code&gt;start()&lt;/code&gt;不一定先执行，是由系统决定的，会导致共享的变量或者执行结果错乱&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;并发与并行\&#34;&gt;并发与并行&lt;/h2&gt;\n&lt;p&gt;并发是指两个或多个事件在同一时间间隔发生，比如在同&lt;code&gt;1s&lt;/code&gt;中内计算机不仅计算&lt;code&gt;数据1&lt;/code&gt;，同时也计算了&lt;code&gt;数据2&lt;/code&gt;。但是两件事情可能在某一个时刻，不是真的同时进行，很可能是抢占时间片就执行，抢不到就别人执行，但是由于时间片很短，所以在1s中内，看似是同时执行完成了。当然前面说的是单核的机器，并发不是真的同时执行，但是多核的机器上，并发也可能是真的在同时执行，只是有可能，这个时候的并发也叫做并行。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210511012516227.png\&#34; alt=\&#34;image-20210511012516227\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;并行是指在同一时刻，有多条指令在多个处理器上同时执行，真正的在同时执行。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210511012723433.png\&#34; alt=\&#34;image-20210511012723433\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;如果是单核的机器，最多只能并发，不可能并行处理，只能把CPU运行时间分片，分配给各个线程执行，执行不同的线程任务的时候需要上下文切换。而多核机器，可以做到真的并行，同时在多个核上计算，运行。&lt;strong&gt;并行操作一定是并发的，但是并发的操作不一定是并行的。&lt;/strong&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;xian-cheng-chi-na-xie-shi-shang-pian&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;&lt;strong&gt;本文关键字：&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;&lt;code&gt;线程&lt;/code&gt;，&lt;code&gt;线程池&lt;/code&gt;，&lt;code&gt;单线程&lt;/code&gt;，&lt;code&gt;多线程&lt;/code&gt;，&lt;code&gt;线程池的好处&lt;/code&gt;，&lt;code&gt;线程回收&lt;/code&gt;，&lt;code&gt;创建方式&lt;/code&gt;，&lt;code&gt;核心参数&lt;/code&gt;，&lt;code&gt;底层机制&lt;/code&gt;，&lt;code&gt;拒绝策略&lt;/code&gt;,&lt;code&gt;参数设置&lt;/code&gt;,&lt;code&gt;动态监控&lt;/code&gt;，&lt;code&gt;线程隔离&lt;/code&gt;&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;线程池那些事上篇&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;线程池&#34;,&#34;slug&#34;:&#34;S8fse4uyb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/S8fse4uyb/&#34;}],&#34;date&#34;:&#34;2023-03-02 00:09:32&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/xian-cheng-chi-na-xie-shi-shang-pian/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;21 min read&#34;,&#34;time&#34;:1259000,&#34;words&#34;:5794,&#34;minutes&#34;:21},&#34;description&#34;:&#34;\n本文关键字：\n线程，线程池，单线程，多线程，线程池的好处，线程回收，创建方式，核心参数，底层机制，拒绝策略,参数设置,动态监控，线程隔离\n\n线程和线程池相关的知识，是Java学习或者面试中一定会遇到的知识点，本篇我们会从线程和进程，并行与...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\&#34;&gt;进程和线程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8E%E7%BA%BF%E7%A8%8B%E5%88%B0%E8%BF%9B%E7%A8%8B\&#34;&gt;从线程到进程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%9B%E7%A8%8B\&#34;&gt;为什么需要进程？&lt;/a&gt;&lt;br&gt;\n*\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BF%9B%E7%A8%8B%E6%80%8E%E4%B9%88%E5%88%87%E6%8D%A2%E7%9A%84%E5%91%A2\&#34;&gt;进程怎么切换的呢？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB\&#34;&gt;线程和进程什么关系？&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%88%96%E8%80%85%E4%BC%98%E7%82%B9\&#34;&gt;线程和进程的区别或者优点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81\&#34;&gt;线程有哪些状态&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B\&#34;&gt;单线程和多线程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B\&#34;&gt;如何启动一个线程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3\&#34;&gt;实现Runnable接口&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%A7%E6%89%BFthread%E7%B1%BB\&#34;&gt;继承Thread类&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#callable%E5%92%8Cfuturetask%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B\&#34;&gt;Callable和FutureTask创建线程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B\&#34;&gt;线程池启动线程&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98\&#34;&gt;多线程可能带来的问题&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C\&#34;&gt;并发与并行&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;blockquote&gt;\n&lt;p&gt;前一段时间在写一门算法课，总算是上线了，以及面试，所以没什么时间写，接下来的时间，应该会讲讲面试准备，刷题的一些东西，面了很多，通过面试的有平安，涂鸦智能，阿里，腾讯微保，虾皮，华为荣耀，微众，当然也有其他不少挂的，挂也正常，面试是一个双向选择，当然，我也还是个菜鸟。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;!-- more --&gt;\n&lt;blockquote&gt;\n&lt;p&gt;以前，我总觉得的买一件东西，做一件事，或者从某一个时间节点开始，我的生命就会发生转折，一切就会无比顺利，立马变厉害。但是，事实上并不是如此。我不可能马上变厉害，也不可能一口吃成一个胖子。看一篇文章也不能让你从此走上人生巅峰，越来越相信，这是一个长期的过程，只有量变引起质变，纵使缓慢，驰而不息。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h1 id=\&#34;如何设计一个线程池\&#34;&gt;如何设计一个线程池？&lt;/h1&gt;\n&lt;h2 id=\&#34;三个步骤\&#34;&gt;三个步骤&lt;/h2&gt;\n&lt;p&gt;这是一个常见的问题，如果在比较熟悉线程池运作原理的情况下，这个问题并不难。设计实现一个东西，三步走：是什么？为什么？怎么做？&lt;/p&gt;\n&lt;h3 id=\&#34;线程池是什么\&#34;&gt;线程池是什么？&lt;/h3&gt;\n&lt;p&gt;线程池使用了池化技术，将线程存储起来放在一个 &amp;quot;池子&amp;quot;（容器）里面，来了任务可以用已有的空闲的线程进行处理， 处理完成之后，归还到容器，可以复用。如果线程不够，还可以根据规则动态增加，线程多余的时候，亦可以让多余的线程死亡。&lt;/p&gt;\n&lt;h3 id=\&#34;为什么要用线程池\&#34;&gt;为什么要用线程池？&lt;/h3&gt;\n&lt;p&gt;实现线程池有什么好处呢？&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;降低资源消耗：池化技术可以重复利用已经创建的线程，降低线程创建和销毁的损耗。&lt;/li&gt;\n&lt;li&gt;提高响应速度：利用已经存在的线程进行处理，少去了创建线程的时间&lt;/li&gt;\n&lt;li&gt;管理线程可控：线程是稀缺资源，不能无限创建，线程池可以做到统一分配和监控&lt;/li&gt;\n&lt;li&gt;拓展其他功能：比如定时线程池，可以定时执行任务&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;需要考虑的点\&#34;&gt;需要考虑的点&lt;/h3&gt;\n&lt;p&gt;那线程池设计需要考虑的点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;线程池状态：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;有哪些状态？如何维护状态？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;线程&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;线程怎么封装？线程放在哪个池子里？&lt;/li&gt;\n&lt;li&gt;线程怎么取得任务？&lt;/li&gt;\n&lt;li&gt;线程有哪些状态？&lt;/li&gt;\n&lt;li&gt;线程的数量怎么限制？动态变化？自动伸缩？&lt;/li&gt;\n&lt;li&gt;线程怎么消亡？如何重复利用？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;任务&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;任务少可以直接处理，多的时候，放在哪里？&lt;/li&gt;\n&lt;li&gt;任务队列满了，怎么办？&lt;/li&gt;\n&lt;li&gt;用什么队列？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;如果从任务的阶段来看，分为以下几个阶段：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;如何存任务？&lt;/li&gt;\n&lt;li&gt;如何取任务？&lt;/li&gt;\n&lt;li&gt;如何执行任务？&lt;/li&gt;\n&lt;li&gt;如何拒绝任务？&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;线程池状态\&#34;&gt;线程池状态&lt;/h2&gt;\n&lt;h3 id=\&#34;状态有哪些如何维护状态\&#34;&gt;状态有哪些？如何维护状态？&lt;/h3&gt;\n&lt;p&gt;状态可以设置为以下几种：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;RUNNING：运行状态，可以接受任务，也可以处理任务&lt;/li&gt;\n&lt;li&gt;SHUTDOWN：不可以接受任务，但是可以处理任务&lt;/li&gt;\n&lt;li&gt;STOP：不可以接受任务，也不可以处理任务，中断当前任务&lt;/li&gt;\n&lt;li&gt;TIDYING：所有线程停止&lt;/li&gt;\n&lt;li&gt;TERMINATED：线程池的最后状态&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;各种状态之间是不一样的，他们的状态之间变化如下：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20210619211431.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;而维护状态的话，可以用一个变量单独存储，并且需要保证修改时的&lt;strong&gt;原子性&lt;/strong&gt;，在底层操作系统中，对int的修改是原子的，而在32位的操作系统里面，对&lt;code&gt;double&lt;/code&gt;,&lt;code&gt;long&lt;/code&gt;这种64位数值的操作不是原子的。&lt;strong&gt;除此之外，实际上JDK里面实现的状态和线程池的线程数是同一个变量，高3位表示线程池的状态，而低29位则表示线程的数量。&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;这样设计的好处是节省空间，并且同时更新的时候有优势。&lt;/p&gt;\n&lt;h2 id=\&#34;线程相关\&#34;&gt;线程相关&lt;/h2&gt;\n&lt;h3 id=\&#34;线程怎么封装线程放在哪个池子里\&#34;&gt;线程怎么封装？线程放在哪个池子里？&lt;/h3&gt;\n&lt;p&gt;线程，即是实现了&lt;code&gt;Runnable&lt;/code&gt;接口，执行的时候，调用的是&lt;code&gt;start()&lt;/code&gt;方法，但是&lt;code&gt;start()&lt;/code&gt;方法内部编译后调用的是 &lt;code&gt;run()&lt;/code&gt; 方法，这个方法只能调用一次，调用多次会报错。因此线程池里面的线程跑起来之后，不可能终止再启动，只能一直运行着。&lt;strong&gt;既然不可以停止，那么执行完任务之后，没有任务过来，只能是轮询取出任务的过程&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;线程可以运行任务，因此封装线程的时候，假设封装成为 &lt;code&gt;Worker&lt;/code&gt;, &lt;code&gt;Worker&lt;/code&gt;里面必定是包含一个 &lt;code&gt;Thread&lt;/code&gt;,表示当前线程，除了当前线程之外，封装的线程类还应该持有任务，初始化可能直接给予任务，当前的任务是null的时候才需要去获取任务。&lt;/p&gt;\n&lt;p&gt;可以考虑使用 &lt;code&gt;HashSet&lt;/code&gt; 来存储线程，也就是充当线程池的角色，当然，&lt;code&gt;HashSet&lt;/code&gt; 会有线程安全的问题需要考虑，那么我们可以考虑使用一个可重入锁比如 &lt;code&gt;ReentrantLock&lt;/code&gt;，凡是增删线程池的线程，都需要锁住。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    private final ReentrantLock mainLock = new ReentrantLock();\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;线程怎么取得任务\&#34;&gt;线程怎么取得任务？&lt;/h3&gt;\n&lt;p&gt;（1）初始化线程的时候可以直接指定任务，譬如&lt;code&gt;Runnable firstTask&lt;/code&gt;，将任务封装到 &lt;code&gt;worker&lt;/code&gt; 中，然后获取 &lt;code&gt;worker&lt;/code&gt; 里面的 &lt;code&gt;thread&lt;/code&gt;，&lt;code&gt;thread.run()&lt;/code&gt;的时候，其实就是 跑的是 &lt;code&gt;worker&lt;/code&gt; 本身的 &lt;code&gt;run()&lt;/code&gt; 方法，因为 &lt;code&gt;worker&lt;/code&gt; 本身就是实现了 &lt;code&gt;Runnable&lt;/code&gt; 接口，里面的线程其实就是其本身。因此也可以实现对 &lt;code&gt;ThreadFactory&lt;/code&gt; 线程工厂的定制化。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-java\&#34;&gt;    private final class Worker\n        extends AbstractQueuedSynchronizer\n        implements Runnable\n    {\n        final Thread thread;\n        Runnable firstTask;\n\n        ...\n\n        Worker(Runnable firstTask) {\n            setState(-1); // inhibit interrupts until runWorker\n            this.firstTask = firstTask;\n            // 从线程池创建线程，传入的是其本身\n            this.thread = getThreadFactory().newThread(this);\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;（2）运行完任务的线程，应该继续取任务，取任务肯定需要从任务队列里面取，要是任务队列里面没有任务，由于是阻塞队列，那么可以等待，如果等待若干时间后，仍没有任务，倘若该线程池的线程数已经超过核心线程数，并且允许线程消亡的话，应该将该线程从线程池中移除，并结束掉该线程。&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;取任务和执行任务，对于线程池里面的线程而言，就是一个周而复始的工作，除非它会消亡。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h3 id=\&#34;线程有哪些状态\&#34;&gt;线程有哪些状态？&lt;/h3&gt;\n&lt;p&gt;现在我们所说的是&lt;code&gt;Java&lt;/code&gt;中的线程&lt;code&gt;Thread&lt;/code&gt;,一个线程在一个给定的时间点，只能处于一种状态，这些状态都是虚拟机的状态，不能反映任何操作系统的线程状态，一共有六种/七种状态：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;NEW&lt;/code&gt;：创建了线程对象，但是还没有调用&lt;code&gt;Start()&lt;/code&gt;方法，还没有启动的线程处于这种状态。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;Running&lt;/code&gt;：运行状态，其实包含了两种状态，但是&lt;code&gt;Java&lt;/code&gt;线程将就绪和运行中统称为可运行&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;Runnable&lt;/code&gt;：就绪状态：创建对象后，调用了&lt;code&gt;start()&lt;/code&gt;方法，该状态的线程还位于可运行线程池中，等待调度，获取&lt;code&gt;CPU&lt;/code&gt;的使用权\n&lt;ul&gt;\n&lt;li&gt;只是有资格执行，不一定会执行&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;start()&lt;/code&gt;之后进入就绪状态，&lt;code&gt;sleep()&lt;/code&gt;结束或者&lt;code&gt;join()&lt;/code&gt;结束，线程获得对象锁等都会进入该状态。&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt;时间片结束或者主动调用&lt;code&gt;yield()&lt;/code&gt;方法，也会进入该状态&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;code&gt;Running&lt;/code&gt; ：获取到&lt;code&gt;CPU&lt;/code&gt;的使用权（获得CPU时间片），变成运行中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;BLOCKED&lt;/code&gt; ：阻塞，线程阻塞于锁，等待监视器锁，一般是&lt;code&gt;Synchronize&lt;/code&gt;关键字修饰的方法或者代码块&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;WAITING&lt;/code&gt; ：进入该状态，需要等待其他线程通知（&lt;code&gt;notify&lt;/code&gt;）或者中断，一个线程无限期地等待另一个线程。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;TIMED_WAITING&lt;/code&gt; ：超时等待，在指定时间后自动唤醒，返回，不会一直等待&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;&lt;code&gt;TERMINATED&lt;/code&gt; ：线程执行完毕，已经退出。如果已终止再调用start()，将会抛出&lt;code&gt;java.lang.IllegalThreadStateException&lt;/code&gt;异常。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20210509224848865.png\&#34; alt=\&#34;image-20210509224848865\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;线程的数量怎么限制动态变化自动伸缩\&#34;&gt;线程的数量怎么限制？动态变化？自动伸缩？&lt;/h3&gt;\n&lt;p&gt;线程池本身，就是为了限制和充分使用线程资的，因此有了两个概念：核心线程数，最大线程数。&lt;/p&gt;\n&lt;p&gt;要想让线程数根据任务数量动态变化，那么我们可以考虑以下设计（假设不断有任务）：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;来一个任务创建一个线程处理，直到线程数达到核心线程数。&lt;/li&gt;\n&lt;li&gt;达到核心线程数之后且没有空闲线程，来了任务直接放到任务队列。&lt;/li&gt;\n&lt;li&gt;任务队列如果是无界的，会被撑爆。&lt;/li&gt;\n&lt;li&gt;任务队列如果是有界的，任务队列满了之后，还有任务过来，会继续创建线程处理，此时线程数大于核心线程数，直到线程数等于最大线程数。&lt;/li&gt;\n&lt;li&gt;达到最大线程数之后，还有任务不断过来，会触发拒绝策略，根据不同策略进行处理。&lt;/li&gt;\n&lt;li&gt;如果任务不断处理完成，任务队列空了，线程空闲没任务，会在一定时间内，销毁，让线程数保持在核心线程数即可。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;由上面可以看出，主要控制伸缩的参数是&lt;code&gt;核心线程数&lt;/code&gt;，&lt;code&gt;最大线程数&lt;/code&gt;,&lt;code&gt;任务队列&lt;/code&gt;,&lt;code&gt;拒绝策略&lt;/code&gt;。&lt;/p&gt;\n&lt;h3 id=\&#34;线程怎么消亡如何重复利用\&#34;&gt;线程怎么消亡？如何重复利用？&lt;/h3&gt;\n&lt;p&gt;线程不能被重新调用多次&lt;code&gt;start()&lt;/code&gt;，因此只能调用一次，也就是线程不可能停下来，再启动。那么就说明线程复用只是在不断的循环罢了。&lt;/p&gt;\n&lt;p&gt;消亡只是结束了它的&lt;code&gt;run()&lt;/code&gt;方法，当线程池数量需要自动缩容的，就会让一部分空闲的线程结束。&lt;/p&gt;\n&lt;p&gt;而重复利用，其实是执行完任务之后，再去去任务队列取任务，取不到任务会等待，任务队列是一个阻塞队列，这是一个&lt;code&gt;不断循环&lt;/code&gt;的过程。&lt;/p&gt;\n&lt;h2 id=\&#34;任务相关\&#34;&gt;任务相关&lt;/h2&gt;\n&lt;h3 id=\&#34;任务少可以直接处理多的时候放在哪里\&#34;&gt;任务少可以直接处理，多的时候，放在哪里？&lt;/h3&gt;\n&lt;p&gt;任务少的时候，来了直接创建，赋予线程初始化任务，就可开始执行，任务多的时候，把它放进队列里面，先进先出。&lt;/p&gt;\n&lt;h3 id=\&#34;任务队列满了怎么办\&#34;&gt;任务队列满了，怎么办？&lt;/h3&gt;\n&lt;p&gt;任务队列满了，会继续增加线程，直到达到最大的线程数。&lt;/p&gt;\n&lt;h3 id=\&#34;用什么队列\&#34;&gt;用什么队列？&lt;/h3&gt;\n&lt;p&gt;一般的队列，只是一个有限长度的缓冲区，要是满了，就不能保存当前的任务，阻塞队列可以通过阻塞，保留出当前需要入队的任务，只是会阻塞等待。同样的，阻塞队列也可以保证任务队列没有任务的时候，阻塞当前获取任务的线程，让它进入&lt;code&gt;wait&lt;/code&gt;状态，释放&lt;code&gt;cpu&lt;/code&gt;的资源。因此在线程池的场景下，阻塞队列其实是比较有必要的。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;ru-he-she-ji-yi-ge-xian-cheng-chi&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;blockquote&gt;\n&lt;p&gt;前一段时间在写一门算法课，总算是上线了，以及面试，所以没什么时间写，接下来的时间，应该会讲讲面试准备，刷题的一些东西，面了很多，通过面试的有平安，涂鸦智能，阿里，腾讯微保，虾皮，华为荣耀，微众，当然也有其他不少挂的，挂也正常，面试是一个双向选择，当然，我也还是个菜鸟。&lt;/p&gt;\n&lt;/blockquote&gt;\n&#34;,&#34;title&#34;:&#34;如何设计一个线程池？&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;线程池&#34;,&#34;slug&#34;:&#34;S8fse4uyb&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/S8fse4uyb/&#34;}],&#34;date&#34;:&#34;2023-03-02 00:08:18&#34;,&#34;dateFormat&#34;:&#34;2023-03-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/ru-he-she-ji-yi-ge-xian-cheng-chi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;10 min read&#34;,&#34;time&#34;:562000,&#34;words&#34;:2719,&#34;minutes&#34;:10},&#34;description&#34;:&#34;\n\n前一段时间在写一门算法课，总算是上线了，以及面试，所以没什么时间写，接下来的时间，应该会讲讲面试准备，刷题的一些东西，面了很多，通过面试的有平安，涂鸦智能，阿里，腾讯微保，虾皮，华为荣耀，微众，当然也有其他不少挂的，挂也正常，面试是一个...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0\&#34;&gt;如何设计一个线程池？&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4\&#34;&gt;三个步骤&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E4%BB%80%E4%B9%88\&#34;&gt;线程池是什么？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0\&#34;&gt;为什么要用线程池？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E7%9A%84%E7%82%B9\&#34;&gt;需要考虑的点&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81\&#34;&gt;线程池状态&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81\&#34;&gt;状态有哪些？如何维护状态？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3\&#34;&gt;线程相关&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%B0%81%E8%A3%85%E7%BA%BF%E7%A8%8B%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%B1%A0%E5%AD%90%E9%87%8C\&#34;&gt;线程怎么封装？线程放在哪个池子里？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%8F%96%E5%BE%97%E4%BB%BB%E5%8A%A1\&#34;&gt;线程怎么取得任务？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81\&#34;&gt;线程有哪些状态？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%E6%80%8E%E4%B9%88%E9%99%90%E5%88%B6%E5%8A%A8%E6%80%81%E5%8F%98%E5%8C%96%E8%87%AA%E5%8A%A8%E4%BC%B8%E7%BC%A9\&#34;&gt;线程的数量怎么限制？动态变化？自动伸缩？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E6%B6%88%E4%BA%A1%E5%A6%82%E4%BD%95%E9%87%8D%E5%A4%8D%E5%88%A9%E7%94%A8\&#34;&gt;线程怎么消亡？如何重复利用？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1%E7%9B%B8%E5%85%B3\&#34;&gt;任务相关&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1%E5%B0%91%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E5%A4%84%E7%90%86%E5%A4%9A%E7%9A%84%E6%97%B6%E5%80%99%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C\&#34;&gt;任务少可以直接处理，多的时候，放在哪里？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E\&#34;&gt;任务队列满了，怎么办？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%A8%E4%BB%80%E4%B9%88%E9%98%9F%E5%88%97\&#34;&gt;用什么队列？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;周末无聊，用&lt;code&gt;Java&lt;/code&gt;写了一个扫雷程序，说起来，这个应该是在学校的时候，写会比较好玩，毕竟自己实现一个小游戏，还是比较好玩的。说实话，扫雷程序里面核心的东西，只有点击的时候，去触发更新数据这一步。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;&lt;strong&gt;Swing 是过时了，但是好玩不会过时，不喜勿喷&lt;/strong&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211229084104.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;源码的地址：https://github.com/Damaer/Game/tree/main/SweepMine&lt;/p&gt;\n&lt;p&gt;下面讲讲里面的设计：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;数据结构设计&lt;/li&gt;\n&lt;li&gt;视图和数据尽可能分开&lt;/li&gt;\n&lt;li&gt;点击时候使用&lt;code&gt;BFS&lt;/code&gt;扫描&lt;/li&gt;\n&lt;li&gt;判断成功失败&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;数据结构设计\&#34;&gt;数据结构设计&lt;/h1&gt;\n&lt;p&gt;在这个程序里面，为了方便，使用了全局的数据类&lt;code&gt;Data&lt;/code&gt;类来维护整个游戏的数据，直接设置为静态变量，也就是一次只能有一个游戏窗口运行，否则会有数据安全问题。（仅仅是为了方便）&lt;/p&gt;\n&lt;p&gt;有以下的数据(部分代码)：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;public class Data {\n    // 游戏状态\n    public static Status status = Status.LOADING;\n    // 雷区大小\n    public static int size = 16;\n    // 雷的数量\n    public static int numOfMine = 0;\n    // 表示是否有雷，1：有，0没有\n    public static int[][] maps = null;\n    // 是否被访问\n    public static boolean[][] visited = null;\n    // 周边雷的数量\n    public static int[][] nums = null;\n    // 是否被标记\n    public static boolean[][] flags = null;\n    // 上次被访问的块坐标\n    public static Point lastVisitedPoint = null;\n    // 困难模式\n    private static DifficultModeEnum mode;\n  \t...\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;需要维护的数据如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;游戏状态：是否开始，结束，成功，失败等等&lt;/li&gt;\n&lt;li&gt;模式：简单，中等或者困难，这个会影响自动生成的雷的数量&lt;/li&gt;\n&lt;li&gt;雷区的大小：16*16的小方块&lt;/li&gt;\n&lt;li&gt;雷的数量：与模式选择有关，是个随机数&lt;/li&gt;\n&lt;li&gt;标识每个方块是否有雷：最基础的数据，生成之后需要同步更新这个数据&lt;/li&gt;\n&lt;li&gt;标识每个方块是否被扫过：默认没有扫过&lt;/li&gt;\n&lt;li&gt;每个方块周边类雷的数量：生成的时候同步计算该结果，不想每次点击后再计算，毕竟是个不会更新的数据，一劳永逸&lt;/li&gt;\n&lt;li&gt;标识方块是否被标记：扫雷的时候我们使用小旗子标记方块，表示这里是雷，标识完所有的雷的时候，成功&lt;/li&gt;\n&lt;li&gt;上次访问的方块坐标：这个其实可以不记录，但是为了表示爆炸效果，与其他的雷展示不一样，故而记录下来&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;视图与数据分开\&#34;&gt;视图与数据分开&lt;/h1&gt;\n&lt;p&gt;尽量遵循一个原则，视图与数据或者数据变更分开，方便维护。我们知道&lt;code&gt;Java&lt;/code&gt;里面是用&lt;code&gt;Swing&lt;/code&gt;来画图形界面，这个东西确实难画，视图写得比较复杂但是画不出什么东西。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211229090112.gif\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;视图与数据分开，也是几乎所有框架的优秀特点，主要是方便维护，如果视图和数据糅合在一起，更新数据，还要操作视图，那就会比较乱。（当然我写的是粗糙版本，只是简单区分了一下）&lt;/p&gt;\n&lt;p&gt;在这个扫雷程序里面基本都是点击事件，触发了数据变更，数据变更后，调用视图刷新，视图渲染的逻辑与数据变更的逻辑分开维护。&lt;/p&gt;\n&lt;p&gt;每个小方块都添加了点击事件,&lt;code&gt;Data.visit(x, y)&lt;/code&gt;是数据刷新，&lt;code&gt;repaintBlocks()&lt;/code&gt;是刷新视图，具体的代码就不放了，有兴趣可以&lt;code&gt;Github&lt;/code&gt;看看源代码:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;new MouseListener() {\n                    @Override\n                    public void mouseClicked(MouseEvent e) {\n                        if (Data.status == Status.GOING) {\n                            int c = e.getButton(); // 得到按下的鼠标键\n                            Block block = (Block) e.getComponent();\n                            int x = block.getPoint_x();\n                            int y = block.getPoint_y();\n                            if (c == MouseEvent.BUTTON1) {\n                                Data.visit(x, y);\n                            } else if (c == MouseEvent.BUTTON3) {// 推断是鼠标右键按下\n                                if (!Data.visited[x][y]) {\n                                    Data.flags[x][y] = !Data.flags[x][y];\n                                }\n                            }\n                        }\n                        repaintBlocks();\n                    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这里很遗憾的一点是每个方块里面还有一个背景的``url`没有抽取出来，这个是变化的数据，不应该放在视图里面：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;public class Block extends JPanel {\n    private int point_x;\n    private int point_y;\n\n    private String backgroundPath = ImgPath.DEFAULT;\n\n    public Block(int x, int y) {\n        this.point_x = x;\n        this.point_y = y;\n        setBorder(BorderFactory.createEtchedBorder());\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;重新设置方块背景，需要居中处理，重新绘制，重写&lt;code&gt;void paintComponent(Graphics g)&lt;/code&gt;方法即可：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;    @Override\n    protected void paintComponent(Graphics g) {\n        refreshBackground();\n        URL url = getClass().getClassLoader().getResource(backgroundPath);\n        ImageIcon icon = new ImageIcon(url);\n        if (backgroundPath.equals(ImgPath.DEFAULT) || backgroundPath.equals(ImgPath.FLAG)\n                || backgroundPath.equals(String.format(ImgPath.NUM, 0))) {\n            g.drawImage(icon.getImage(), 0, 0, getWidth(), getHeight(), this);\n        } else {\n            int x = (int) (getWidth() * 0.1);\n            int y = (int) (getHeight() * 0.15);\n            g.drawImage(icon.getImage(), x, y, getWidth() - 2 * x, getHeight() - 2 * y, this);\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h1 id=\&#34;bfs扫描\&#34;&gt;BFS扫描&lt;/h1&gt;\n&lt;p&gt;&lt;code&gt;BFS&lt;/code&gt;，也称为广度优先搜索，这算是扫雷里面的核心知识点，也就是点击的时候，如果当前方块是空的，那么就会触发扫描周边的方块，同时周边方块如果也是空的，会继续递归下去，我用了广度优先搜索，也就是先将它们放到队列里面，取出来，再判断是否为空，再将周边符合的方块添加进去，进行一一处理。&lt;/p&gt;\n&lt;p&gt;广度优先搜索在这里不展开，其本质是优先搜索与其直接关联的数据，也就是方块周围的点，这也是为什么需要队列的原因，我们需要队列来保存遍历的顺序。&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-Java\&#34;&gt;    public static void visit(int x, int y) {\n        lastVisitedPoint.x = x;\n        lastVisitedPoint.y = y;\n        if (maps[x][y] == 1) {\n            status = Status.FAILED;\n            // 游戏结束，暴露所有的雷\n        } else {\n            // 点击的不是雷\n            Queue&amp;lt;Point&amp;gt; points = new LinkedList&amp;lt;&amp;gt;();\n            points.add(new Point(x, y));\n            while (!points.isEmpty()) {\n                Point point = points.poll();\n                visited[point.x][point.y] = true;\n                if (nums[point.x][point.y] == 0) {\n                    addToVisited(points, point.x, point.y);\n                }\n            }\n        }\n    }\n\n    public static void addToVisited(Queue&amp;lt;Point&amp;gt; points, int i, int j) {\n        int x = i - 1;\n        while (x &amp;lt;= i + 1) {\n            if (x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; size) {\n                int y = j - 1;\n                while (y &amp;lt;= j + 1) {\n                    if (y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; size) {\n                        if (!(x == i &amp;amp;&amp;amp; j == y)) {\n                            // 没访问过且不是雷\n                            if (!visited[x][y] &amp;amp;&amp;amp; maps[x][y] == 0) {\n                                points.add(new Point(x, y));\n                            }\n                        }\n                    }\n                    y++;\n                }\n            }\n            x++;\n        }\n    }\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;值得注意的是，周边的点，如果它的周边没有雷，那么会继续拓展，但是只要周边有雷，就会停止拓展，只会显示数字。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211229091520.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h1 id=\&#34;判断成功失败\&#34;&gt;判断成功失败&lt;/h1&gt;\n&lt;p&gt;当挖到雷的时候，就失败了，同时会将所有的雷暴露出来，为了展示我们当前挖到的点，有爆炸效果，我们记录了上一步操作的点，在刷新视图后，弹窗提示：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/image-20211229091811385.png\&#34; alt=\&#34;image-20211229091811385\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;判断成功则需要将所有的雷遍历一次，判断是否被标记出来，这是我简单想的规则，忘记了扫雷是不是这样了，或者可以实现将其他所有非雷区都挖空的时候，成功，也是可以的。&lt;/p&gt;\n&lt;h1 id=\&#34;总结\&#34;&gt;总结&lt;/h1&gt;\n&lt;p&gt;扫雷，一个简单的游戏，无聊的时候可以尝试一下，但是&lt;code&gt;Java&lt;/code&gt; 的&lt;code&gt;Swing&lt;/code&gt;真的难用，想找一个数据驱动视图修改的框架，但是貌似没有，那就简单实现一下。其实大部分时间都在找图标，测试&lt;code&gt;UI&lt;/code&gt;，核心的代码并没有多少。&lt;/p&gt;\n&lt;p&gt;在这里推荐一下&lt;code&gt;icon&lt;/code&gt;网站：&lt;code&gt;https://www.iconfont.cn/&lt;/code&gt;,即使是没有什么技术含量的扫雷，写一下还是挺有趣的。&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;【作者简介】&lt;/strong&gt;：&lt;br&gt;\n秦怀，公众号【&lt;strong&gt;秦怀杂货店&lt;/strong&gt;】作者，个人网站：http://aphysia.cn，技术之路不在一时，山高水长，纵使缓慢，驰而不息。&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;http://aphysia.cn/archives/jianzhiofferpdf\&#34;&gt;剑指Offer全部题解PDF&lt;/a&gt;&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;wu-liao-yong-java-xie-liao-ge-sao-lei&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;周末无聊，用&lt;code&gt;Java&lt;/code&gt;写了一个扫雷程序，说起来，这个应该是在学校的时候，写会比较好玩，毕竟自己实现一个小游戏，还是比较好玩的。说实话，扫雷程序里面核心的东西，只有点击的时候，去触发更新数据这一步。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;无聊用Java写了个扫雷&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;游戏&#34;,&#34;slug&#34;:&#34;rEI471LrM&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/rEI471LrM/&#34;}],&#34;date&#34;:&#34;2023-01-07 00:40:50&#34;,&#34;dateFormat&#34;:&#34;2023-01-07&#34;,&#34;feature&#34;:&#34;https://aphysia.cn/post-images/wu-liao-yong-java-xie-liao-ge-sao-lei.png&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/wu-liao-yong-java-xie-liao-ge-sao-lei/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;8 min read&#34;,&#34;time&#34;:428000,&#34;words&#34;:1808,&#34;minutes&#34;:8},&#34;description&#34;:&#34;\n周末无聊，用Java写了一个扫雷程序，说起来，这个应该是在学校的时候，写会比较好玩，毕竟自己实现一个小游戏，还是比较好玩的。说实话，扫雷程序里面核心的东西，只有点击的时候，去触发更新数据这一步。\n\nSwing 是过时了，但是好玩不会过时，...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1\&#34;&gt;数据结构设计&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%86%E5%9B%BE%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%88%86%E5%BC%80\&#34;&gt;视图与数据分开&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#bfs%E6%89%AB%E6%8F%8F\&#34;&gt;BFS扫描&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%A4%E6%96%AD%E6%88%90%E5%8A%9F%E5%A4%B1%E8%B4%A5\&#34;&gt;判断成功失败&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%80%BB%E7%BB%93\&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h1 id=\&#34;作者简介\&#34;&gt;作者简介&lt;/h1&gt;\n&lt;p&gt;秦怀，公众号【&lt;strong&gt;秦怀杂货店&lt;/strong&gt;】作者，个人网站：http://aphysia.cn，技术之路不在一时，山高水长，纵使缓慢，驰而不息。&lt;/p&gt;\n&lt;p&gt;会一点 Java 和 Go，目前就职国内一家头部互联网公司，主要是支付方向。&lt;/p&gt;\n&lt;h1 id=\&#34;数据结构与算法\&#34;&gt;数据结构与算法&lt;/h1&gt;\n&lt;p&gt;快速解数据结构，可以看看： &lt;a href=\&#34;https://aphysia.cn/post/man-you-shu-ju-jie-gou-shi-jie/\&#34;&gt;万字长文解说数据结构&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://juejin.cn/column/6963836588627329060\&#34;&gt;剑指Offer系列&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;&lt;a href=\&#34;https://github.com/Damaer/CodeSolution\&#34;&gt;刷题仓库&lt;/a&gt;&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20211208224819.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于作者&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2023-01-06 23:50:50&#34;,&#34;dateFormat&#34;:&#34;2023-01-06&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:22000,&#34;words&#34;:108,&#34;minutes&#34;:1},&#34;description&#34;:&#34;作者简介\n秦怀，公众号【秦怀杂货店】作者，个人网站：http://aphysia.cn，技术之路不在一时，山高水长，纵使缓慢，驰而不息。\n会一点 Java 和 Go，目前就职国内一家头部互联网公司，主要是支付方向。\n数据结构与算法\n快速解数...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BD%9C%E8%80%85%E7%AE%80%E4%BB%8B\&#34;&gt;作者简介&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95\&#34;&gt;数据结构与算法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;以前写 Java 的时候，听到前端同学谈论闭包，觉得甚是新奇，后面自己写了一小段时间 JS，虽只学到皮毛，也大概了解到闭包的概念，现在工作常用语言是 Go，很多优雅的代码中总是有闭包的身影，看来不了解个透是不可能的了，本文让我来科普(按照自己水平随便瞎扯)一下：&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;1-什么是闭包\&#34;&gt;1、什么是闭包？&lt;/h1&gt;\n&lt;p&gt;在真正讲述闭包之前，我们先铺垫一点知识点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;函数式编程&lt;/li&gt;\n&lt;li&gt;函数作用域&lt;/li&gt;\n&lt;li&gt;作用域的继承关系&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;11-前提知识铺垫\&#34;&gt;1.1 前提知识铺垫&lt;/h2&gt;\n&lt;h3 id=\&#34;121-函数式编程\&#34;&gt;1.2.1 函数式编程&lt;/h3&gt;\n&lt;p&gt;函数式编程是一种编程范式，看待问题的一种方式，每一个函数都是为了用小函数组织成为更大的函数，函数的参数也是函数，函数返回的也是函数。我们常见的编程范式有：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;命令式编程：\n&lt;ul&gt;\n&lt;li&gt;主要思想为：关注计算机执行的步骤，也就是一步一步告诉计算机先做什么再做什么。&lt;/li&gt;\n&lt;li&gt;先把解决问题步骤规范化，抽象为某种算法，然后编写具体的算法去实现，一般只要支持过程化编程范式的语言，我们都可以称为过程化编程语言，比如 BASIC，C 等。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;声明式编程：\n&lt;ul&gt;\n&lt;li&gt;主要思想为：告诉计算机应该做什么，但是不指定具体要怎么做，比如 SQL，网页编程的 HTML，CSS。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;函数式编程：\n&lt;ul&gt;\n&lt;li&gt;只关注做什么而不关注怎么做，有一丝丝声明式编程的影子，但是更加侧重于”函数是第一位“的原则，也就是函数可以出现在任何地方，参数、变量、返回值等等。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;函数式编程可以认为是面向对象编程的对立面，一般只有一些编程语言会强调一种特定的编程方式，大多数的语言都是多范式语言，可以支持多种不同的编程方式，比如 JavaScript ，Go 等。&lt;/p&gt;\n&lt;p&gt;函数式编程是一种思维方式，将电脑运算视为函数的计算，是一种写代码的方法论，&lt;strong&gt;其实我应该聊函数式编程，然后再聊到闭包，因为闭包本身就是函数式编程里面的一个特点之一。&lt;/strong&gt;&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;在函数式编程中，函数是&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%AF%B9%E8%B1%A1\&#34;&gt;头等对象&lt;/a&gt;，意思是说一个函数，既可以作为其它函数的输入参数值，也可以从函数中返回值，被修改或者被分配给一个变量。(维基百科)&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;一般纯函数编程语言是不允许直接使用程序状态以及可变对象的，函数式编程本身就是要避免使用 &lt;strong&gt;共享状态&lt;/strong&gt;，&lt;strong&gt;可变状态&lt;/strong&gt;，尽可能避免产生 &lt;strong&gt;副作用&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;函数式编程一般具有以下特点：&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;\n&lt;p&gt;函数是第一等公民：函数的地位放在第一位，可以作为参数，可以赋值，可以传递，可以当做返回值。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;没有副作用：函数要保持纯粹独立，不能修改外部变量的值，不修改外部状态。&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;引用透明：函数运行不依赖外部变量或者状态，相同的输入参数，任何情况，所得到的返回值都应该是一样的。&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h3 id=\&#34;122-函数作用域\&#34;&gt;1.2.2 函数作用域&lt;/h3&gt;\n&lt;p&gt;&lt;strong&gt;作用域&lt;/strong&gt;（scope），程序设计概念，通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的&lt;em&gt;作用域&lt;/em&gt;。&lt;/p&gt;\n&lt;p&gt;通俗易懂的说，函数作用域是指函数可以起作用的范围。函数有点像盒子，一层套一层，作用域我们可以理解为是个封闭的盒子，也就是函数的局部变量，只能在盒子内部使用，成为独立作用域。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://gitee.com/Damaer/pic/raw/master/image-20221112163921104.png\&#34; alt=\&#34;image-20221112163921104\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;函数内的局部变量，出了函数就跳出了作用域，找不到该变量。（里层函数可以使用外层函数的局部变量，因为外层函数的作用域包括了里层函数），比如下面的 &lt;code&gt;innerTmep&lt;/code&gt; 出了函数作用域就找不到该变量，但是 &lt;code&gt;outerTemp&lt;/code&gt; 在内层函数里面还是可以使用。&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://gitee.com/Damaer/pic/raw/master/image-20221112164640101.png\&#34; alt=\&#34;image-20221112164640101\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;不管是任何语言，基本存在一定的内存回收机制，也就是回收用不到的内存空间，回收的机制一般和上面说的函数的作用域是相关的，局部变量出了其作用域，就有可能被回收，如果还被引用着，那么就不会被回收。&lt;/p&gt;\n&lt;h3 id=\&#34;123-作用域的继承关系\&#34;&gt;1.2.3 作用域的继承关系&lt;/h3&gt;\n&lt;p&gt;所谓作用域继承，就是前面说的小盒子可以继承外层大盒子的作用域，在小盒子可以直接取出大盒子的东西，但是大盒子不能取出小盒子的东西，除非发生了逃逸（逃逸可以理解为小盒子的东西给出了引用，大盒子拿到就可以使用）。一般而言，变量的作用域有以下两种：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;全局作用域：作用于任何地方&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;局部作用域：一般是代码块，函数、包内，&lt;strong&gt;函数内部&lt;/strong&gt;声明/定义的变量叫&lt;strong&gt;局部变量&lt;/strong&gt;，&lt;strong&gt;作用域仅限于函数内部&lt;/strong&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;12-闭包的定义\&#34;&gt;1.2 闭包的定义&lt;/h2&gt;\n&lt;p&gt;“多数情况下我们并不是先理解后定义，而是先定义后理解“，先下定义，&lt;strong&gt;读不懂没关系&lt;/strong&gt;：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;闭包（closure）是&lt;strong&gt;一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合&lt;/strong&gt;。 换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。 闭包会随着函数的创建而被同时创建。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;一句话表述：&lt;/p&gt;\n&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=\&#34;katex-display\&#34;&gt;&lt;span class=\&#34;katex\&#34;&gt;&lt;span class=\&#34;katex-mathml\&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;闭&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;包&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;函&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;数&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;引&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;用&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;环&lt;/mi&gt;&lt;mi mathvariant=\&#34;normal\&#34;&gt;境&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=\&#34;application/x-tex\&#34;&gt;闭包 = 函数 + 引用环境\n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=\&#34;katex-html\&#34; aria-hidden=\&#34;true\&#34;&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.36687em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;闭&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;包&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mrel\&#34;&gt;=&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2777777777777778em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0.66666em;vertical-align:-0.08333em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;函&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;数&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mbin\&#34;&gt;+&lt;/span&gt;&lt;span class=\&#34;mspace\&#34; style=\&#34;margin-right:0.2222222222222222em;\&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=\&#34;base\&#34;&gt;&lt;span class=\&#34;strut\&#34; style=\&#34;height:0em;vertical-align:0em;\&#34;&gt;&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;引&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;用&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;环&lt;/span&gt;&lt;span class=\&#34;mord cjk_fallback\&#34;&gt;境&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;p&gt;以上定义找不到 Go语言 这几个字眼，聪明的同学肯定知道，闭包是和语言无关的，不是 JavaScript 特有的，也不是 Go 特有的，而是&lt;strong&gt;函数式编程语言&lt;/strong&gt;的特有的，是的，你没有看错，&lt;strong&gt;任何支持函数式编程的语言都支持闭包，Go 和 JavaScript 就是其中之二， 目前 Java 目前版本也是支持闭包的&lt;/strong&gt;，但是有些人可能认为不是完美的闭包，详细情况文中讨论。&lt;/p&gt;\n&lt;h2 id=\&#34;13-闭包的写法\&#34;&gt;1.3 闭包的写法&lt;/h2&gt;\n&lt;h3 id=\&#34;131-初看闭包\&#34;&gt;1.3.1 初看闭包&lt;/h3&gt;\n&lt;p&gt;下面是一段闭包的代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;import &amp;quot;fmt&amp;quot;\n\nfunc main() {\n\tsumFunc := lazySum([]int{1, 2, 3, 4, 5})\n\tfmt.Println(&amp;quot;等待一会&amp;quot;)\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())\n}\nfunc lazySum(arr []int) func() int {\n\tfmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)\n\tvar sum = func() int {\n\t\tfmt.Println(&amp;quot;求结果...&amp;quot;)\n\t\tresult := 0\n\t\tfor _, v := range arr {\n\t\t\tresult = result + v\n\t\t}\n\t\treturn result\n\t}\n\treturn sum\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出的结果：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;先获取函数，不求结果\n等待一会\n求结果...\n结果： 15\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看出，里面的 &lt;code&gt;sum()&lt;/code&gt; 方法可以引用外部函数 &lt;code&gt;lazySum()&lt;/code&gt; 的参数以及局部变量，在&lt;code&gt;lazySum()&lt;/code&gt;返回函数 &lt;code&gt;sum()&lt;/code&gt; 的时候，相关的参数和变量都保存在返回的函数中，可以之后再进行调用。&lt;/p&gt;\n&lt;p&gt;上面的函数或许还可以更进一步，体现出捆绑函数和其周围的状态，我们加上一个次数 &lt;code&gt;count&lt;/code&gt;：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;import &amp;quot;fmt&amp;quot;\n\nfunc main() {\n\tsumFunc := lazySum([]int{1, 2, 3, 4, 5})\n\tfmt.Println(&amp;quot;等待一会&amp;quot;)\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())\n}\n\nfunc lazySum(arr []int) func() int {\n\tfmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)\n\tcount := 0\n\tvar sum = func() int {\n\t\tcount++\n\t\tfmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求结果...&amp;quot;)\n\t\tresult := 0\n\t\tfor _, v := range arr {\n\t\t\tresult = result + v\n\t\t}\n\t\treturn result\n\t}\n\treturn sum\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面代码输出什么呢？次数 &lt;code&gt;count&lt;/code&gt; 会不会发生变化，&lt;code&gt;count&lt;/code&gt;明显是外层函数的局部变量，但是在内存函数引用（捆绑），内层函数被暴露出去了，执行结果如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;先获取函数，不求结果\n等待一会\n第 1 次求结果...\n结果： 15\n第 2 次求结果...\n结果： 15\n第 3 次求结果...\n结果： 15\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;结果是 &lt;code&gt;count&lt;/code&gt; 其实每次都会变化，这种情况总结一下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;函数体内嵌套了另外一个函数，并且返回值是一个函数。&lt;/li&gt;\n&lt;li&gt;内层函数被暴露出去，被&lt;strong&gt;外层函数以外&lt;/strong&gt;的地方引用着，形成了闭包。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;此时有人可能有疑问了，前面是&lt;code&gt;lazySum（）&lt;/code&gt;被创建了 1 次，执行了 3 次，但是如果是 3 次执行都是不同的创建，会是怎么样呢？实验一下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;import &amp;quot;fmt&amp;quot;\n\nfunc main() {\n\tsumFunc := lazySum([]int{1, 2, 3, 4, 5})\n\tfmt.Println(&amp;quot;等待一会&amp;quot;)\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())\n\n\tsumFunc1 := lazySum([]int{1, 2, 3, 4, 5})\n\tfmt.Println(&amp;quot;等待一会&amp;quot;)\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc1())\n\n\tsumFunc2 := lazySum([]int{1, 2, 3, 4, 5})\n\tfmt.Println(&amp;quot;等待一会&amp;quot;)\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc2())\n}\n\nfunc lazySum(arr []int) func() int {\n\tfmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)\n\tcount := 0\n\tvar sum = func() int {\n\t\tcount++\n\t\tfmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求结果...&amp;quot;)\n\t\tresult := 0\n\t\tfor _, v := range arr {\n\t\t\tresult = result + v\n\t\t}\n\t\treturn result\n\t}\n\treturn sum\n}\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行的结果如下，每次执行都是第 1 次：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;先获取函数，不求结果\n等待一会\n第 1 次求结果...\n结果： 15\n先获取函数，不求结果\n等待一会\n第 1 次求结果...\n结果： 15\n先获取函数，不求结果\n等待一会\n第 1 次求结果...\n结果： 15\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从以上的执行结果可以看出：&lt;/p&gt;\n&lt;p&gt;&lt;strong&gt;闭包被创建的时候，引用的外部变量&lt;code&gt;count&lt;/code&gt;就已经被创建了 1 份，也就是各自调用是没有关系的&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;继续抛出一个问题，**如果一个函数返回了两个函数，这是一个闭包还是两个闭包呢？**下面我们实践一下：&lt;/p&gt;\n&lt;p&gt;一次返回两个函数，一个用于计算加和的结果，一个计算乘积：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;import &amp;quot;fmt&amp;quot;\n\nfunc main() {\n\tsumFunc, productSFunc := lazyCalculate([]int{1, 2, 3, 4, 5})\n\tfmt.Println(&amp;quot;等待一会&amp;quot;)\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())\n\tfmt.Println(&amp;quot;结果：&amp;quot;, productSFunc())\n}\n\nfunc lazyCalculate(arr []int) (func() int, func() int) {\n\tfmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)\n\tcount := 0\n\tvar sum = func() int {\n\t\tcount++\n\t\tfmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求加和...&amp;quot;)\n\t\tresult := 0\n\t\tfor _, v := range arr {\n\t\t\tresult = result + v\n\t\t}\n\t\treturn result\n\t}\n\n\tvar product = func() int {\n\t\tcount++\n\t\tfmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求乘积...&amp;quot;)\n\t\tresult := 0\n\t\tfor _, v := range arr {\n\t\t\tresult = result * v\n\t\t}\n\t\treturn result\n\t}\n\treturn sum, product\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;先获取函数，不求结果\n等待一会\n第 1 次求加和...\n结果： 15\n第 2 次求乘积...\n结果： 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;从上面结果可以看出，闭包是函数返回函数的时候，不管多少个返回值(函数)，都是一次闭包，如果返回的函数有使用外部函数变量，则会绑定到一起，相互影响：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://gitee.com/Damaer/pic/raw/master/image-20221119001944927.png\&#34; alt=\&#34;image-20221119001944927\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;闭包绑定了周围的状态，我理解此时的函数就拥有了状态，让函数具有了对象所有的能力，函数具有了状态。&lt;/p&gt;\n&lt;h3 id=\&#34;132-闭包中的指针和值\&#34;&gt;1.3.2 闭包中的指针和值&lt;/h3&gt;\n&lt;p&gt;上面的例子，我们闭包中用到的都是数值，如果我们传递指针，会是怎么样的呢？&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;import &amp;quot;fmt&amp;quot;\nfunc main() {\n\ti := 0\n\ttestFunc := test(&amp;amp;i)\n\ttestFunc()\n\tfmt.Printf(&amp;quot;outer i = %d\\n&amp;quot;, i)\n}\nfunc test(i *int) func() {\n\t*i = *i + 1\n\tfmt.Printf(&amp;quot;test inner i = %d\\n&amp;quot;, *i)\n\treturn func() {\n\t\t*i = *i + 1\n\t\tfmt.Printf(&amp;quot;func inner i = %d\\n&amp;quot;, *i)\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;运行结果如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;test inner i = 1\nfunc inner i = 2\nouter i = 2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看出如果是指针的话，闭包里面修改了指针对应的地址的值，也会影响闭包外面的值。这个其实很容易理解，Go 里面没有引用传递，只有值传递，那我们传递指针的时候，也是值传递，这里的值是指针的数值（可以理解为地址值）。&lt;/p&gt;\n&lt;p&gt;当我们函数的参数是指针的时候，参数会拷贝一份这个指针地址，当做参数进行传递，因为本质还是地址，所以内部修改的时候，仍然可以对外部产生影响。&lt;/p&gt;\n&lt;p&gt;闭包里面的数据其实地址也是一样的，下面的实验可以证明：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func main() {\n\ti := 0\n\ttestFunc := test(&amp;amp;i)\n\ttestFunc()\n\tfmt.Printf(&amp;quot;outer i address %v\\n&amp;quot;, &amp;amp;i)\n}\nfunc test(i *int) func() {\n\t*i = *i + 1\n\tfmt.Printf(&amp;quot;test inner i address %v\\n&amp;quot;, i)\n\treturn func() {\n\t\t*i = *i + 1\n\t\tfmt.Printf(&amp;quot;func inner i address %v\\n&amp;quot;, i)\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出如下, 因此可以推断出，闭包如果引用外部环境的指针数据，只是会拷贝一份指针地址数据，而不是拷贝一份真正的数据(&lt;mark&gt;先留个问题：拷贝的时机是什么时候呢&lt;/mark&gt;)：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;test inner i address 0xc0003fab98\nfunc inner i address 0xc0003fab98\nouter i address 0xc0003fab98\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;132-闭包延迟化\&#34;&gt;1.3.2 闭包延迟化&lt;/h3&gt;\n&lt;p&gt;上面的例子仿佛都在告诉我们，闭包创建的时候，数据就已经拷贝了，但是真的是这样么？&lt;/p&gt;\n&lt;p&gt;下面是继续前面的实验：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func main() {\n\ti := 0\n\ttestFunc := test(&amp;amp;i)\n\ti = i + 100\n\tfmt.Printf(&amp;quot;outer i before testFunc  %d\\n&amp;quot;, i)\n\ttestFunc()\n\tfmt.Printf(&amp;quot;outer i after testFunc %d\\n&amp;quot;, i)\n}\nfunc test(i *int) func() {\n\t*i = *i + 1\n\tfmt.Printf(&amp;quot;test inner i = %d\\n&amp;quot;, *i)\n\treturn func() {\n\t\t*i = *i + 1\n\t\tfmt.Printf(&amp;quot;func inner i = %d\\n&amp;quot;, *i)\n\t}\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;我们在创建闭包之后，把数据改了，之后执行闭包，答案肯定是真实影响闭包的执行，因为它们都是指针，都是指向同一份数据：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;test inner i = 1\nouter i before testFunc  101\nfunc inner i = 102\nouter i after testFunc 102\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;假设我们换个写法，让闭包外部环境中的变量在声明闭包函数的之后，进行修改：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;import &amp;quot;fmt&amp;quot;\n\nfunc main() {\n\tsumFunc := lazySum([]int{1, 2, 3, 4, 5})\n\tfmt.Println(&amp;quot;等待一会&amp;quot;)\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())\n}\nfunc lazySum(arr []int) func() int {\n\tfmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)\n\tcount := 0\n\tvar sum = func() int {\n\t\tfmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求结果...&amp;quot;)\n\t\tresult := 0\n\t\tfor _, v := range arr {\n\t\t\tresult = result + v\n\t\t}\n\t\treturn result\n\t}\n\tcount = count + 100\n\treturn sum\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;实际执行结果，&lt;code&gt;count&lt;/code&gt; 会是修改后的值：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;等待一会\n第 100 次求结果...\n结果： 15\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;这也证明了，实际上闭包并不会在声明&lt;code&gt;var sum = func() int {...}&lt;/code&gt;这句话之后，就将外部环境的 &lt;code&gt;count&lt;/code&gt;绑定到闭包中，而是在函数返回闭包函数的时候，才绑定的，这就是&lt;strong&gt;延迟绑定&lt;/strong&gt;。&lt;/p&gt;\n&lt;p&gt;如果还没看明白没关系，我们再来一个例子：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;func main() {\n\tfuncs := testFunc(100)\n\tfor _, v := range funcs {\n\t\tv()\n\t}\n}\nfunc testFunc(x int) []func() {\n\tvar funcs []func()\n\tvalues := []int{1, 2, 3}\n\tfor _, val := range values {\n\t\tfuncs = append(funcs, func() {\n\t\t\tfmt.Printf(&amp;quot;testFunc val = %d\\n&amp;quot;, x+val)\n\t\t})\n\t}\n\treturn funcs\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;上面的例子，我们闭包返回的是函数数组，本意我们想入每一个 &lt;code&gt;val&lt;/code&gt; 都不一样，但是实际上 &lt;code&gt;val&lt;/code&gt;都是一个值，&lt;mark&gt;也就是执行到&lt;code&gt;return funcs&lt;/code&gt; 的时候（或者真正执行闭包函数的时候）才绑定的 &lt;code&gt;val&lt;/code&gt;值&lt;/mark&gt;（关于这一点，后面还有个Demo可以证明），此时 &lt;code&gt;val&lt;/code&gt;的值是最后一个 &lt;code&gt;3&lt;/code&gt;,最终输出结果都是 &lt;code&gt;103&lt;/code&gt;:&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;testFunc val = 103\ntestFunc val = 103\ntestFunc val = 103\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;以上两个例子，都是闭包延迟绑定的问题导致，这也可以说是 feature，到这里可能不少同学还是对闭包绑定外部变量的时机有疑惑，到底是返回闭包函数的时候绑定的呢？还是真正执行闭包函数的时候才绑定的呢？&lt;/p&gt;\n&lt;p&gt;下面的例子可以有效的解答：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;import (\n\t&amp;quot;fmt&amp;quot;\n\t&amp;quot;time&amp;quot;\n)\n\nfunc main() {\n\tsumFunc := lazySum([]int{1, 2, 3, 4, 5})\n\tfmt.Println(&amp;quot;等待一会&amp;quot;)\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())\n\ttime.Sleep(time.Duration(3) * time.Second)\n\tfmt.Println(&amp;quot;结果：&amp;quot;, sumFunc())\n}\nfunc lazySum(arr []int) func() int {\n\tfmt.Println(&amp;quot;先获取函数，不求结果&amp;quot;)\n\tcount := 0\n\tvar sum = func() int {\n\t\tcount++\n\t\tfmt.Println(&amp;quot;第&amp;quot;, count, &amp;quot;次求结果...&amp;quot;)\n\t\tresult := 0\n\t\tfor _, v := range arr {\n\t\t\tresult = result + v\n\t\t}\n\t\treturn result\n\t}\n\tgo func() {\n\t\ttime.Sleep(time.Duration(1) * time.Second)\n\t\tcount = count + 100\n\t\tfmt.Println(&amp;quot;go func 修改后的变量 count：&amp;quot;, count)\n\t}()\n\treturn sum\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;输出结果如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;先获取函数，不求结果\n等待一会\n第 1 次求结果...\n结果： 15\ngo func 修改后的变量 count： 101\n第 102 次求结果...\n结果： 15\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;第二次执行闭包函数的时候，明显 &lt;code&gt;count&lt;/code&gt;被里面的 &lt;code&gt;go func()&lt;/code&gt;修改了，也就是调用的时候，才真正的获取最新的外部环境，但是在声明的时候，就会把环境预留保存下来。&lt;/p&gt;\n&lt;p&gt;其实本质上，&lt;strong&gt;Go Routine的匿名函数的延迟绑定就是闭包的延迟绑定&lt;/strong&gt;，上面的例子中，&lt;code&gt;go func(){}&lt;/code&gt;获取到的就是最新的值，而不是原始值&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;\n&lt;p&gt;总结一下上面的验证点：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;闭包每次返回都是一个新的实例，每个实例都有一份自己的环境。&lt;/li&gt;\n&lt;li&gt;同一个实例多次执行，会使用相同的环境。&lt;/li&gt;\n&lt;li&gt;闭包如果逃逸的是指针，会相互影响，因为绑定的是指针，相同指针的内容修改会相互影响。&lt;/li&gt;\n&lt;li&gt;闭包并不是在声明时绑定的值，声明后只是预留了外部环境（逃逸分析），真正执行闭包函数时，会获取最新的外部环境的值（也称为延迟绑定）。&lt;/li&gt;\n&lt;li&gt;Go Routine的匿名函数的延迟绑定本质上就是闭包的延迟绑定。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h1 id=\&#34;2-闭包的好处与坏处\&#34;&gt;2、闭包的好处与坏处？&lt;/h1&gt;\n&lt;h2 id=\&#34;21-好处\&#34;&gt;2.1 好处&lt;/h2&gt;\n&lt;p&gt;纯函数没有状态，而闭包则是让函数轻松拥有了状态。但是凡事都有两面性，一旦拥有状态，多次调用，可能会出现不一样的结果，就像是前面测试的 case 中一样。那么问题来了：&lt;/p&gt;\n&lt;p&gt;Q：&lt;strong&gt;如果不支持闭包的话，我们想要函数拥有状态，需要怎么做呢？&lt;/strong&gt;&lt;/p&gt;\n&lt;p&gt;A： 需要使用全局变量，让所有函数共享同一份变量。&lt;/p&gt;\n&lt;p&gt;但是我们都知道全局变量有以下的一些特点（在不同的场景，优点会变成缺点）：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;常驻于内存之中，只要程序不停会一直在内存中。&lt;/li&gt;\n&lt;li&gt;污染全局，大家都可以访问，共享的同时不知道谁会改这个变量。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;闭包可以一定程度优化这个问题：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;不需要使用全局变量，外部函数局部变量在闭包的时候会创建一份，生命周期与函数生命周期一致，闭包函数不再被引用的时候，就可以回收了。&lt;/li&gt;\n&lt;li&gt;闭包暴露的局部变量，外界无法直接访问，只能通过函数操作，可以避免滥用。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;除了以上的好处，像在 JavaScript 中，没有原生支持私有方法，可以靠闭包来模拟私有方法，因为闭包都有自己的词法环境。&lt;/p&gt;\n&lt;h2 id=\&#34;22-坏处\&#34;&gt;2.2 坏处&lt;/h2&gt;\n&lt;p&gt;函数拥有状态，如果处理不当，会导致闭包中的变量被误改，但这是编码者应该考虑的问题，是预期中的场景。&lt;/p&gt;\n&lt;p&gt;闭包中如果随意创建，引用被持有，则无法销毁，同时闭包内的局部变量也无法销毁，过度使用闭包会占有更多的内存，导致性能下降。一般而言，能共享一份闭包（共享闭包局部变量数据），不需要多次创建闭包函数，是比较优雅的方式。&lt;/p&gt;\n&lt;h1 id=\&#34;3-闭包怎么实现的\&#34;&gt;3、闭包怎么实现的？&lt;/h1&gt;\n&lt;p&gt;从上面的实验中，我们可以知道，闭包实际上就是外部环境的逃逸，跟随着闭包函数一起暴露出去。&lt;/p&gt;\n&lt;p&gt;我们用以下的程序进行分析：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-go\&#34;&gt;import &amp;quot;fmt&amp;quot;\n\nfunc testFunc(i int) func() int {\n\ti = i * 2\n\ttestFunc := func() int {\n\t\ti++\n\t\treturn i\n\t}\n\ti = i * 2\n\treturn testFunc\n}\nfunc main() {\n\ttest := testFunc(1)\n\tfmt.Println(test())\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;执行结果如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;先看看逃逸分析，用下面的命令行可以查看：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt; go build --gcflags=-m main.go\n&lt;/code&gt;&lt;/pre&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;4\&#34;&gt;&lt;img src=\&#34;https://gitee.com/Damaer/pic/raw/master/image-20221120223253318.png\&#34; alt=\&#34;image-20221120223253318\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;可以看到 变量 &lt;code&gt;i&lt;/code&gt;被移到堆中，也就是本来是局部变量，但是发生逃逸之后，从栈里面放到堆里面，同样的 &lt;code&gt;test()&lt;/code&gt;函数由于是闭包函数，也逃逸到堆上。&lt;/p&gt;\n&lt;p&gt;下面我们用命令行来看看汇编代码：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;go tool compile -N -l -S main.go\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;生成代码比较长，我截取一部分：&lt;/p&gt;\n&lt;pre&gt;&lt;code class=\&#34;language-shell\&#34;&gt;&amp;quot;&amp;quot;.testFunc STEXT size=218 args=0x8 locals=0x38 funcid=0x0 align=0x0\n        0x0000 00000 (main.go:5)        TEXT    &amp;quot;&amp;quot;.testFunc(SB), ABIInternal, $56-8\n        0x0000 00000 (main.go:5)        CMPQ    SP, 16(R14)\n        0x0004 00004 (main.go:5)        PCDATA  $0, $-2\n        0x0004 00004 (main.go:5)        JLS     198\n        0x000a 00010 (main.go:5)        PCDATA  $0, $-1\n        0x000a 00010 (main.go:5)        SUBQ    $56, SP\n        0x000e 00014 (main.go:5)        MOVQ    BP, 48(SP)\n        0x0013 00019 (main.go:5)        LEAQ    48(SP), BP\n        0x0018 00024 (main.go:5)        FUNCDATA        $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)\n        0x0018 00024 (main.go:5)        FUNCDATA        $1, gclocals·d571c0f6cf0af59df28f76498f639cf2(SB)\n        0x0018 00024 (main.go:5)        FUNCDATA        $5, &amp;quot;&amp;quot;.testFunc.arginfo1(SB)\n        0x0018 00024 (main.go:5)        MOVQ    AX, &amp;quot;&amp;quot;.i+64(SP)\n        0x001d 00029 (main.go:5)        MOVQ    $0, &amp;quot;&amp;quot;.~r0+16(SP)\n        0x0026 00038 (main.go:5)        LEAQ    type.int(SB), AX\n        0x002d 00045 (main.go:5)        PCDATA  $1, $0\n        0x002d 00045 (main.go:5)        CALL    runtime.newobject(SB)\n        0x0032 00050 (main.go:5)        MOVQ    AX, &amp;quot;&amp;quot;.&amp;amp;i+40(SP)\n        0x0037 00055 (main.go:5)        MOVQ    &amp;quot;&amp;quot;.i+64(SP), CX\n        0x003c 00060 (main.go:5)        MOVQ    CX, (AX)\n        0x003f 00063 (main.go:6)        MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), CX\n        0x0044 00068 (main.go:6)        MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), DX\n        0x0049 00073 (main.go:6)        MOVQ    (DX), DX\n        0x004c 00076 (main.go:6)        SHLQ    $1, DX\n        0x004f 00079 (main.go:6)        MOVQ    DX, (CX)\n        0x0052 00082 (main.go:7)        LEAQ    type.noalg.struct { F uintptr; &amp;quot;&amp;quot;.i *int }(SB), AX\n        0x0059 00089 (main.go:7)        PCDATA  $1, $1\n        0x0059 00089 (main.go:7)        CALL    runtime.newobject(SB)\n        0x005e 00094 (main.go:7)        MOVQ    AX, &amp;quot;&amp;quot;..autotmp_3+32(SP)\n        0x0063 00099 (main.go:7)        LEAQ    &amp;quot;&amp;quot;.testFunc.func1(SB), CX\n        0x006a 00106 (main.go:7)        MOVQ    CX, (AX)\n        0x006d 00109 (main.go:7)        MOVQ    &amp;quot;&amp;quot;..autotmp_3+32(SP), CX\n        0x0072 00114 (main.go:7)        TESTB   AL, (CX)\n        0x0074 00116 (main.go:7)        MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), DX\n        0x0079 00121 (main.go:7)        LEAQ    8(CX), DI\n        0x007d 00125 (main.go:7)        PCDATA  $0, $-2\n        0x007d 00125 (main.go:7)        CMPL    runtime.writeBarrier(SB), $0\n        0x0084 00132 (main.go:7)        JEQ     136\n        0x0086 00134 (main.go:7)        JMP     142\n        0x0088 00136 (main.go:7)        MOVQ    DX, 8(CX)\n        0x008c 00140 (main.go:7)        JMP     149\n        0x008e 00142 (main.go:7)        CALL    runtime.gcWriteBarrierDX(SB)\n        0x0093 00147 (main.go:7)        JMP     149\n        0x0095 00149 (main.go:7)        PCDATA  $0, $-1\n        0x0095 00149 (main.go:7)        MOVQ    &amp;quot;&amp;quot;..autotmp_3+32(SP), CX\n        0x009a 00154 (main.go:7)        MOVQ    CX, &amp;quot;&amp;quot;.testFunc+24(SP)\n        0x009f 00159 (main.go:11)       MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), CX\n        0x00a4 00164 (main.go:11)       MOVQ    &amp;quot;&amp;quot;.&amp;amp;i+40(SP), DX\n        0x00a9 00169 (main.go:11)       MOVQ    (DX), DX\n        0x00ac 00172 (main.go:11)       SHLQ    $1, DX\n        0x00af 00175 (main.go:11)       MOVQ    DX, (CX)\n        0x00b2 00178 (main.go:12)       MOVQ    &amp;quot;&amp;quot;.testFunc+24(SP), AX\n        0x00b7 00183 (main.go:12)       MOVQ    AX, &amp;quot;&amp;quot;.~r0+16(SP)\n        0x00bc 00188 (main.go:12)       MOVQ    48(SP), BP\n        0x00c1 00193 (main.go:12)       ADDQ    $56, SP\n        0x00c5 00197 (main.go:12)       RET\n        0x00c6 00198 (main.go:12)       NOP\n        0x00c6 00198 (main.go:5)        PCDATA  $1, $-1\n        0x00c6 00198 (main.go:5)        PCDATA  $0, $-2\n        0x00c6 00198 (main.go:5)        MOVQ    AX, 8(SP)\n        0x00cb 00203 (main.go:5)        CALL    runtime.morestack_noctxt(SB)\n        0x00d0 00208 (main.go:5)        MOVQ    8(SP), AX\n        0x00d5 00213 (main.go:5)        PCDATA  $0, $-1\n        0x00d5 00213 (main.go:5)        JMP     0\n\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;可以看到闭包函数实际上底层也是用结构体&lt;code&gt;new&lt;/code&gt;创建出来的：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;5\&#34;&gt;&lt;img src=\&#34;https://gitee.com/Damaer/pic/raw/master/image-20221120224413412.png\&#34; alt=\&#34;image-20221120224413412\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;使用的就是堆上面的&lt;code&gt; i&lt;/code&gt;：&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;6\&#34;&gt;&lt;img src=\&#34;https://gitee.com/Damaer/pic/raw/master/image-20221120225532865.png\&#34; alt=\&#34;image-20221120225532865\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;p&gt;也就是返回函数的时候，实际上返回结构体，结构体里面记录了函数的引用环境。&lt;/p&gt;\n&lt;h1 id=\&#34;4-浅聊一下\&#34;&gt;4、浅聊一下&lt;/h1&gt;\n&lt;h2 id=\&#34;41-java-支不支持闭包\&#34;&gt;4.1 Java 支不支持闭包？&lt;/h2&gt;\n&lt;p&gt;网上有很多种看法，实际上 Java 虽然暂时不支持返回函数作为返参，但是Java 本质上还是实现了闭包的概念的，所使用的的方式是内部类的形式，因为是内部类，所以相当于自带了一个引用环境，算是一种不完整的闭包。&lt;/p&gt;\n&lt;p&gt;目前有一定限制，比如是 &lt;code&gt;final &lt;/code&gt;声明的，或者是明确定义的值，才可以进行传递：&lt;/p&gt;\n&lt;p&gt;Stack Overflow上有相关答案：https://stackoverflow.com/questions/5443510/closure-in-java-7&lt;/p&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;7\&#34;&gt;&lt;img src=\&#34;https://gitee.com/Damaer/pic/raw/master/image-20221120233223203.png\&#34; alt=\&#34;image-20221120233223203\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;42-函数式编程的前景怎么样\&#34;&gt;4.2 函数式编程的前景怎么样？&lt;/h2&gt;\n&lt;p&gt;下面是Wiki的内容：&lt;/p&gt;\n&lt;blockquote&gt;\n&lt;p&gt;函数式编程长期以来在学术界流行，但几乎没有工业应用。造成这种局面的主因是函数式编程常被认为严重耗费CPU和存储器资源[&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-18\&#34;&gt;18]&lt;/a&gt; ，这是由于在早期实现函数式编程语言时并没有考虑过效率问题，而且面向函数式编程特性，如保证&lt;a href=\&#34;https://zh.wikipedia.org/w/index.php?title=%E5%8F%82%E7%85%A7%E9%80%8F%E6%98%8E%E6%80%A7&amp;amp;action=edit&amp;amp;redlink=1\&#34;&gt;参照透明性&lt;/a&gt;等，要求独特的数据结构和算法。[&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-programmingScala-19\&#34;&gt;19]&lt;/a&gt;&lt;/p&gt;\n&lt;p&gt;然而，最近几种函数式编程语言已经在商业或工业系统中使用[&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-20\&#34;&gt;20]&lt;/a&gt;，例如：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://zh.wikipedia.org/wiki/Erlang\&#34;&gt;Erlang&lt;/a&gt;，它由瑞典公司&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E7%88%B1%E7%AB%8B%E4%BF%A1\&#34;&gt;爱立信&lt;/a&gt;在20世纪80年代后期开发，最初用于实现容错电信系统。此后，它已在&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%8C%97%E7%94%B5%E7%BD%91%E7%BB%9C\&#34;&gt;Nortel&lt;/a&gt;、&lt;a href=\&#34;https://zh.wikipedia.org/wiki/Facebook\&#34;&gt;Facebook&lt;/a&gt;、&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E6%B3%95%E5%9B%BD%E7%94%B5%E5%8A%9B%E5%85%AC%E5%8F%B8\&#34;&gt;Électricité de France&lt;/a&gt;和&lt;a href=\&#34;https://zh.wikipedia.org/wiki/WhatsApp\&#34;&gt;WhatsApp&lt;/a&gt;等公司作为流行语言创建一系列应用程序。[&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-21\&#34;&gt;21]&lt;/a&gt;[&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-whatsapp.blog.2012-22\&#34;&gt;22]&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://zh.wikipedia.org/wiki/Scheme\&#34;&gt;Scheme&lt;/a&gt;，它被用作早期&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E8%8B%B9%E6%9E%9C%E5%85%AC%E5%8F%B8\&#34;&gt;Apple&lt;/a&gt; &lt;a href=\&#34;https://zh.wikipedia.org/wiki/Macintosh\&#34;&gt;Macintosh&lt;/a&gt;计算机上的几个应用程序的基础，并且最近已应用于诸如训练模拟软件和望远镜控制等方向。&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://zh.wikipedia.org/wiki/OCaml\&#34;&gt;OCaml&lt;/a&gt;，它于20世纪90年代中期推出，已经在金融分析，驱动程序验证，工业机器人编程和嵌入式软件静态分析等领域得到了商业应用。&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://zh.wikipedia.org/wiki/Haskell\&#34;&gt;Haskell&lt;/a&gt;，它虽然最初是作为一种研究语言，也已被一系列公司应用于航空航天系统，硬件设计和网络编程等领域。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;其他在工业中使用的函数式编程语言包括多范型的&lt;a href=\&#34;https://zh.wikipedia.org/wiki/Scala\&#34;&gt;Scala&lt;/a&gt;[&lt;a href=\&#34;https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B#cite_note-23\&#34;&gt;23]&lt;/a&gt;、&lt;a href=\&#34;https://zh.wikipedia.org/wiki/F%EF%BC%83\&#34;&gt;F#&lt;/a&gt;，还有&lt;a href=\&#34;https://zh.wikipedia.org/wiki/Wolfram%E8%AF%AD%E8%A8%80\&#34;&gt;Wolfram语言&lt;/a&gt;、&lt;a href=\&#34;https://zh.wikipedia.org/wiki/Common_Lisp\&#34;&gt;Common Lisp&lt;/a&gt;、&lt;a href=\&#34;https://zh.wikipedia.org/wiki/Standard_ML\&#34;&gt;Standard ML&lt;/a&gt;和&lt;a href=\&#34;https://zh.wikipedia.org/wiki/Clojure\&#34;&gt;Clojure&lt;/a&gt;等。&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;p&gt;从我个人的看法，不看好纯函数编程，但是函数式编程的思想，我相信以后几乎每门高级编程需要都会具备，特别期待 Java 拥抱函数式编程。从我自己了解的语言看，像 Go，JavaScript 中的函数式编程的特性，都让开发者深爱不已（当然，如果写出了bug，就是深恶痛疾）。&lt;/p&gt;\n&lt;p&gt;最近突然火了一波的原因，也是因为世界不停的发展，内存也越来越大，这个因素的限制几乎要解放了。&lt;/p&gt;\n&lt;p&gt;我相信，世界就是绚丽多彩的，要是一种事物统治世界，绝无可能，更多的是百家争鸣，编程语言或者编程范式也一样，后续可能有集大成者，最终最终历史会筛选出最终符合人类社会发展的。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;go-zhong-de-bi-bao-dao-di-shi-sha&#34;,&#34;abstract&#34;:&#34;&lt;meta name=\&#34;referrer\&#34; content=\&#34;no-referrer\&#34; /&gt;\n&lt;p&gt;以前写 Java 的时候，听到前端同学谈论闭包，觉得甚是新奇，后面自己写了一小段时间 JS，虽只学到皮毛，也大概了解到闭包的概念，现在工作常用语言是 Go，很多优雅的代码中总是有闭包的身影，看来不了解个透是不可能的了，本文让我来科普(按照自己水平随便瞎扯)一下：&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Go 中的闭包到底是啥？&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Go&#34;,&#34;slug&#34;:&#34;QDrVtldDx&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://aphysia.cn/tag/QDrVtldDx/&#34;}],&#34;date&#34;:&#34;2023-01-06 23:43:36&#34;,&#34;dateFormat&#34;:&#34;2023-01-06&#34;,&#34;feature&#34;:&#34;https://aphysia.cn/post-images/go-zhong-de-bi-bao-dao-di-shi-sha.png&#34;,&#34;link&#34;:&#34;https://aphysia.cn/post/go-zhong-de-bi-bao-dao-di-shi-sha/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;27 min read&#34;,&#34;time&#34;:1579000,&#34;words&#34;:6504,&#34;minutes&#34;:27},&#34;description&#34;:&#34;\n以前写 Java 的时候，听到前端同学谈论闭包，觉得甚是新奇，后面自己写了一小段时间 JS，虽只学到皮毛，也大概了解到闭包的概念，现在工作常用语言是 Go，很多优雅的代码中总是有闭包的身影，看来不了解个透是不可能的了，本文让我来科普(按照...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85\&#34;&gt;1、什么是闭包？&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#11-%E5%89%8D%E6%8F%90%E7%9F%A5%E8%AF%86%E9%93%BA%E5%9E%AB\&#34;&gt;1.1 前提知识铺垫&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#121-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\&#34;&gt;1.2.1 函数式编程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#122-%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F\&#34;&gt;1.2.2 函数作用域&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#123-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB\&#34;&gt;1.2.3 作用域的继承关系&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#12-%E9%97%AD%E5%8C%85%E7%9A%84%E5%AE%9A%E4%B9%89\&#34;&gt;1.2 闭包的定义&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#13-%E9%97%AD%E5%8C%85%E7%9A%84%E5%86%99%E6%B3%95\&#34;&gt;1.3 闭包的写法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#131-%E5%88%9D%E7%9C%8B%E9%97%AD%E5%8C%85\&#34;&gt;1.3.1 初看闭包&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#132-%E9%97%AD%E5%8C%85%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E5%80%BC\&#34;&gt;1.3.2 闭包中的指针和值&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#132-%E9%97%AD%E5%8C%85%E5%BB%B6%E8%BF%9F%E5%8C%96\&#34;&gt;1.3.2 闭包延迟化&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#2-%E9%97%AD%E5%8C%85%E7%9A%84%E5%A5%BD%E5%A4%84%E4%B8%8E%E5%9D%8F%E5%A4%84\&#34;&gt;2、闭包的好处与坏处？&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#21-%E5%A5%BD%E5%A4%84\&#34;&gt;2.1 好处&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#22-%E5%9D%8F%E5%A4%84\&#34;&gt;2.2 坏处&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#3-%E9%97%AD%E5%8C%85%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84\&#34;&gt;3、闭包怎么实现的？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#4-%E6%B5%85%E8%81%8A%E4%B8%80%E4%B8%8B\&#34;&gt;4、浅聊一下&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#41-java-%E6%94%AF%E4%B8%8D%E6%94%AF%E6%8C%81%E9%97%AD%E5%8C%85\&#34;&gt;4.1 Java 支不支持闭包？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#42-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%89%8D%E6%99%AF%E6%80%8E%E4%B9%88%E6%A0%B7\&#34;&gt;4.2 函数式编程的前景怎么样？&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/love.js"></script>


<script src=" /media/js/cool.js"></script>


</html>